{"/blog/deadlock/":{"data":{"1-self-deadlock--recursive-deadlock#1. Self deadlock \u0026amp;\u0026amp; Recursive Deadlock":"Deadlock defination and how to prevent deadlock.\nSituations of deadlock In concurrent computing, deadlock is any situation in which no member of some group of entities can proceed because each waits for another member, including itself, to take action, such as sending a message or, more commonly, releasing a lock. Deadlocks are a common problem in multiprocessing systems, parallel computing, and distributed systems, because in these contexts systems often use software or hardware locks to arbitrate shared resources and implement process synchronization.\nIn an operating system, a deadlock occurs when a process or thread enters a waiting state because a requested system resource is held by another waiting process, which in turn is waiting for another resource held by another waiting process. If a process remains indefinitely unable to change its state because resources requested by it are being used by another process that itself is waiting, then the system is said to be in a deadlock.\nIn a communications system, deadlocks occur mainly due to loss or corruption of signals rather than contention for resources.\nAvoid Deadlock in Concurrent ProgrammingDeadlock is a permanent blocking of a set of threads that are competing for a set of resources. Just because some thread can make progress does not mean that there is not a deadlock somewhere else.\n1. Self deadlock \u0026amp;\u0026amp; Recursive Deadlock The most common error causing deadlock is\nSelf deadlock: a thread tries to acquire a lock it is already holding. Recursive deadlock: is very easy to program by mistake. For example, if a code monitor has every module function grabbing the mutex lock for the duration of the call, then any call between the functions within the module protected by the mutex lock immediately deadlocks. If a function calls some code outside the module which, through some circuitous path, calls back into any method protected by the same mutex lock, then it will deadlock too.\nSolution The solution for this kind of deadlock is to avoid calling functions outside the module when you don\u0026rsquo;t know whether they will call back into the module without reestablishing invariants and dropping all module locks before making the call. Of course, after the call completes and the locks are reacquired, the state must be verified to be sure the intended operation is still valid.\nSummary: avoid calling functions outside the module and if called, it has to be verified the intended operation is still valid.\n","2-permanent-blocking-of-threads#2. Permanent blocking of threads":"An example of another kind of deadlock is when two threads, thread 1 and thread 2, each acquires a mutex lock, A and B, respectively. Suppose that thread 1 tries to acquire mutex lock B and thread 2 tries to acquire mutex lock A. Thread 1 cannot proceed and it is blocked waiting for mutex lock B. Thread 2 cannot proceed and it is blocked waiting for mutex lock A. Nothing can change, so this is a permanent blocking of the threads, and a deadlock.\nSolution1: lock hierarchy This kind of deadlock is avoided by establishing an order in which locks are acquired (a lock hierarchy). When all threads always acquire locks in the specified order, this deadlock is avoided.\nSummary: not optimal. The discarded lock might have many assumptions and need to reevaluate later.\nSolution2: mutex_trylock() Adhering to a strict order of lock acquisition is not always optimal. When thread 2 has many assumptions about the state of the module while holding mutex lock B, giving up mutex lock B to acquire mutex lock A and then reacquiring mutex lock B in order would cause it to discard its assumptions and reevaluate the state of the module.\nThe blocking synchronization primitives usually have variants that attempt to get a lock and fail if they cannot, such as mutex_trylock().\nSummary: optimal. This allows threads to violate the lock hierarchy when there is no contention. When there is contention, the held locks must usually be discarded and the locks reacquired in order.\n","3-deadlocks-related-to-scheduling#3. Deadlocks Related to Scheduling":"Because there is no guaranteed order in which locks are acquired, a problem in threaded programs is that a particular thread never acquires a lock, even though it seems that it should.\nThis usually happens when the thread that holds the lock releases it, lets a small amount of time pass, and then reacquires it. Because the lock was released, it might seem that the other thread should acquire the lock. But, because nothing blocks the thread holding the lock, it continues to run from the time it releases the lock until it reacquires the lock, and so no other thread is run.\nYou can usually solve this type of problem by calling thr_yield(3T) just before the call to reacquire the lock. This allows other threads to run and to acquire the lock.\nBecause the time-slice requirements of applications are so variable, the threads library does not impose any. Use calls to thr_yield() to make threads share time as you require.\n","avoid-deadlock-in-concurrent-programming#Avoid Deadlock in Concurrent Programming":"","locking-guidelines#Locking Guidelines":"Here are some simple guidelines for locking.\nTry not to hold locks across long operations like I/O where performance can be adversely affected. Don\u0026rsquo;t hold locks when calling a function that is outside the module and that might reenter the module. In general, start with a coarse-grained approach, identify bottlenecks, and add finer-grained locking where necessary to alleviate the bottlenecks. Most locks are held for short amounts of time and contention is rare, so fix only those locks that have measured contention. When using multiple locks, avoid deadlocks by making sure that all threads acquire the locks in the same order. ","situations-of-deadlock#Situations of deadlock":""},"title":"Deadlock"},"/blog/dynamic_programming/":{"data":{"":"","chapter-1-dp-入门#Chapter 1: DP 入门":"","chapter-10-骰子求和背包型#Chapter 10: 骰子求和：背包型":" Lintcode 20 骰子求和 本质上这道题是求方案数\n核心的是看状态是什么：\n状态：用来表示一个子问题的一些参数凑在一起 这道题的状态： 背包型 f[i][j] 表示前i次骰子（掷i次骰子）我能够凑出和为j的概率是多少 能想出这个的原因： 影响到状态，影响到每个计算结果的是掷多少次 我们要求的和，求的和是1，求的和是2，的概率也不一样 将以上两个信息全部放到状态当中去 class Solution { public: std::vector\u0026lt;std::pair\u0026lt;int, double\u0026gt;\u0026gt; dicesSum(int n) { std::vector\u0026lt;std::pair\u0026lt;int, double\u0026gt;\u0026gt; result; std::vector\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;double\u0026gt;(6 * n + 1, 0)); // has to be double for (int i = 1; i \u0026lt;= 6; ++i) { f[1][i] = 1.0 / 6; } for (int i = 2; i \u0026lt;= n; ++i) { for (int j = i; j \u0026lt;= 6 * n; ++j) { // n or i, both work for (int k = 1; k \u0026lt;= 6; ++k) { if (j \u0026gt; k) { f[i][j] += f[i - 1][j - k]; } } f[i][j] /= 6.0; } } for (int j = n; j \u0026lt;= 6 * n; ++j) { result.push_back(std::make_pair(j, f[n][j])); } return result; } }; ","chapter-11-最长有效括号后缀型与前缀型只区别与计算顺序#Chapter 11: 最长有效括号：后缀型(与前缀型只区别与计算顺序)":" Lintcode 193 最长有效括号\n字符串的题目特别多的题目都是前缀型 或 后缀型\n设状态dp[i]为从i到len - 1中，以i开头的最长合法子串长度 初始化：dp[len - 1] = 0 如果s[i] = ')'，则跳过，因为不可能有由'('开头的串 如果s[i] = '(', 则需要找到右括号和它匹配。可以跳过以i + 1开头的合法子串，看j = i + dp[i + 1] + 1的位置是否为右括号。 如果位置i没越界且为右括号，那么有dp[i] = dp[i + 1] + 2，此外在这个基础上还要将j + 1开头的子串加进来（只要不越界）。 class Solution { public: int longestValidParentheses(std::string\u0026amp; s) { int n = s.size(); if (n \u0026lt; 2) { return 0; } int result = 0; // int dp[n] should have an additional step to initialize all elements to zero std::vector\u0026lt;int\u0026gt; dp(n, 0); for (int i = n - 2; i \u0026gt;= 0; --i) { if (s[i] == \u0026#39;(\u0026#39;) { int j = i + dp[i + 1] + 1; // 如果没越界且为右括号 if (j \u0026lt; n \u0026amp;\u0026amp; s[j] == \u0026#39;)\u0026#39;) { dp[i] = dp[i + 1] + 2; // 还要将j + 1开头的子串加进来 if (j + 1 \u0026lt; n) { dp[i] += dp[j + 1]; } } result = std::max(result, dp[i]); } } return result; } }; ","chapter-12-最大子数组差#Chapter 12: 最大子数组差":" Lintcode 45 最大子数组差\n关键字不重叠，应该想到隔板法\n因为区间不重合，那么他们肯定会被一个隔板隔开，我们枚举隔板，再去算左右两边的 最大区间和 和 最小区间和\nMine solution class Solution { public: int maxDiffSubArrays(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt; 2) { return 0; } std::vector\u0026lt;int\u0026gt; prefix_sum(n + 1, 0); for (int i = 1; i \u0026lt; n + 1; ++i) { prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]; } std::vector\u0026lt;int\u0026gt; left_max(n, nums[0]); std::vector\u0026lt;int\u0026gt; right_max(n, nums[n - 1]); std::vector\u0026lt;int\u0026gt; left_min(n, nums[0]); std::vector\u0026lt;int\u0026gt; right_min(n, nums[n - 1]); int temp_min = nums[0]; int temp_max = nums[0]; for (int i = 1; i \u0026lt; n; ++i) { } } }; Official Solution: with some Greedy idea class Solution { public: int maxDiffSubArrays(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt; 2) { return 0; } // max_sum_of_left[i], min_sum_of_left[i]分别表示从左到i的范围内的子数组最大/最小和 int max_sum_of_left[n]; int min_sum_of_left[n]; // max_sum_of_right[i], min_sum_of_right[i]分别表示从右到i的范围内的子数组最大/最小和 int max_sum_of_right[n]; int min_sum_of_right[n]; // 求从左到i的范围内的子数组最大和 max_sum_of_left[0] = nums[0]; for (int i = 1, now = nums[0]; i \u0026lt; n; ++i) { now = std::max(nums[i], now + nums[i]); max_sum_of_left[i] = std::max(max_sum_of_left[i - 1], now); } // 求从右到i的范围内的子数组最大和 max_sum_of_right[n - 1] = nums[n - 1]; for (int i = n - 2, now = nums[n - 1]; i \u0026gt;= 0; --i) { now = std::max(nums[i], now + nums[i]); max_sum_of_right[i] = std::max(max_sum_of_right[i + 1], now); } // 求从左到i的范围内的子数组最小和 min_sum_of_left[0] = nums[0]; for (int i = 1, now = nums[0]; i \u0026lt; n; ++i) { now = std::min(nums[i], now + nums[i]); min_sum_of_left[i] = std::min(min_sum_of_left[i - 1], now); } // 求从右到i的范围内的子数组最小和 min_sum_of_right[n - 1] = nums[n - 1]; for (int i = n - 2, now = nums[n - 1]; i \u0026gt;= 0; --i) { now = std::min(nums[i], now + nums[i]); min_sum_of_right[i] = std::min(min_sum_of_right[i + 1], now); } int ans = 0xcfcfcfcf; for (int i = 0; i \u0026lt; n - 1; ++i) { // max(左大右小的差值，左小右大的差值) ans = std::max(ans, std::max(std::abs(max_sum_of_left[i] - min_sum_of_right[i + 1]), std::abs(min_sum_of_left[i] - max_sum_of_right[i + 1]))); } return ans; } }; 相关题目 Lintcode 1833 钢笔盒\nLintcode 1850 捡苹果\n","chapter-13-工作安排坐标型#Chapter 13: 工作安排：坐标型":" Lintcode 1147 工作安排 Compared to the question of house robbers, not only do we have to decide whether to pick the task(whether to rob the current house) but also we have to determine what task we will choose(simple or complex)\n状态：令dp[i]表示前i周可完成的最大价值 状态转移：dp[i] = max(dp[i - 1] + low[i], dp[i - 2] + high[i]) 临界值：第一周只能选择简单任务 class Solution { public: int workPlan(std::vector\u0026lt;int\u0026gt;\u0026amp; low, std::vector\u0026lt;int\u0026gt;\u0026amp; high) { int n = low.size(); int dp[n]; if (n == 0) { return 0; } dp[0] = low[0]; for (int i = 1; i \u0026lt; n; ++i) { if (i \u0026lt; 2) { dp[i] = std::max(dp[i - 1] + low[i], high[i]); continue; } dp[i] = std::max(dp[i - 1] + low[i], dp[i - 2] + high[i]); } return dp[n - 1]; } }; 思考：如果有负数怎么办？\n","chapter-14-染色问题坐标型#Chapter 14: 染色问题：坐标型":" Lintcode 1444 染色问题\nState: let dp[i] represents the total number of plans when circle is divided into i sectors\nInitialization:\nwhen i == 1, we can use at least 1 color, A(m, 1) : dp[1] = m when i % 2 == 0, we can use at least 2 color, A(m, 2) : dp[2] = m * (m - 1) when i % 2 == 1 \u0026amp;\u0026amp; i \u0026gt;= 3, we can use at least 3 color, A(m, 3) : dp[3] = m * (m - 1) * (m - 2) Function:\nthe n sectors problem can be derived from n - 1 sectors sub-problem and n - 2 sectors sub-problem Regarding to n - 1 sectors sub-problem, it has dp[n - 1] color plans. Due to the colors of adjacent sectors cannot be the same, when we insert a new sector between two sectors, the number of plans is m - 2, and then the total number of color plans is dp[n - 1] * (m - 2) function 1: dp[i] += dp[i - 1] * (m - 2) Regarding to n - 2 sectors sub-problem, it has dp[n - 2] color plans We just choose one sector and then split it into two sectors with the same colors, and then insert a new sector between these two same color sectors. Then we have dp[n - 2] * (m - 1) the number of color plans function 2: dp[i] += dp[i - 2] * (m - 1) Answer:\nWhen calculating the result, we should add module operation within calculation to avoid overflowing dp[n] is the final answer Time Complexity: O(n) Space Complexity: O(n)\nclass Solution { public: int getCount(int n, int m) { long long MOD = 1000000007; // long long dp[n + 3]; // ERROR: each value has to be initialized to zero // dp[i] represent number of color plans when we have i sectors and m colors std::vector\u0026lt;long long\u0026gt; dp(n + 3, 0); // one sector has m color plans dp[1] = m % MOD; // two sectors have m * (m - 1) color plans dp[2] = (long long)m * (m - 1) % MOD; // three sectors have m * (m - 1) * (m - 2) color plans dp[3] = (long long)m * (m - 1) * (m - 2) % MOD; for (int i = 4; i \u0026lt;= n; ++i) { dp[i] += dp[i - 1] * (m - 2) % MOD; dp[i] += dp[i - 2] * (m - 1) % MOD; dp[i] %= MOD; // dp[i] = (dp[i - 1] * (m - 2) + dp[i - 2] * (m - 1)) % MOD; // alternative } return (int)dp[n]; } }; Note: long long dp[n + 5]; // each value has to be initialized to zero we can also optimize space with rolling array\n","chapter-15-最小的窗口子序列匹配型#Chapter 15: 最小的窗口子序列：匹配型":" Lintcode 857 MinWindow This problem is very similar to The Problem of LCS and The Problem of Edit Distance, given two strings which means 匹配型动态规划\n匹配型动态规划开(n + 1)(m + 1)的数组， 类似于背包型动态规划 这个题的题目名看起来和很多题目有相似之处，如“滑动窗口的最小值”等，那里我们使用单调队列进行求解，不要弄混\nThe first solution with O(n^2 * (n + m)) approximate to O(n^3) The first solution we should come up with is brute force: use O(n^2) to find all sub-string of a string, and then check each sub-string whether they include the sub-sequence of string T. The total time cost O(n^2 * (n + m)) The second solution with O(n * (n + m)) approximate to O(n^2), we should let time less than 10^8, if n is 20000, then it becomes 4 * 10^8 \u0026gt; 10^8, which is not good Then to optimize time complexity, we should consider which part can be optimized. The first part which is to find the sub-string. We just enumerate left of sub-string and ignore right of sub-string. Then the total time becomes O(n * (n + m)) The thrid solution: Dynamic Programming: Time O(n * m) Space O(n * m) State: let dp[i][j] represent the left start pointer which successfully have previous j characters of string T is the sub-sequence of previous i characters of string S\n状态：令dp[i][j]表示成功匹配T串的前j个字符为S中前i个字符的子序列时的匹配起点（即第几个字符）\nFunction:\nS[i] == T[j] \u0026amp;\u0026amp; j == 1 : dp[i][j] = i S[i] == T[j] \u0026amp;\u0026amp; j != 1 : dp[i][j] = dp[i - 1][j - 1] S[i] != T[j] : dp[i][j] = dp[i - 1][j] Initialization: dp[i][0] = 0 represents the left start pointer of pairation of an empty string and previous i characters of string S.\nExplanation: it equals to 0 means 0th character, not the index here Alternative: To initialize here is let dp[i][0] = -1, because index 0 represent a real character Answer:\nEnumerate dp[][T.size()]: if dp[i][T.size()] != 0(here 0 is 0th character, -1 is index), then here exist left start pointer of the window dp[i][T.size()], the length of window is i - dp[i][T.size()] + 1 At this time, we maintain our minimum length of window len and the most left start pointer start Answer: S.substr(start, start + len) class Solution { public: std::string minWindow(std::string\u0026amp; S, std::string\u0026amp; T) { int n = S.size(); int m = T.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { if (S[i - 1] == T[j - 1]) { if (j == 1) { dp[i][j] = i; } else { dp[i][j] = dp[i - 1][j - 1]; } } else { dp[i][j] = dp[i - 1][j]; } } } int start = 0; int len = n + 1; for (int i = 1; i \u0026lt;= n; ++i) { if (dp[i][m] != 0) { if (i - dp[i][m] + 1 \u0026lt; len) { start = dp[i][m] - 1; len = i - dp[i][m] + 1; } } } if (len == n + 1) { return \u0026#34;\u0026#34;; } return S.substr(start, len); } }; Relative Problems Lintcode 32 最小子串覆盖 Lintcode 397 最长上升连续子序列 Lintcode 77 最长公共子序列 ","chapter-16-划分型博弈型-和-背包型-动态规划#Chapter 16: 划分型、博弈型 和 背包型 动态规划":"划分型动态规划 定义： 给定长度为N的序列或字符串，要求划分成若干段，每一段要满足一定的性质\n段数不限，或指定K段 每一段满足一定的性质 做法：\n类似于序列型动态规划，但是通常要加上段数信息 一般用f[i][j]记录前i个元素（元素0 ~ i-1）分成j段的性质，如最小代价 Example: Lintcode 513 Perfect Square：划分型 Lintcode 513 完美平方 动态规划组成部分一：确定状态 确定状态：关注最优策略中最后一个完全平方数j^2 最优策略中n - j^2也一定被划分成最少的完全平方数之和 需要知道n - j^2最少被分成几个完全平方数之和 原来是求n最少被分成几个完全平方数之和 子问题 状态：设f[i]表示i最少被分成几个完全平方数之和（copy下来，变量变成下标，就能得到状态） 这道题只开一维数组，没有段数，原因是段数不是我们需要限定的。比如说如果这道题问，能不能分成10段，就需要改一下。 动态规划组成部分二：转移方程 设f[i]表示i最少被分成几个完全平方数之和 f[i] = min_{1 \u0026lt;= j * j \u0026lt;= i}(f[i - j^2] + 1) 此处{1 \u0026lt;= j * j \u0026lt;= i}是限定条件 动态规划组成部分三：初始条件和边界情况 设f[i]表示i最少被分成几个完全平方数之和\nf[i] = min_{1 \u0026lt;= j * j \u0026lt;= i}(f[i - j^2] + 1)\n初始条件：0被分成0个完全平方数之和\nf[0] = 0 动态规划组成部分四：计算顺序 初始化f[0] 计算f[1], ..., f[N] 答案是f[N] 空间复杂度是O(n)并且不能用滚动数组 时间复杂度是sqrt(1) + sqrt(2) + ... + sqrt(n) = O(n * sqrt(n)) Coding Solution // DP solution // Running time error class Solution { public: int numSquares(int n) { std::vector\u0026lt;int\u0026gt; f(n + 1); f[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { f[i] = INT_MAX; // last perfect square is j * j for (int j = 1; j * j \u0026lt;= i; ++j) { f[i] = std::min(f[i], f[i - j * j] + 1); } } return f[n]; } }; A Math solution costs O(n) time, and O(1) space\n// Math solution // Accepted class Solution { public: int numSquares(int n) { while (n % 4 == 0) { n /= 4; } if (n % 8 == 7) { return 4; } for (int i = 0; i * i \u0026lt;= n; ++i) { int j = (int)std::sqrt(n * 1.0 - i * i); if (i * i + j * j == n) { int res = 0; if (i \u0026gt; 0) { res += 1; } if (j \u0026gt; 0) { res += 1; } return res; } } return 3; } }; Follow up 有多少种方式把N表示成完全平方数之和（1^2 + 2^2和2^2 + 1^2属于不同的方式）————方案数 Ans: replace min with sum 能不能把N表示成恰好K个完全平方数之和————可行性 状态：f[i][k]能不能将i表示成恰好k个完全平方数之和 状态转移：f[i][k] = OR_{1 \u0026lt;= j * j \u0026lt;= i}(f[i - j^2][k - 1]) Example: Lintcode 108 Palindrome Partitioning II Lintcode Palindrome Partitioning II 动态规划组成部分一：确定状态 最后一步：关注最优策略中最后一段回文串，设为S[j .. N-1] 需要知道S前j个字符[0 .. j-1]最少可以划分成几个回文串 子问题 求S前N个字符S[0 .. N-1]最少划分为几个回文串 需要知道S前j个字符[0 .. j-1]最少可以划分成几个回文串 子问题 状态：设S前i个字符S[0 .. i-1]最少可以划分成f[i]个回文串 动态规划组成部分二：转移方程 设f[i]为S前i个字符S[0 .. i-1]最少可以划分成几个回文串 f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) 动态规划组成部分三：初始条件和边界情况 设f[i]为S前i个字符S[0 .. i-1]最少可以划分成几个回文串 f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) 初始条件：空串可以被分成0个回文串 f[0] = 0 动态规划组成部分四：计算顺序 计算f[0], f[1], ..., f[N] 回文串判断 方法一：从左到右 和 从右到左 各读一遍，完全一样 方法二：可以用两个指针从两头向中间移动，每一步两个指针指向的字符都必须相等 但是动态规划转移方程是f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) 每次都判断S[j .. i-1]是不是回文串很慢( 转移方程为O(n^3)太慢) 如何优化？ 回文串种类 回文串分两种： 长度为奇数 长度为偶数 生成回文串 假设我们现在不是寻找回文串，而是生成回文串 从中间开始，向两边扩展，每次左右两端加上同样的字符 在字符串中找到所有回文串 以字符串的每一个字符为中点，向两边扩展，找到所有回文串 记录回文串 从S每一个字符开始向两边扩展 考虑奇数长度回文串 和 偶数长度回文串 用isPlain[i][j]表示S[i .. j]是否是回文串 时间复杂度O(n^2) 回到原题 S最少划分成多少个回文串 f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | isPlain[j][i - 1] = True) 答案是f[N] - 1(因为原题是求最少划分几次) 时间复杂度O(n^2) 空间复杂度O(n^2) class Solution { public: int minCut(std::string\u0026amp; S) { int n = S.size(); if (n == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; palin = CalcPalin(S); std::vector\u0026lt;int\u0026gt; f(n + 1); f[0] = 0; int i, j; // S[0 .. i-1] for (i = 1; i \u0026lt;= n; ++i) { f[i] = 0x3f3f3f3f; // S[j .. i-1] for (j = 0; j \u0026lt; i; ++j) { if (palin[j][i - 1]) { f[i] = std::min(f[i], f[j] + 1); } } } return f[n] - 1; } std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; CalcPalin(std::string\u0026amp; S) { int n = S.size(); std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; palin(n, std::vector\u0026lt;bool\u0026gt;(n, false)); int i, j, mid; for (mid = 0; mid \u0026lt; n; ++mid) { // odd-length palindrome i = j = mid; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; S[i] == S[j]) { palin[i][j] = true; --i; ++j; } // even-length palindrome i = mid - 1; j = mid; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; S[i] == S[j]) { palin[i][j] = true; --i; ++j; } } return palin; } }; Example: Lintcode 437 Copy Books Lintcode 437 Copy Books\n通过关键词连续可以判断是否为划分型动态规划\n这道题有段数限制\n题目分析 如果一个抄写员抄写第i本到第j本书，则需要时间A[i] + A[i + 1] + ... + A[j] 最后完成时间取决于耗时最长的那个抄写员 需要找到一种分段方式，分成不超过K段，使得所有段的数字之和的最大值最小 动态规划组成部分一：确定状态 最后一步：最优策略中最后一个抄写员Bob（设他是第K个）抄写的部分 一段连续的书，包含最后一本 如果Bob抄写第j本到第N - 1本书 则Bob需要时间A[j] + ... + A[N - 1] 需要知道前面K - 1个人最少需要多少时间抄完前j本书（第0 ~ j-1本书）(这里也是指 时间的最大值最小) 子问题 求K个人最短需要多少时间抄完前N本书 需要知道K - 1个人最少需要多少时间抄完前j本书 子问题 状态：设f[k][i]为前k个抄写员最少需要多少时间抄完前i本书 动态规划组成部分二：转移方程 设f[k][i]为k个抄写员最少需要多少时间抄完前i本书 f[k][i] = min_{i = 0, ..., i}(max(f[k - 1][j], A[j] + ... + A[i - 1]))(Note: min的下标可以到i，代表这个人根本就不抄书，有些人可能分到0本书，所以是0 到 i) 动态规划组成部分三：初始条件和边界情况 设f[k][i]为k个抄写员最少需要多少时间抄完前i本书\nf[k][i] = min_{j = 0, ..., i}(max(f[k - 1][j], A[j] + ... A[i - 1]))\n初始条件：\n0 个抄写员只能抄0本书 f[0][0] = 0, f[0][1] = f[0][2] = ... = f[0][N] = +inf k 个抄写员（k \u0026gt; 0）需要 0 时间抄 0 本书 f[k][0] = 0(k \u0026gt; 0) 动态规划组成部分四：计算顺序 计算f[0][0], f[0][1], ..., f[0][N] 计算f[1][0], f[1][1], ..., f[1][N] \u0026hellip; 计算f[K][0], f[K][1], ..., f[K][N] 答案是f[K][N] 时间复杂度O(N^2 * K) 空间复杂度O(NK)，优化后可以达到O(N) 如果K \u0026gt; N, 可以赋值K \u0026lt;- N Coding: The First Solution with DP class Solution { public: int copyBooks(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int n = A.size(); if (n == 0) { return 0; } if (K \u0026gt; n) { K = n; } int f[K + 1][n + 1]; int i, j, k, s; for (i = 1; i \u0026lt;= n; ++i) { f[0][i] = 0x3f3f3f3f; } f[0][0] = 0; // first k copier for (k = 1; k \u0026lt;= K; ++k) { f[k][0] = 0; // copy first i books for (i = 1; i \u0026lt;= n; ++i) { f[k][i] = 0x3f3f3f3f; s = 0; for (j = i; j \u0026gt;= 0; --j) { // s = A[j] + ... + A[i - 1] if (f[k - 1][j] != 0x3f3f3f3f) { f[k][i] = std::min(f[k][i], std::max(f[k - 1][j], s)); } // update s // s += A[j - 1] if (j \u0026gt; 0) { s += A[j - 1]; } } } } return f[K][n]; } }; Coding: The Second Solution with Binary Search #include \u0026lt;numeric\u0026gt; // accumulate #include \u0026lt;algorithm\u0026gt; // max_element class Solution { public: int copyBooks(std::vector\u0026lt;int\u0026gt;\u0026amp; pages, int K) { if (pages.size() == 0) { return 0; } // int start = 0xcfcfcfcf; // maximum element of pages // int end = 0; // sum of pages // for (int i = 0; i \u0026lt; pages.size(); ++i) { // start = std::max(start, pages[end]); // i += pages[i]; // } int start = *std::max_element(pages.begin(), pages.end()); int end = std::accumulate(pages.begin(), pages.end(), 0); while (start + 1 \u0026lt; end) { int mid = start + (end - start) / 2; if (GetLeastPeople(pages, mid) \u0026lt;= K) { end = mid; } else { start = mid; } } if (GetLeastPeople(pages, start) \u0026lt;= K) { return start; } return end; } int GetLeastPeople(std::vector\u0026lt;int\u0026gt;\u0026amp; pages, int time_limit) { int count = 0; int time_cost = 0; for (auto\u0026amp; page : pages) { if (time_cost + page \u0026gt; time_limit) { ++count; time_cost = 0; } time_cost += page; } return count + 1; } }; Summary 划分型动态规划 要求将一个序列或字符串划分成若干满足要求的片段 解决方法：最后一步-\u0026gt;最后一段 枚举最后一段的起点，然后把最后一段拿出来判断满不满足性质，然后再看前面最少的段数啊最少的时间等等 如果题目不指定段数，用f[i]表示前i个元素分段后的最值，可行性，方式数：Perfect Squares, Palindrome Partition II 如果题目指定段数，用f[i][j]表示前i个元素分成j段后的最值，可行性，方案数：Copy Books 博弈型动态规划 博弈为两方游戏\n一方先下，在一定规则下依次出招\n如果满足一定条件，则一方胜\n目标：取胜\n先手：先出招的一方\n出招后，先手换人，新的先手面对一个新的局面\nNote: 只记先手(为了简化状态)，当前要下棋的那个人\n只有博弈型动态规划不是从最后一步分析，而是从第一步分析 反例：如果往一个空棋盘上加石子，先到n的人先赢，那这个时候应该按最后一步来想，因为这个时候子问题从后往前会更小 博弈型动态规划基本上都是: 取数字，取石子 Example: Lintcode 394 Coins in a Line Lintcode 394 Coins in a Line 动态规划组成部分一：确定状态 博弈动态规划通常从第一步分析，而不是最后一步 因为局面越来越简单，石子数越来越少 面对N个石子，先手Alice第一步可以拿1个或2个石子 这样后手Bob就面对N - 1个石子或N - 2个石子 先手Alice一定会选择能让自己赢的一步 因为双方都是采取最优策略 假如后手Bob面对N - 1个石子 其实这和一开始Bob是先手，有N - 1个石子的情况是一样的 那么Bob也会选择让自己赢的一步：取走1个或2个石子 之后Alice面对新的局面，自己成为新的先手，选择让自己赢的一步 \u0026hellip; 博弈型动态规划：必胜 vs 必败 怎么选择让自己赢的一步 就是走了这一步之后，对手面对剩下的石子，他必输(这里不是循环定义) 知识点：如果取1个或2个石子后，能让剩下的局面先手必败，则当前先手必胜 知识点：如果不管怎么走，剩下的局面都是先手必胜，则当前先手必败 宗旨： 必胜：在当下的局面走出一步，让对手无路可逃（即必败） 必败：自己无路可逃（即必败） 子问题 要求面对N个石子，是否先手必胜 需要知道面对N - 1个石子和N - 2个石子，是否先手必胜 子问题 状态：设f[i]表示面对i个石子，是否先手必胜（f[i] = TRUE / FALSE） 动态规划组成部分二：转移方程 设f[i]表示面对i个石子，是否先手必胜（f[i] = TRUE / FALSE）\nf[i] = true, f[i - 1] == False \u0026amp;\u0026amp; f[i - 2] == false 拿1或2个石子都必胜 true, f[i - 1] == false \u0026amp;\u0026amp; f[i - 2] == true 拿1个石子必胜 true, f[i - 1] == true \u0026amp;\u0026amp; f[i - 2] == false 拿2个石子必胜 false, f[i - 1] == true \u0026amp;\u0026amp; f[i - 2] == true 必败 Simplify: f[i] = f[i - 1] == false || f[i - 2] == false\n动态规划组成部分三：初始条件和边界情况 设f[i]表示面对i个石子，是否先手必胜（f[i] = TRUE / FALSE）\nf[i] = f[i - 1] == false || f[i - 2] == false\nf[0] = false 面对0个石子，先手必败\nf[1] = f[2] = true 面对1个或2个石子，先手必胜\n动态规划组成部分四：计算顺序 f[0], f[1], f[2], ..., f[N] 如果f[N] = true则先手必胜，否则先手必败 时间复杂度O(N) 空间复杂度O(N)，可以滚动数组优化至O(1) Official Solution class Solution { public: bool firstWillWin(int n) { if (n == 0) { return false; } std::vector\u0026lt;bool\u0026gt; f(n + 1); f[0] = false; f[1] = true; int i, j, k; for (i = 2; i \u0026lt;= n; ++i) { f[i] = f[i - 1] == false || f[i - 2] == false; } return f[n]; } }; The Second Solution with Time O(1) Space O(1) class Solution { public: bool firstWillWin(int n) { return n % 3 != 0; } }; 背包型动态规划 你有一个背包，背包有最大承重 商店里有若干物品，都是免费拿 每个物品有重量和价值 目标：不撑爆背包的前提下 装下最多重量物品 装下最大总价值的物品 有多少种方式正好带走满满一书包物品 直觉 逐个放物品，看是否还能放入 两个关键点: 还有几个物品 还剩多少承重 Example: Lintcode 92 Backpack Lintcode 92 Backpack\n黄金定律：背包问题中，数组大小和总承重有关\n动态规划组成部分一：确定状态 需要知道N个物品是否能拼出重量W（W = 0, 1, \u0026hellip;, M）\n最后一步：最后一个物品（重量A_{N - 1}是否进入背包）\n情况一：如果前N - 1个物品能拼出W，当然前N个物品也能拼出W\n情况二：如果前N - 1个物品能拼出W - A_{N - 1}，再加上最后的物品A_{N - 1}，拼出W\n例子:\n4个物品，重量为 2, 3, 5, 7\n前3个物品可以拼出重量8(即3 + 5)，自然4个物品可以拼出重量8\n前3个物品可以拼出重量2（即2），加上最后一个物品，可以拼出重量9\n子问题 要求前N个物品能不能拼出重量 0, 1, \u0026hellip;, M 需要知道前N - 1个物品能不能拼出重量 0, 1, \u0026hellip;, M 子问题 状态：设f[i][w] = 能否用前i个物品拼出重量w (TRUE / FALSE) 常见误区：错误 设f[i]表示前i个物品能拼出的最大重量（不超过M） 反例：A = [3 9 5 2], M = 10 错误原因：最优策略中，前N - 1个物品拼出的不一定是不超过M的最大重量 或者用黄金定律，即一定要有背包承重的维度 动态规划组成部分二：转移方程 设f[i][w] = 能否用前i个物品拼出重量w (TRUE / FALSE) f[i][w] = f[i - 1][w] || f[i - 1][w - A_{i - 1}] 动态规划组成部分三：初始条件和边界情况 f[i][w] = f[i - 1][w] || f[i - 1][w - A_{i - 1}] 初始条件： f[0][0] = true : 0个物品可以拼出重量0 f[0][1 .. M] = false : 0个物品不能拼出大于0的重量 边界情况： f[i - 1][w - A_{i - 1}] 只能在w \u0026gt;= A_{i - 1}时使用\n动态规划组成部分四：计算顺序 初始化f[0][0], f[0][1], ..., f[0][M] 计算前 1 个物品能拼出哪些重量：f[1][0], f[1][1], ..., f[1][M] 计算前 2 个物品能拼出哪些重量：f[2][0], f[2][1], ..., f[2][M] \u0026hellip; 计算前 N 个物品能拼出哪些重量：f[N][0], f[N][1], ..., f[N][M] 时间复杂度（计算步数）：O(MN) 空间复杂度（数组大小）：优化后可以达到O(M) DP Official Solution class Solution { public: int backPack(int m, std::vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(); if (n == 0) { return 0; } bool f[n + 1][m + 1]; int i, w; // initialization for (i = 1; i \u0026lt;= m; ++i) { f[0][i] = false; } f[0][0] = true; // first i items for (i = 1; i \u0026lt;= n; ++i) { for (w = 0; w \u0026lt;= m; ++w) { // case 1: not using item_{i - 1} f[i][w] = f[i - 1][w]; // case 2: using item_{i - 1} if (w \u0026gt;= A[i - 1]) { f[i][w] = f[i][w] || f[i - 1][w - A[i - 1]]; } } } for (i = m; i \u0026gt;= 0; --i) { if (f[n][i]) { return i; } } return 0; } }; Backpack Official Solution class Solution { public: int backPack(int m, std::vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1)); for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (j - A[i - 1] \u0026gt;= 0) { dp[i][j] = std::max(dp[i - 1][j - A[i - 1]] + A[i - 1], dp[i - 1][j]); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[n][m]; } }; Summary 方法二： 要求不超过M时能拼出的最大重量 记录前i个物品能拼出哪些重量 前i个物品能拼出的重量： 前i - 1个物品能拼出的重量 前i - 1个物品能拼出的重量 + 第i个物品重量A_{i - 1} 如果我们的重量不是正数，而是保留的两位小数，那么我们应该怎么处理? 把重量扩大100倍进行背包，但一般仅限于小数位数比较少的时候，不然我们需要大量的空间来存储背包。 Example: Lintcode 563 Backpack V Lintcode 563 Backpack V 动态规划组成部分一：确定状态 需要知道N个物品有多少种方式拼出重量W (W = 0, 1, ..., Target) 最后一步：第N个物品（重量A_{N - 1}）是否进入背包 情况一：用前N - 1个物品拼出W 情况二：用前N - 1个物品能拼出W - A_{N - 1}，再加上最后的物品A_{N - 1}，拼出W 情况一的个数 + 情况二的个数 = 用前N个物品拼出W的方式 子问题 要求前N个物品有多少种方式拼出重量 0, 1, \u0026hellip;, Target 需要知道前N - 1个物品有多少种方式拼出重量 0, 1, \u0026hellip;, Target 子问题 状态：设f[i][w] = 用前 i 个物品有多少种方式拼出重量w 动态规划组成部分二：转移方程 设f[i][w] = 用前 i 个物品有多少种方式拼出重量w f[i][w] = f[i - 1][w] + f[i - 1][w - A_{i - 1}] 动态规划组成部分三：初始条件和边界情况 f[i][w] = f[i - 1][w] + f[i - 1][w - A_{i - 1}]\n初始条件：\nf[0][0] = 1 : 0 个物品可以有一种方式拼出重量 0 f[0][1 .. M] = 0 : 0 个物品不能拼出大于 0 的重量 边界情况：\nf[i - 1][w - A_{i - 1}]只能在w \u0026gt;= A_{i - 1}时使用 动态规划组成部分四：计算顺序 初始化f[0][0], f[0][1], ..., f[0][Target] 计算前 1 个物品有多少种方式拼出重量：f[1][0], f[1][1], ..., f[1][Target] \u0026hellip; 计算前 N 个物品有多少种方式拼出重量：f[N][0], f[N][1], ..., f[N][Target] 答案是f[N][Target] 时间复杂度（计算步数）：O(N * Target) 空间复杂度（数组大小）：滚动数组优化后可以达到O(Target) Official Solution class Solution { public: int backPackV(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int m) { int n = A.size(); if (n == 0) { return 0; } int f[n + 1][m + 1]; int i, w; // initialization for (i = 1; i \u0026lt;= m; ++i) { f[0][i] = 0; } f[0][0] = 1; // first i items for (i = 1; i \u0026lt;= n; ++i) { for (w = 0; w \u0026lt;= m; ++w) { // case 1: not using item_{i - 1} f[i][w] = f[i - 1][w]; // case 2: using item_{i - 1} if (w \u0026gt;= A[i - 1]) { f[i][w] = f[i][w] + f[i - 1][w - A[i - 1]]; } } } return f[n][m]; } }; 进一步空间优化 f[i][w] = f[i - 1][w] + f[i - 1][w - A_{i - 1}] 可以只开一个数组 按照f[i][Target], ..., f[i][0]的顺序更新 class Solution { public: int backPackV(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int m) { int n = A.size(); if (n == 0) { return 0; } int f[m + 1]; int i, w; // initialization for (i = 1; i \u0026lt;= m; ++i) { f[i] = 0; } f[0] = 1; // first i items for (i = 1; i \u0026lt;= n; ++i) { for (w = m; w \u0026gt;= A[i - 1]; --w) { // w doesn\u0026#39;t have to be 0 here f[w] += f[w - A[i - 1]]; } } return f[m]; } }; My Correct Solution class Solution { public: int backPackV(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); int dp[n + 1][target + 1]; for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= target; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { dp[i][j] = 1; } else if (i == 0) { dp[i][j] = 0; } else if (j - nums[i - 1] \u0026gt;= 0) { dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j]; } else { dp[i][j]= dp[i - 1][j]; } } } return dp[n][target]; } }; Exercise: Lintcode 564 BackPack IV (组合总和 IV) Lintcode 564 Backpack IV (组合总和 IV)\n类似于最前面的Coin Change\n区别于BackpackV:\nHere: [5, 1, 1], [1, 1, 5] 为两种不同的方案 BackpackV: [5, 1, 1], [1, 1, 5] 只能存在一种 最后一步：背包里最后一个物品的重量是多少\nf[i] = 有多少种组合能拼出重量i\nf[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}]\n题目分析 和BackpackV唯一区别：组合中数字可以按不同的顺序，比如1 + 1 + 2与1 + 2 + 1算两种组合 不能先处理第一个物品，再处理第二个物品 似乎是更难的背包问题 其实更简单 动态规划组成部分一：确定状态 关注最后一步：最后一个物品的重量是多少 关键点1: 任何一个正确的组合中，所有物品总重量是Target 关键点2: 如果最后一个物品重量是K，则前面的物品重量是Target - K 如果最后一个物品重量是A_{0}，则要求有多少种组合能拼成Target - A_{0} 如果最后一个物品重量是A_{1}，则要求有多少种组合能拼成Target - A_{1} \u0026hellip; 如果最后一个物品重量是A_{N - 1}，则要求有多少种组合能拼成Target - A_{N - 1} 子问题 原问题要求 有多少种组合能拼成Target 子问题 设f[i] = 有多少种组合能拼出重量i 动态规划组成部分二：转移方程 设f[i] = 有多少种组合能拼出重量i f[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}] 动态规划组成部分三：初始条件和边界情况 f[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}]\n出事条件：\nf[0] = 1\n有1种组合能拼出重量0（什么都不选） 边界情况：\n如果i \u0026lt; A_{j}，则对应的f[i - A_{j}]不加入f[i]\nA_{0} = 1, A_{1} = 2, A_{2} = 4 f[3] = f[3 - A_{0}] + f[3 - A_{1}] 动态规划组成部分四：计算顺序 设f[i] = 有多少种组合能拼出重量i f[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}] f[0] = 1 计算f[1], f[2], ..., f[Target] 结果为f[Target] 时间复杂度（计算步数）：O(N * Target) 空间复杂度：O(Target) Offical Solution class Solution { public: int backPackVI(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int m) { int n = A.size(); int f[m + 1]; f[0] = 1; int i, j; for (i = 1; i \u0026lt;= m; ++i) { // how many ways can we make weight // last item A[j] f[i] = 0; for (j = 0; j \u0026lt; n; ++j) { if (A[j] \u0026lt;= i) { f[i] += f[i - A[j]]; } } } return f[m]; } }; Summary 划分型动态规划\n如果不需要段数，f[i]: 前i个元素分段的最优值，方案数，可行性 如果需要段数，f[i][k] 博弈型动态规划\n必胜 vs 必败 只考虑先手 当前状态必胜，说明当前状态至少有一种状态 可以走到 必败 当前状态必败，说明不管怎么走都到 必胜的局面 背包型动态规划\n黄金定律：背包的总承重一定要放在状态里 Exercise: Single Choice ","chapter-17-背包型-和-区间型-动态规划#Chapter 17: 背包型 和 区间型 动态规划":"01 backpack Lintcode 125 Backpack II class Solution { public: int backPackII(int m, std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;int\u0026gt;\u0026amp; V) { int n = A.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (j - A[i - 1] \u0026gt;= 0) { dp[i][j] = std::max(dp[i - 1][j - A[i - 1]] + V[i - 1], dp[i - 1][j]); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[n][m]; } }; 打印路径 class Solution { public: int backPackII(int m, std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;int\u0026gt;\u0026amp; V) { int n = A.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); // pi has the same size with dp std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; pi(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (j - A[i - 1] \u0026gt;= 0) { dp[i][j] = std::max(dp[i - 1][j - A[i - 1]] + V[i - 1], dp[i - 1][j]); // keep tracking whether we choose the item if (dp[i][j] == dp[i - 1][j - A[i - 1]] + V[i - 1]) { pi[i][j] = 1; } } else { dp[i][j] = dp[i - 1][j]; } } } // print path std::vector\u0026lt;bool\u0026gt; selected(n); int weight = m; for (int i = n; i \u0026gt;= 1; --i) { if (pi[i][weight] == 1) { selected[i - 1] = true; weight -= A[i - 1]; } else { selected[i - 1] = false; } } for (int i = 0; i \u0026lt; n; ++i) { if (selected[i]) { std::cout \u0026lt;\u0026lt; \u0026#34;i: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;A[i]: \u0026#34; \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; \u0026#34;V[i]: \u0026#34; \u0026lt;\u0026lt; V[i] \u0026lt;\u0026lt; std::endl; } } return dp[n][m]; } }; complete backpack Lintcode 440 backpack III class Solution { public: int backPackIII(std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;int\u0026gt;\u0026amp; V, int m) { std::vector\u0026lt;int\u0026gt; AA; std::vector\u0026lt;int\u0026gt; VV; for (int ) int n = AA.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); } }; Convert to 01backpack Two dimentional matrix One dimentinoal array multiple backpack Convert the problem to 01-backpack 区间型动态规划 给定一个序列/字符串，进行一些操作 最后一步会将序列/字符串 去头/去尾 剩下的会是一个区间[i, j] 状态自然定义为f[i][j]，表示面对子序列[i, ..., j]时的最优性质 Example: Lintcode 667 Longest Palindrome Subsequence Lintcode 667 Longest Palindrome Subsequence 动态规划组成部分一：确定状态 最优策略产生最长的回文子序列T，长度是M\n情况1: 回文串长度是1，即一个字母\n情况2: 回文串长度大于1，那么必定有T[0] = T[M - 1]\n设T[0]是S[i]，T[M - 1]是S[j]\nT剩下的部分T[1 ... M - 2]仍然是一个回文串，而且是S[i + 1 ... j - 1]的最长回文子序列\n子问题 要求S[i ... j]的最长回文子序列 如果S[i] = S[j]，需要知道S[i + 1 ... j - 1]的最长回文子序列 否则答案是S[i + 1 .. j]的最长回文子序列 或 S[i ... j - 1]的最长回文子序列 子问题 状态：设f[i][j]为S[i ... j]的最长回文子序列的长度 动态规划组成部分二：转移方程 设f[i][j]为S[i ... j]的最长回文子序列的长度 f[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 动态规划组成部分三：初始条件和边界情况 设f[i][j]为S[i ... j]的最长回文子序列的长度\nf[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 初始条件：\nf[0][0] = f[1][1] = ... = f[N - 1][N - 1] = 1 一个字母也是一个长度为1的回文串 如果S[i] == S[i + 1], f[i][i + 1] = 2(即相邻) 如果S[i] != S[i + 1], f[i][i + 1] = 1(即相邻) 动态规划组成部分四：计算顺序 设f[i][j]为S[i ... j]的最长回文子序列的长度 f[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 不能按照i的顺序去算 区间动态规划：按照长度j - i从小到大的顺序去算 即for循环那个长度，不能循环i或j 长度 1 ：f[0][0], f[1][1], f[2][2], ..., f[N - 1][N - 1] 长度 2 ：f[0][1], ..., f[N - 2][N - 1] \u0026hellip; 长度 N ：f[0][N - 1] 答案是f[0][N - 1] 时间复杂度O(N^2) 空间复杂度O(N^2) Official Solution class Solution { public: int longestPalindromeSubseq(std::string\u0026amp; S) { int n = S.size(); if (n \u0026lt;= 1) { return n; } int f[n][n]; int i, j, len; // case 1: len == 1 for (i = 0; i \u0026lt; n; ++i) { f[i][i] = 1; } // case 2: len == 2 for (i = 0; i \u0026lt; n - 1; ++i) { f[i][i + 1] = (S[i] == S[i + 1]) ? 2 : 1; } for (len = 3; len \u0026lt;= n; ++len) { // [i .. i + len - 1] // i + len - 1 \u0026lt; n ==\u0026gt; i \u0026lt; n - len + 1 ==\u0026gt; i \u0026lt;= n - len for (i = 0; i \u0026lt;= n - len; ++i) { // i 是起点 j = i + len - 1; // j 是终点 // S[i .. j], length is len // 三种情况： f[i][j] = std::max(f[i + 1][j], f[i][j - 1]); if (S[i] == S[j]) { f[i][j] = std::max(f[i][j], f[i + 1][j - 1] + 2); } } } return f[0][n - 1]; } }; 区间动态规划的初始化和计算顺序都是基于区间长度\n记忆化搜索方法 一种写程序的方法，不是新的算法 动态规划编程的另一个选择 f[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 计算f[0][N - 1] 递归计算f[1][N - 1], f[0, N - 2], f[1][N - 2] 记忆化：计算f[i][j]结束后，将结果保存在数组f[i][j]里，下次如果需要再次计算f[i][j]，直接返回f[i][j] 两种解决动态规划的思路: top-down 记忆化搜索 bottom-up 递推 recurrence 任何动态规划的题 既可以用 记忆化搜索 又可以用 递推\n与递推方法比较 递推方法 自下而上（从简单到复杂）：f[0], f[1], ..., f[N] 记忆化方法 自上而下（从复杂到简单）：f[N], f[N - 1], ... 记忆化搜索编写一般比较简单 递推方法在某些条件下可以做空间优化，记忆化搜索则必须存储所有f值 Coding with Template (important) class Solution { public: int longestPalindromeSubseq(std::string\u0026amp; ss) { s = ss; n = s.size(); if (n \u0026lt;= 1) { return n; } f.resize(n, std::vector\u0026lt;int\u0026gt;(n, 0)); // important1: clear memory int i, j; for (i = 0; i \u0026lt; n; ++i) { for (j = i; j \u0026lt; n; ++j) { f[i][j] = -1; // f[i][j] has not been computed yet } } calc(0, n - 1); return f[0][n - 1]; } private: void calc(int i, int j) { // compute f[i][j] if (f[i][j] != -1) { // important2: 递归里的第一句话就要写上: if f[i][j] has been computed, return directly return; } // simple case: caculate directly: length is 1 if (i == j) { f[i][i] = 1; return; } // simple case: caculate directly: length is 2 if (i + 1 == j) { f[i][i + 1] = (s[i] == s[i + 1]) ? 2 : 1; return; } // important3: 先在这里递归 calc(i + 1, j); // f[i + 1][j] is computed calc(i, j - 1); calc(i + 1, j - 1); f[i][j] = std::max(f[i + 1][j], f[i][j - 1]); if (s[i] == s[j]) { f[i][j] = std::max(f[i][j], f[i + 1][j - 1] + 2); } } // we need to do recursion, so we need some global variable std::string s; int n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f; }; Example: Lintcode 396 Coins in A Line III （区间型动态规划—博弈问题） Lintcode 396 Coins in A Line III 博弈 这道题是一道博弈题，目标是让自己拿到的数字之和不比对手小 设己方数字和是A，对手数字和是B，即目标是A \u0026gt;= B 等价于A - B \u0026gt;= 0 也就是说，如果Alice和Bob都存着自己的数字和与对手的数字和之差，分别记为S_A = A - B，S_B = B - A 则Alice的目标是最大化S_A，Bob的目标是最大化S_B 当一方X面对剩下的数字，可以认为X就是当前的先手，他的目标就是最大化S_X = X - Y 当他取走一个数字m后，对手Y变成先手，同理他也要最大化S_Y = Y - X important: 对于X来说，S_X = - S_Y + m 其中，m是当前这步的数字，-S_Y是对手看来的数字差取相反数（因为先手是X） 现在X有两种选择，取第一个数字m_1或最后一个数字m_2，为了最大化S_X，应该选择较大的那个S_X 动态规划组成部分一：确定状态 如果Alice第一步取走a[0]，Bob面对a[1 .. N - 1]\nBob的最大数字差是S_Y\nAlice的数字差是a[0] - S_Y\n如果Alice第一步取走a[N - 1]，Bob面对a[0 .. N - 2]\nBob的最大数字差是S_Y_prime\nAlice的数字差是a[N - 1] - S_Y_prime\nAlice 选择较大的数字差\n博弈子问题 当Bob面对a[1 .. N - 1]，他这时是先手 他的目标同样是最大化先手（自己）和后手（Alice）的数字差 但是此时的数字少了一个：a[1 .. N - 1] 子问题 状态：设f[i][j]为一方先手在面对a[i .. j]这些数字时，能得到的最大的与对手的数字差 动态规划组成部分二：转移方程 设f[i][j]为一方先手在面对a[i .. j]这些数字时，能得到的最大的与对手的数字差 f[i][j] = std::max(a[i] - f[i + 1][j], a[j] - f[i][j - 1]) 动态规划组成部分三：初始条件和边界情况 设f[i][j]为一方先手在面对a[i .. j]这些数字时，能得到的最大的与对手的数字差 f[i][j] = std::max(a[i] - f[i + 1][j], a[j] - f[i][j - 1]) 只有一个数字a[i]时，己方得a[i]分，对手0分，数字差为a[i] f[i][i] = a[i] (i = 0, 1, ..., N - 1) 动态规划组成部分四：计算顺序 长度1: f[0][0], f[1][1], f[2][2], ..., f[N - 1][N - 1] 长度2: f[0][1], ..., f[N - 2][N - 1] \u0026hellip; 长度N: f[0][N - 1] 如果f[0][N - 1] \u0026gt;= 0，先手Alice必赢，否则必输 时间复杂度O(N^2) 空间复杂度O(N^2) // 博弈型与区间型的结合类问题 class Solution { public: bool firstWillWin(std::vector\u0026lt;int\u0026gt;\u0026amp; values) { int n = values.size(); if (n == 0) { return true; } int f[n][n]; int i, j, len; // len == 1 for (i = 0; i \u0026lt; n; ++i) { f[i][i] = values[i]; } for (len = 2; len \u0026lt;= n; ++len) { for (i = 0; i \u0026lt;= n - len; ++i) { j = i + len - 1; // A[i ... j] f[i][j] = std::max(values[i] - f[i + 1][j], values[j] - f[i][j - 1]); } } return f[0][n - 1] \u0026gt;= 0; } }; Example: Lintcode 430 Scramble String Lintcode 430 Scramble String\n区间有两种获得方式：\n去头去尾 二分，中间劈一刀，像这道题 动态规划组成部分一：确定状态 显然，T如果长度和S不一样，那么肯定不能由S变换而来 如果T是S变换而来的，并且我们知道S最上层二分被分成S = S_1 S_2，那么一定有： T也有两部分T = T_1 T_2，T_1是S_1变换而来的，T_2是S_2变换而来的 T也有两部分T = T_1 T_2，T_1是S_2变换而来的，T_2是S_1变换而来的 子问题 要求T是否由S变换而来 需要知道T_1是否由S_1变换而来的，T_2是否由S_2变换而来 需要知道T_1是否由S_2变换而来的，T_2是否由S_1变换而来 S_1, S_2, T_1, T_2长度更短 子问题 状态：f[i][j][k][h]表示T[k .. h]是否由S[i .. j]变换而来 动态规划组成部分一：确定状态 这里所有串都是S和T的子串，且长度一样 所以每个串都可以用**（起始位置， 长度）**表示 例如： S_1长度是5，在S中位置7开始 T_1长度是5，在T中位置0开始 可以用f[7][0][5] = True/False表示S_1能否通过变换成为T_1 状态：设f[i][j][k]表示S_1能否通过变换成为T_1 S_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串 动态规划组成部分二：转移方程 状态：设f[i][j][k]表示S_1能否通过变换成为T_1 S_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串 动态规划组成部分三：初始条件和边界情况 状态：设f[i][j][k]表示S_1能否通过变换成为T_1\nS_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串 如果S[i] = T[j], f[i][j][1] = True否则f[i][j][1] = False\n动态规划组成部分四：计算顺序 状态：设f[i][j][k]表示S_1能否通过变换成为T_1\nS_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串 按照k从小到大的顺序去计算\nf[i][j][1], 0 \u0026lt;= i \u0026lt; N, 0 \u0026lt;= j \u0026lt; N f[i][j][2], 0 \u0026lt;= i \u0026lt; N - 1, 0 \u0026lt;= j \u0026lt; N - 1 \u0026hellip; f[0][0][N] 答案是f[0][0][N]\n时间复杂度O(N^4)\n空间复杂度O(N^3)\nclass Solution { public: bool isScramble(std::string\u0026amp; S, std::string\u0026amp; T) { int m = S.size(); int n = T.size(); if (m != n) { return false; } bool f[n][n][n + 1]; int i, j, w, len; // len = 1 for (i = 0; i \u0026lt; n; ++i) { for (j = 0; j \u0026lt; n; ++j) { f[i][j][1] = (S[i] == T[j]); } } for (len = 2; len \u0026lt;= n; ++len) { for (i = 0; i \u0026lt;= n - len; ++i) { // S[i ... i+len-1] for (j = 0; j \u0026lt;= n - len; ++j) { // T[j ... j+len-1] f[i][j][len] = false; // break into S1 and S2 // S1 has length w, S2 has length len - w for (w = 1; w \u0026lt; len; ++w) { //no swap // S1--\u0026gt;T1, S2--\u0026gt;T2 if (f[i][j][w] \u0026amp;\u0026amp; f[i + w][j + w][len - w]) { f[i][j][len] = true; break; } // swap // S1--\u0026gt;T2, S2--\u0026gt;T1 if (f[i][j + len - w][w] \u0026amp;\u0026amp; f[i + w][j][len - w]) { f[i][j][len] = true; break; } } } } } return f[0][0][n]; } }; 记忆化搜索 class Solution { public: bool isScramble(std::string\u0026amp; SS, std::string\u0026amp; TT) { S = SS; T = TT; int m = S.size(); n = T.size(); if (m != n) { return false; } int i, j, len; f.resize(n, std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt;(n, std::vector\u0026lt;bool\u0026gt;(n + 1))); done.resize(n, std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt;(n, std::vector\u0026lt;bool\u0026gt;(n + 1))); for (len = 1; len \u0026lt;= n; ++len) { for (i = 0; i \u0026lt;= n - len; ++i) { // S[i ... i+len-1] for (j = 0; j \u0026lt;= n - len; ++j) { // T[j ... j+len-1] done[i][j][len] = false; // f[i][j][len] not computed yet } } } calc(0, 0, n); return f[0][0][n]; } private: void calc(int i, int j, int len) { if (done[i][j][len]) { return; } int w; if (len == 1) { f[i][j][1] = (S[i] == T[j]); return; } // break into S1 and S2 // S1 has length w, S2 has length len - w for (w = 1; w \u0026lt; len; ++w) { //no swap // S1--\u0026gt;T1, S2--\u0026gt;T2 calc(i, j, w); calc(i + w, j + w, len - w); if (f[i][j][w] \u0026amp;\u0026amp; f[i + w][j + w][len - w]) { f[i][j][len] = true; break; } // swap // S1--\u0026gt;T2, S2--\u0026gt;T1 calc(i, j + len - w, w); calc(i + w, j, len - w); if (f[i][j + len - w][w] \u0026amp;\u0026amp; f[i + w][j][len - w]) { f[i][j][len] = true; break; } } done[i][j][len] = true; // has been computed } std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt;\u0026gt; f; std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt;\u0026gt; done; int n; std::string S; std::string T; }; Example: Lintcode 168 吹气球 (消去型 \u0026ndash;\u0026gt; 区间型) Lintcode 168 吹气球\n消去型：一定要倒着想，不然状态过多\n观察最后被扎破的气球，分为左右两个区间\n设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数\nf[i][j] = max_{i \u0026lt; k \u0026lt; j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])\n时间复杂度O(N^3)\n空间复杂度O(N^2)\n类似题目： Lintcode 1694 Monster Hunter 动态规划组成部分一：确定状态 所有N个气球都被扎破 最后一步：一定有最后一个被扎破的气球，编号是i 扎破i时，左边是气球0，右边是气球N + 1，获得金币1 * a_i * 1 = a_i 此时气球1 ~ i-1以及i+1 ~ N都已经被扎破，并且已经获得对应金币 子问题 要求扎破1 ~ N号气球，最多获得的金币数 需要知道扎破1 ~ i - 1号气球，最多获得的金币数和扎破i+1 ~ N号气球，最多获得的金币数 子问题 状态：设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数 动态规划组成部分二：转移方程 设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数 i和j不能扎破 f[i][j] = max_{i \u0026lt; k \u0026lt; j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j]) 动态规划组成部分三：初始条件和边界情况 设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数\ni和j不能扎破 f[i][j] = max_{i \u0026lt; k \u0026lt; j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])\n初始条件：f[0][1] = f[1][2] = ... = f[N][N + 1] = 0\n当没有气球要扎破时，最多获得0枚金币 动态规划组成部分四：计算顺序 设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数\ni和j不能扎破 f[i][j] = max_{i \u0026lt; k \u0026lt; j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])\n区间动态规划：按照长度j - i从小到大的顺序去算\nf[0][1], f[1][2], f[2][3], ..., f[N][N + 1] f[0][2], f[1][3], f[2][4], ..., f[N - 1][N + 1] \u0026hellip; f[0][N + 1] 时间复杂度O(N^3) 空间复杂度O(N^2)\nclass Solution { public: int maxCoins(std::vector\u0026lt;int\u0026gt;\u0026amp; AA) { int n = AA.size(); if (n == 0) { return 0; } int i, j, k, len; int A[n + 2]; A[0] = A[n + 1] = 1; for (i = 1; i \u0026lt;= n; ++i) { A[i] = AA[i - 1]; } n += 2; // AA: 3 2 8 7 9 // A: 1 3 2 8 7 9 1 int f[n][n]; for (i = 0; i \u0026lt; n - 1; ++i) { f[i][i + 1] = 0; } for (len = 3; len \u0026lt;= n; ++len) { for (i = 0; i \u0026lt;= n - len; ++i) { j = i + len - 1; // i ... k ... j f[i][j] = 0; for (k = i + 1; k \u0026lt; j; ++k) { f[i][j] = std::max(f[i][j], f[i][k] + f[k][j] + A[i] * A[k] * A[j]); } } } return f[0][n - 1]; // n here has added 2 before } }; Summary 区间型动态规划 状态用区间左右端点：f[i][j] 有时需要逆向思考，从最后一个操作开始考虑，分成左右两个独立的空间 如何发现是否是区间型动态规划 去头去尾 二分: Scramble String 消去型，其实也是二分，但是一定要倒着想 ","chapter-18-石头碰撞背包型#Chapter 18: 石头碰撞：背包型":" Lintcode 724 最小划分\n分析也许和coding不一致，只能做参考\n使用i循环从1到石头总和 / 2大小的背包 dp[j]代表将容量为j的01背包装满是否可行，如果可行，|sum - j - j|即为目前的碰撞结果 每装满一个大小为x的01背包，都要维护|sum - 2x|的最小值 class Solution { public: int findMin(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n == 0) return 0; if (n == 1) return nums[0]; int sum = 0; for (int i = 0; i \u0026lt; n ; ++i) sum += nums[i]; std::vector\u0026lt;int\u0026gt; dp(sum / 2 + 1); dp[0] = 0; for (int i = 0; i \u0026lt; n; ++i) for (int j = sum / 2; j \u0026gt;= nums[i]; --j) dp[j] = dp[j - nums[i]] + nums[i] \u0026gt; dp[j] ? dp[j - nums[i]] + nums[i] : dp[j]; return std::abs(sum - 2 * dp[sum / 2]); } }; ","chapter-19-合并金币区间型#Chapter 19: 合并金币：区间型":" Lintcode 476 石子合并\n这道题是一道区间dp的入门题，通过理解状态转移的过程，决定循环的要素。在这题里，我们需要先枚举区间长度，再枚举起点。这就是区间dp的精髓。让我们一起来亲手做一下这道题目吧~\n我们令dp[i][j]为从 第i堆金币到第j堆金币所需的最小代价\n区间[i, j]可以从以任意的i \u0026lt;= k \u0026lt; j为分割点所得的两个子区间得来\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j])\nsum[i][j]表示区间[i, j]的数字和，可以使用前缀和来维护\n区间DP通用思路： 目标是求解在一个区间上的最优解，那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可 本题思路： 枚举区间长度 len 为每次分割成的小区间长度（由短到长不断合并），内层枚举该长度下的可能起点，并按照 len 计算终点。然后在这个起点终点之间枚举分割点 k ，求解这段以 i 为起点。长度为 len 的小区间在某个 k 的最优解。 class Solution { public: int stoneGame(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(); if (n == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n, std::vector\u0026lt;int\u0026gt;(n, 0)); std::vector\u0026lt;int\u0026gt; sum(n + 1, 0); // prefix sum for (int i = 1; i \u0026lt; n + 1; ++i) { sum[i] = sum[i - 1] + A[i - 1]; } for (int len = 2; len \u0026lt;= n; ++len) { for (int i = 0; i \u0026lt;= n - len; ++i) { int j = i + len - 1; dp[i][j] = 0x3f3f3f3f; int least_sum = sum[j + 1] - sum[i]; for (int k = i; k \u0026lt; j; ++k) { // 当前区间由子区间得到 dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k + 1][j] + least_sum); } } } return dp[0][n - 1]; } }; Lintcode 593 Stone Game II Lintcode 168 Burst Ballon ","chapter-2-动态规划初探--坐标型动态规划--位操作型动态规划#Chapter 2: 动态规划初探 + 坐标型动态规划 + 位操作型动态规划":"","chapter-20-外卖满减01背包#Chapter 20: 外卖满减：01背包":"\n输入\u0026amp;输出 输入：5 20 [18, 19, 17, 6, 7] 输出：23 class Solution { public: std::vector minimumPrice(int n, int X, std::vector\u0026lt;int\u0026gt; price) { int total_price = 0; for (int i = 0; i \u0026lt; n; ++i) { total_price += price[i]; } // 转化为容量为 total_price 的 01背包 // dp[i] 为 true 表示可以选择总价恰好为 i 的物品 std::vector\u0026lt;bool\u0026gt; dp(total_price + 1, false); for (int i = 0; i \u0026lt; n; ++i) { for (int j = total_price; j \u0026gt;= price[i]; --j) { dp[j] |= dp[j - price[i]]; } } // 找到 \u0026gt;= X 的最小价格 for (int i = X; i \u0026lt;= total_price; ++i) { if (dp[i]) { return i; } } return -1; } }; Exercise Lintcode 92 backpack Lintcode 92 Backpack Exercise Lintcode 125 backpack II Lintcode 125 Backpack Exercise Lintcode 563 backpack V Lintcode 563 Backpack ","chapter-21-考试策略0051背包#Chapter 21: 考试策略：0/0.5/1背包":" Lintcode 273 考试策略\n做一部分：(满足p[i - 1] \u0026lt;= j): part = dp[i - 1][j - p_time[i - 1]] + p_score[i - 1]\n全做完：(满足f[i - 1] \u0026lt;= j): full = dp[i - 1][j - f_time[i - 1]] + f_score[i - 1]\ndp[i][j]= max(part, full, dp[i - 1][j])\nclass Solution { public: int exam(std::vector\u0026lt;int\u0026gt;\u0026amp; p, std::vector\u0026lt;int\u0026gt;\u0026amp; part, std::vector\u0026lt;int\u0026gt;\u0026amp; f, std::vector\u0026lt;int\u0026gt;\u0026amp; full) { int n = p.size(); int m = 120; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { dp[i][j] = dp[i - 1][j]; if (j - p[i - 1] \u0026gt;= 0) { dp[i][j] = std::max(dp[i][j], dp[i - 1][j - p[i - 1]] + part[i - 1]); } if (j - f[i - 1] \u0026gt;= 0) { dp[i][j] = std::max(dp[i][j], dp[i - 1][j - f[i - 1]] + full[i - 1]); } } } return dp[n][m]; } }; // 滚动数组优化 class Solution { public: int exam(std::vector\u0026lt;int\u0026gt;\u0026amp; p, std::vector\u0026lt;int\u0026gt;\u0026amp; part, std::vector\u0026lt;int\u0026gt;\u0026amp; f, std::vector\u0026lt;int\u0026gt;\u0026amp; full) { int n = p.size(); int m = 120; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(2, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { dp[i % 2][j] = dp[(i - 1) % 2][j]; if (j - p[i - 1] \u0026gt;= 0) { dp[i % 2][j] = std::max(dp[i % 2][j], dp[(i - 1) % 2][j - p[i - 1]] + part[i - 1]); } if (j - f[i - 1] \u0026gt;= 0) { dp[i % 2][j] = std::max(dp[i % 2][j], dp[(i - 1) % 2][j - f[i - 1]] + full[i - 1]); } } } return dp[n % 2][m]; } }; Exercise Lintcode 1538 卡牌游戏 II Lintcode 1538 卡牌游戏 II Exercise Lintcode 700 杆子分割 Lintcode 700 杆子分割 ","chapter-22-双序列动态规划#Chapter 22: 双序列动态规划":" 顾名思义，有两个序列/字符串，需要进行一些操作 每个序列本身是一维的 可以转化为二维动态规划 Example: Lintcode 77 最长公共子序列 Lintcode 77 最长公共子序列 题目分析 公共子序列一定是对应的字符按顺序都相等 找到最长的对应对子，且对子连线不能相交 动态规划组成部分一：确定状态 设A长度是m，B长度是n\n现在我们考虑最优策略产生出的最长公共子序列（虽然还不知道是什么）\n最后一步：观察A[m - 1]和B[n - 1]这两个字符是否作为一个对子在最优策略中\n最长公共子序列也是公共子序列：长度是L -\u0026gt; 选定了L个对应的对子 最长公共子序列 情况一：对子中没有A[m - 1] 推论：A和B的最长公共子序列就是 A 前 m - 1 个字符和 B 前 n 个字符的最长公共子序列 情况二：对子中没有B[n - 1] 推论：A和B的最长公共子序列就是 A 前 m 个字符和 B 前 n - 1 个字符的最长公共子序列 情况三：对子中有 A[m - 1] - B[n - 1] 推论：A和B的最长公共子序列就是 A 前 m - 1 个字符和 B 前 n - 1 个字符的最长公共子序列 + A[m - 1] 子问题 要求A[0 .. m - 1]和B[0 .. n - 2]的最长公共子序列，A[0 .. m - 2]和B[0 .. n - 1]的最长公共子序列和A[0 .. m - 2]和B[0 .. n - 2]的最长公共子序列 原来是求A[0 .. m - 1]和B[0 .. n - 1]的最长公共子序列 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符[0 .. j - 1]的最长公共子序列的长度 动态规划组成部分二：转移方程 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符[0 .. j - 1]的最长公共子序列的长度 要求f[m][n] f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1 | A[i - 1] == B[j - 1]) 动态规划组成部分三：初始条件和边界情况 f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符[0 .. j - 1]的最长公共子序列的长度 转移方程：f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1 | A[i - 1] == B[j - 1]) 初始条件：空串和任何串的最长公共子序列长度是0 f[0][j] = 0, j = 0 .. n f[i][0] = 0, i = 0 .. m 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: int longestCommonSubsequence(std::string\u0026amp; A, std::string\u0026amp; B) { int n = A.size(); int m = B.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { if (i == 0 || j == 0) { f[i][j] = 0; continue; } f[i][j] = std::max(f[i][j - 1], f[i - 1][j]); if (A[i - 1] == B[j - 1]) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + 1); } } } return f[n][m]; } }; 打印最长公共子序列 class Solution { public: int longestCommonSubsequence(std::string\u0026amp; A, std::string\u0026amp; B) { int n = A.size(); int m = B.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; pi(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1, 0)); for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { if (i == 0 || j == 0) { f[i][j] = 0; continue; } f[i][j] = std::max(f[i][j - 1], f[i - 1][j]); if (f[i][j] == f[i - 1][j]) { pi[i][j] = 1; } else { pi[i][j] = 2; } if (A[i - 1] == B[j - 1]) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + 1); if (f[i][j] == f[i - 1][j - 1] + 1) { pi[i][j] = 3; } } } } std::vector\u0026lt;char\u0026gt; routine(f[n][m]); int p = f[n][m] - 1; int i = n; int j = m; while (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0) { if (pi[i][j] == 1) { --i; // not using A\u0026#39;s tail } else { if (pi[i][j] == 2) { --j; // not using B\u0026#39;s tail } else { routine[p] = A[i - 1]; --p; --i; --j; } } } for (p = 0; p \u0026lt; f[n][m]; ++p) { std::cout \u0026lt;\u0026lt; routine[p]; } return f[n][m]; } }; Example: Lintcode 29 交叉字符串 Lintcode 29 交叉字符串 动态规划组成部分一：确定状态 首先，如果 X的长度 不等于 A的长度 + B的长度，直接输出 False 设A长度是m，B长度是n，X的长度是m + n 最后一步：假设X是由A和B交错形成的，那么X的最后一个字符X[m + n - 1] 要么是A[m - 1] 那么X[0 .. m + n - 2]是由A[0 .. m - 2]和B[0 .. n - 1]交错形成的 要么是B[n - 1] 那么X[0 .. m + n - 2]是由A[0 .. m - 1]和B[0 .. n - 2]交错形成的 子问题 要求X[0 .. m + n - 1]是否由A[0 .. m - 1]和B[0 .. n - 1]交错形成 需要知道X[0 .. m + n - 2]是否由A[0 .. m - 2]和B[0 .. n - 1]交错形成，以及X[0 .. m + n - 2]是否由A[0 .. m - 1]和B[0 .. n - 2]交错形成 子问题 状态：设f[s][i][j]为X前s个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 但是s = i + j，所以可以简化为：设f[i][j]为X前i + j个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 动态规划组成部分二：转移方程 设f[i][j]为X前i + j个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 f[i][j] = (f[i - 1][j] \u0026amp;\u0026amp; X[i + j - 1] == A[i - 1]) || (f[i][j - 1] \u0026amp;\u0026amp; X[i + j - 1] == B[j - 1]) 动态规划组成部分三：初始条件和边界情况 设f[i][j]为X前i + j个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 f[i][j] = (f[i - 1][j] \u0026amp;\u0026amp; X[i + j - 1] == A[i - 1]) || (f[i][j - 1] \u0026amp;\u0026amp; X[i + j - 1] == B[j - 1]) 初始条件：空串由A的空串和B的空串交错形成 -\u0026gt; f[0][0] = true 边界情况：如果i = 0，不考虑情况一；如果j = 0，不考虑情况二 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][m] f[1][0], f[1][1], ..., f[1][m] \u0026hellip; f[n][0], f[n][1], ..., f[n][m] 答案是f[n][m] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isInterleave(std::string\u0026amp; A, std::string\u0026amp; B, std::string\u0026amp; X) { int n = A.size(); int m = B.size(); if (X.size() != n + m) { return false; } std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;bool\u0026gt;(m + 1, false)); int i, j; for (i = 0; i \u0026lt;= n; ++i) { for (j = 0; j \u0026lt;= m; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = true; continue; } f[i][j] = false; if (i \u0026gt; 0 \u0026amp;\u0026amp; X[i + j - 1] == A[i - 1] \u0026amp;\u0026amp; f[i - 1][j]) { f[i][j] = true; } if (j \u0026gt; 0 \u0026amp;\u0026amp; X[i + j - 1] == B[j - 1] \u0026amp;\u0026amp; f[i][j - 1]) { f[i][j] = true; } } } return f[n][m]; } }; 滚动数组优化 class Solution { public: bool isInterleave(std::string\u0026amp; A, std::string\u0026amp; B, std::string\u0026amp; X) { int n = A.size(); int m = B.size(); if (X.size() != n + m) { return false; } // first std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f(2, std::vector\u0026lt;bool\u0026gt;(m + 1, false)); int i, j; // second int old, now = 0; for (i = 0; i \u0026lt;= n; ++i) { // third old = now; now = 1 - now; // then change all f[i] to f[now] // change all f[i - 1] to f[old] for (j = 0; j \u0026lt;= m; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[now][j] = true; continue; } f[now][j] = false; if (i \u0026gt; 0 \u0026amp;\u0026amp; X[i + j - 1] == A[i - 1] \u0026amp;\u0026amp; f[old][j]) { f[now][j] = true; } if (j \u0026gt; 0 \u0026amp;\u0026amp; X[i + j - 1] == B[j - 1] \u0026amp;\u0026amp; f[now][j - 1]) { f[now][j] = true; } } } return f[now][m]; } }; Example: Lintcode 119 编辑距离 Lintcode 119 编辑距离 最小操作次数 == 最小编辑距离 动态规划组成部分一：确定状态 设A长度是m，B长度是n\n全部操作完成后A的长度也是n，并且A[n - 1] = B[n - 1]\n于是最优策略（以及所有合法策略）最终都是让A的最后一个字符变成B的最后一个字符\n情况一：A在最后插入B[n - 1]\n要将A[0 .. m - 1]变成B[0 .. n - 2] 情况二：A最后一个字符替换成B[n - 1]\n要将A[0 .. m - 2]变成B[0 .. n - 2] 情况三：A删掉最后一个字符\n要将A[0 .. m - 2]变成B[0 .. n - 1] 情况四：A和B最后一个字符相等\n要将A[0 .. m - 2]变成B[0 .. n - 2] 子问题 要求A[0 .. m - 1]和B[0 .. n - 2]的最小编辑距离，A[0 .. m - 2]和B[0 .. n - 1]的最小编辑距离和A[0 .. m - 2]和B[0 .. n - 2]的最小编辑距离 原来是求A[0 .. m - 1]和B[0 .. n - 1]的最小编辑距离 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B的前j个字符B[0 .. j - 1]的最小编辑距离 动态规划组成部分二：转移方程 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离 要求f[m][n] f[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1]) 动态规划组成部分三：初始条件和边界情况 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离\n要求f[m][n]\nf[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1]) 初始条件：一个空串和一个长度为L的串的最小编辑距离是L\nf[0][j] = j (j = 0, 1, 2, ..., n) f[i][0] = i (j = 0, 1, 2, ..., m) 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: int minDistance(std::string\u0026amp; A, std::string\u0026amp; B) { int m = A.size(); int n = B.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(m + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); int i, j; for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { if (i == 0) { // insert, insert, ... f[i][j] = j; continue; } if (j == 0) { // delete, delete, ... f[i][j] = i; continue; } // insert, delete, replace f[i][j] = std::min(std::min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { // 情况四 f[i][j] = std::min(f[i][j], f[i - 1][j - 1]); } } } return f[m][n]; } }; 滚动数组优化 class Solution { public: int minDistance(std::string\u0026amp; A, std::string\u0026amp; B) { int m = A.size(); int n = B.size(); // first std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(2, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); int i, j; // second int old, now = 0; for (i = 0; i \u0026lt;= m; ++i) { // third old = now; now = 1 - now; for (j = 0; j \u0026lt;= n; ++j) { if (i == 0) { f[now][j] = j; continue; } if (j == 0) { f[now][j] = i; continue; } f[now][j] = std::min(std::min(f[old][j], f[now][j - 1]), f[old][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { f[now][j] = std::min(f[now][j], f[old][j - 1]); } } } return f[now][n]; } }; 编辑距离的实际用途 比较两个字符串 显示较错：input \u0026ldquo;Chia\u0026rdquo; 然后根据最小编辑距离1 显示结果\u0026quot;China\u0026quot;，然后根据最小编辑距离2 显示结果\u0026quot;Chinaa\u0026quot;, \u0026hellip; Example: Lintcode 154 Regular Expression Matching Lintcode 154 Regular Expression Matching 动态规划组成部分一：确定状态 双序列型动态规划\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于正则表达式B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非.非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是.，则A[m - 1]一定是和.匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它代表B[n - 2] = c可以重复0次或多次，它们是一个整体c*，需要考虑A[m - 1]是0个c，还是多个c中的最后一个\nA[m - 1]是0个c，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 3]是否匹配 A[m - 1]是多个c中的最后一个，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配 这种情况必须A[m - 1] = c或者c = . 子问题 要求A前m个字符和B前n个字符能否匹配，需要知道A前m个字符和B前n - 1个字符，A前m - 1个字符和B前n个字符以及A前m个字符和B前n - 2个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 动态规划组成部分二：转移方程 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u0026gt; 0，并且B[j - 1] = .或者A[i - 1] = B[j - 1] f[i][j - 2] || (f[i - 1][j] \u0026amp;\u0026amp; (B[j - 2] == . || B[j - 2] == A[i - 1]))，如果B[j - 1] = * 动态规划组成部分三：初始条件和边界情况 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空正则表达式匹配：f[0][0] = true 空正则表达式不能匹配长度\u0026gt; 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 2] 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026amp; s, std::string\u0026amp; p) { int m = s.size(); int n = p.size(); std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f(m + 1, std::vector\u0026lt;bool\u0026gt;(n + 1, false)); int i, j; for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = true; continue; } if (j == 0) { // i \u0026gt; 0 f[i][j] = false; continue; } f[i][j] = false; if (p[j - 1] != \u0026#39;*\u0026#39;) { if (i \u0026gt; 0 \u0026amp;\u0026amp; (p[j - 1] == \u0026#39;.\u0026#39; || p[j - 1] == s[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // c* // 0 c\u0026#39;s if (j \u0026gt; 1) { f[i][j] = f[i][j - 2]; } // \u0026gt;= 1 c\u0026#39;s, c: p[j - 2] if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 1 \u0026amp;\u0026amp; (p[j - 2] == \u0026#39;.\u0026#39; || p[j - 2] == s[i - 1])) { f[i][j] = f[i][j] || f[i - 1][j]; } } } } return f[m][n]; } }; Example: Lintcode 192 Wildcard Matching Lintcode 192 Wildcard Matching 动态规划组成部分一：确定状态 双序列型动态规划\n和Regular Expression Matching很类似，因为.和?作用相同，但是这题中*可以匹配0个或多个任意字符\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于Wildcard B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非?非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是?，则A[m - 1]一定是和?匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它可以匹配0个或任意多个字符，需要考虑A[m - 1]有没有被这个*匹配\nA[m - 1]不被*匹配，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 2]是否匹配 A[m - 1]被*匹配，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配 子问题 要求A前m个字符和B前n个字符能否匹配，需要知道A前m - 1个字符和B前n - 1个字符，A前m个字符和B前n - 1个字符以及A前m - 1个字符和B前n个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 动态规划组成部分二：转移方程 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u0026gt; 0，并且B[j - 1] = ?或者A[i - 1] = B[j - 1] f[i - 1][j] || f[i][j - 1]，如果B[j - 1] = * 动态规划组成部分三：初始条件和边界情况 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空Wildcard匹配：f[0][0] = true 空Wildcard不能匹配长度\u0026gt; 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 1] 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026amp; A, std::string\u0026amp; B) { int m = A.size(); int n = B.size(); std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f(m + 1, std::vector\u0026lt;bool\u0026gt;(n + 1, false)); int i, j; for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = true; continue; } if (j == 0) { f[i][j] = false; continue; } // j \u0026gt; 0 f[i][j] = false; if (B[j - 1] != \u0026#39;*\u0026#39;) { if (i \u0026gt; 0 \u0026amp;\u0026amp; (B[j - 1] == \u0026#39;?\u0026#39; || B[j - 1] == A[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // * represents 0 character f[i][j] = f[i][j - 1]; if (i \u0026gt; 0) { f[i][j] = (f[i][j] || f[i - 1][j]); } } } } return f[m][n]; } }; Example: Lintcode 668 Ones and Zeroes：双背包 Lintcode 668 Ones and Zeroes 动态规划组成部分一：确定状态 最后一步：最优策略组成了最多的01串，其中有没有最后一个字符串S_{T - 1} 情况一：没有S_{T - 1} 需要知道前T - 1个01串中，用m个0和n个1最多能组成多少个01串 情况二：有S_{T - 1} 设第T - 1个01串中有a_{T - 1}个0，b_{T - 1}个1 需要知道前T - 1个01串中，用m - a_{T - 1}个0和n - b_{T - 1}个1最多能组成多少个01串 子问题 0和1的个数在变化，如何记录？ 直接放入状态 状态：设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 动态规划组成部分二：转移方程 设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u0026gt;= a_{i - 1} \u0026amp;\u0026amp; k \u0026gt;= b_{i - 1}) 动态规划组成部分三：初始条件和边界情况 设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u0026gt;= a_{i - 1} \u0026amp;\u0026amp; k \u0026gt;= b_{i - 1}) 初始条件：f[0][0 ~ m][0 ~ n] = 0 无论有多少0和1，前0个01串最多能组成0个 边界情况：f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1必须j \u0026gt;= a_{i - 1} \u0026amp;\u0026amp; k \u0026gt;= b_{i - 1} 动态规划组成部分四：计算顺序 f[0][0][0], f[0][0][1], ..., f[0][0][n], f[0][1][0], ..., f[0][1][n], ..., f[0][m][n] f[1][0][0], f[1][0][1], ..., f[1][0][n], f[1][1][0], ..., f[1][1][n], ..., f[1][m][n] \u0026hellip; f[T][0][0], f[T][0][1], ..., f[T][0][n], f[T][1][0], ..., f[T][1][n], ..., f[T][m][n] 答案是max(f[T][0][0], f[T][0][1], ..., f[T][m][n]) 时间复杂度：O(Tmn) 空间复杂度：O(Tmn)，可以用滚动数组优化空间至O(mn) class Solution { public: int findMaxForm(std::vector\u0026lt;std::string\u0026gt;\u0026amp; A, int m, int n) { if (A.size() == 0) { return 0; } int T = A.size(); std::vector\u0026lt;int\u0026gt; cnt0(T, 0); std::vector\u0026lt;int\u0026gt; cnt1(T, 0); int i, j, k; for (i = 0; i \u0026lt; T; ++i) { cnt0[i] = cnt1[i] = 0; std::string s = A[i]; for (j = 0; j \u0026lt; s.size(); ++j) { if (s[j] == \u0026#39;0\u0026#39;) { ++cnt0[i]; } else { ++cnt1[i]; } } } std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; f(T + 1, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(m + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0))); for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { f[0][i][j] = 0; } } for (i = 1; i \u0026lt;= T; ++i) { for (j = 0; j \u0026lt;= m; ++j) { for (k = 0; k \u0026lt;= n; ++k) { // j 0\u0026#39;s, k 1\u0026#39;s // do not take A[i - 1] f[i][j][k] = f[i - 1][j][k]; // take A[i - 1] if (j \u0026gt;= cnt0[i - 1] \u0026amp;\u0026amp; k \u0026gt;= cnt1[i - 1]) { f[i][j][k] = std::max(f[i][j][k], f[i - 1][j - cnt0[i - 1]][k - cnt1[i - 1]] + 1); } } } } int ans = 0; for (j = 0; j \u0026lt;= m; ++j) { for (k = 0; k \u0026lt;= n; ++k) { ans = std::max(ans, f[T][j][k]); } } return ans; } }; Example: Lintcode 118 Distinct Subsequences Lintcode 118 Distinct Subsequences\n类似于最长公共子序列\nB在A中出现多少次 -\u0026gt; B的每个字符都要在A中出现\nB的“尾巴”是否和A的“尾巴”结成对子\n设f[i][j]为B前j个字符B[0 .. j - 1]在A前i个字符A[0 .. i - 1]中出现多少次\nf[i][j] = f[i - 1][j - 1] | A[i - 1] == B[j - 1] + f[i - 1][j]\nclass Solution { public: int numDistinct(std::string\u0026amp; s, std::string\u0026amp; t) { } }; ","chapter-23-毕业旅行#Chapter 23: 毕业旅行":" Lintcode 816 TSP\nTSP问题（旅行商问题）是 NP 问题非常典型的代表\nTraveling salesman problem\nSolution 1: 排列型DFS 需要开数组存储哪些位置/元素已经被访问 递归中用循环选择下一个符合条件的位置/元素 循环内： 标记访问 递归 标记未访问 分析 DFS 相当于所有城市全排列，但是第一个城市固定是1，需要找到代价最小的路径（全排列） 需要记录当前的路径（包括上一个城市） 搜索过程中可以剪枝：当前路径长度已经 \u0026gt;= 当前最优解即退出 AC class Solution { public: int minCost(int nn, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { // costs: [[i, j, d]] i----j cost is d n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u0026lt;int\u0026gt;(n, 0x3f3f3f3f)); for (i = 0; i \u0026lt; costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; // 第0个城市搞过了 dfs(1, 0, 0); // 第1个城市; 前一个城市是0; 当前花费时间是0 return result; } private: // level is the level-th city // previous city p // current cost c void dfs(int level, int p, int c) { if (level == n) { if (c \u0026lt; result) { result = c; } return; } int i; // next city i, from p // p--\u0026gt;i must have a road for (i = 0; i \u0026lt; n; ++i) { if (!done[i] \u0026amp;\u0026amp; g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; // g[i][j] is the cost to go from city i to j (\u0026lt;---\u0026gt; 双向) std::vector\u0026lt;bool\u0026gt; done; int result; }; Optimize: Pruning class Solution { public: int minCost(int nn, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u0026lt;int\u0026gt;(n, 0x3f3f3f3f)); for (i = 0; i \u0026lt; costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; dfs(1, 0, 0); return result; } private: void dfs(int level, int p, int c) { // 1. pruning!!! if (c \u0026gt;= result) { return; } if (level == n) { // 2. pruning, remove this branch // c \u0026lt; result result = c; return; } int i; for (i = 0; i \u0026lt; n; ++i) { if (!done[i] \u0026amp;\u0026amp; g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; // g[i][j] is the cost to go from city i to j (\u0026lt;---\u0026gt; 双向) std::vector\u0026lt;bool\u0026gt; done; int result; }; Solution 2: 状态压缩型动态规划??? 设城市数为n，则有2^n个子集合 时间复杂度：枚举全部集合2^n，起点n，子问题n。时间复杂度为O(n^2 * 2^n) 空间复杂度：DP数组规模为n * (2^n)。空间复杂度为O(n * 2^n) class Solution { public: int minCost(int n, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads) { int inf = 1000000000; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; graph(n + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); ConstructGraph(graph, roads, n); // state_size represent the number of cities int state_size = 1 \u0026lt;\u0026lt; n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(state_size, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 0; i \u0026lt; state_size; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { f[i][j] = inf; } } f[1][1] = 0; for (int state = 0; state \u0026lt; state_size; state++) { for (int i = 2; i \u0026lt; n + 1; i++) { if ((state \u0026amp; (1 \u0026lt;\u0026lt; (i - 1))) == 0) { continue; } int prev_state = state ^ (1 \u0026lt;\u0026lt; (i - 1)); for (int j = 1; j \u0026lt; n + 1; j++) { if ((prev_state \u0026amp; (1 \u0026lt;\u0026lt; (j - 1))) == 0) { continue; } f[state][i] = std::min(f[state][i], f[prev_state][j] + graph[j][i]); } } } int minimal_cost = inf; for (int i = 0; i \u0026lt; n + 1; i++) { minimal_cost = std::min(minimal_cost, f[state_size - 1][i]); } return minimal_cost; } private: void ConstructGraph(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads, int n) { int inf = 1000000000; for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { graph[i][j] = inf; } } for (int i = 0; i \u0026lt; roads.size(); i++) { int a = roads[i][0], b = roads[i][1], c = roads[i][2]; graph[a][b] = std::min(graph[a][b], c); graph[b][a] = std::min(graph[b][a], c); } } }; ","chapter-23-毕业旅行-1#Chapter 23: 毕业旅行":" Lintcode 816 TSP\nTSP问题（旅行商问题）是 NP 问题非常典型的代表\nTraveling salesman problem\nSolution 1: 排列型DFS 需要开数组存储哪些位置/元素已经被访问 递归中用循环选择下一个符合条件的位置/元素 循环内： 标记访问 递归 标记未访问 分析 DFS 相当于所有城市全排列，但是第一个城市固定是1，需要找到代价最小的路径（全排列） 需要记录当前的路径（包括上一个城市） 搜索过程中可以剪枝：当前路径长度已经 \u0026gt;= 当前最优解即退出 AC class Solution { public: int minCost(int nn, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { // costs: [[i, j, d]] i----j cost is d n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u0026lt;int\u0026gt;(n, 0x3f3f3f3f)); for (i = 0; i \u0026lt; costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; // 第0个城市搞过了 dfs(1, 0, 0); // 第1个城市; 前一个城市是0; 当前花费时间是0 return result; } private: // level is the level-th city // previous city p // current cost c void dfs(int level, int p, int c) { if (level == n) { if (c \u0026lt; result) { result = c; } return; } int i; // next city i, from p // p--\u0026gt;i must have a road for (i = 0; i \u0026lt; n; ++i) { if (!done[i] \u0026amp;\u0026amp; g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; // g[i][j] is the cost to go from city i to j (\u0026lt;---\u0026gt; 双向) std::vector\u0026lt;bool\u0026gt; done; int result; }; Optimize: Pruning class Solution { public: int minCost(int nn, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u0026lt;int\u0026gt;(n, 0x3f3f3f3f)); for (i = 0; i \u0026lt; costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; dfs(1, 0, 0); return result; } private: void dfs(int level, int p, int c) { // 1. pruning!!! if (c \u0026gt;= result) { return; } if (level == n) { // 2. pruning, remove this branch // c \u0026lt; result result = c; return; } int i; for (i = 0; i \u0026lt; n; ++i) { if (!done[i] \u0026amp;\u0026amp; g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; // g[i][j] is the cost to go from city i to j (\u0026lt;---\u0026gt; 双向) std::vector\u0026lt;bool\u0026gt; done; int result; }; Solution 2: 状态压缩型动态规划??? 设城市数为n，则有2^n个子集合 时间复杂度：枚举全部集合2^n，起点n，子问题n。时间复杂度为O(n^2 * 2^n) 空间复杂度：DP数组规模为n * (2^n)。空间复杂度为O(n * 2^n) class Solution { public: int minCost(int n, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads) { int inf = 1000000000; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; graph(n + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); ConstructGraph(graph, roads, n); // state_size represent the number of cities int state_size = 1 \u0026lt;\u0026lt; n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(state_size, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 0; i \u0026lt; state_size; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { f[i][j] = inf; } } f[1][1] = 0; for (int state = 0; state \u0026lt; state_size; state++) { for (int i = 2; i \u0026lt; n + 1; i++) { if ((state \u0026amp; (1 \u0026lt;\u0026lt; (i - 1))) == 0) { continue; } int prev_state = state ^ (1 \u0026lt;\u0026lt; (i - 1)); for (int j = 1; j \u0026lt; n + 1; j++) { if ((prev_state \u0026amp; (1 \u0026lt;\u0026lt; (j - 1))) == 0) { continue; } f[state][i] = std::min(f[state][i], f[prev_state][j] + graph[j][i]); } } } int minimal_cost = inf; for (int i = 0; i \u0026lt; n + 1; i++) { minimal_cost = std::min(minimal_cost, f[state_size - 1][i]); } return minimal_cost; } private: void ConstructGraph(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads, int n) { int inf = 1000000000; for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { graph[i][j] = inf; } } for (int i = 0; i \u0026lt; roads.size(); i++) { int a = roads[i][0], b = roads[i][1], c = roads[i][2]; graph[a][b] = std::min(graph[a][b], c); graph[b][a] = std::min(graph[b][a], c); } } }; ","chapter-24-双色塔#Chapter 24: 双色塔":" Lintcode 269 双色塔 class Solution { public: int twoColorsTower(int red, int green) { } }; ","chapter-24-双色塔-1#Chapter 24: 双色塔":" Lintcode 269 双色塔\n求方案总数和可行性的问题 很有 可能是动态规划，求最大最小值其次\n求方案总数的问题 99% 都是动态规划\nclass Solution { public: int twoColorsTower(int red, int green) { } }; ","chapter-25-编辑距离#Chapter 25: 编辑距离":"Example: Lintcode 119 编辑距离 Lintcode 119 编辑距离 最小操作次数 == 最小编辑距离 动态规划组成部分一：确定状态 设A长度是m，B长度是n\n全部操作完成后A的长度也是n，并且A[n - 1] = B[n - 1]\n于是最优策略（以及所有合法策略）最终都是让A的最后一个字符变成B的最后一个字符\n情况一：A在最后插入B[n - 1]\n要将A[0 .. m - 1]变成B[0 .. n - 2] 情况二：A最后一个字符替换成B[n - 1]\n要将A[0 .. m - 2]变成B[0 .. n - 2] 情况三：A删掉最后一个字符\n要将A[0 .. m - 2]变成B[0 .. n - 1] 情况四：A和B最后一个字符相等\n要将A[0 .. m - 2]变成B[0 .. n - 2] 子问题 要求A[0 .. m - 1]和B[0 .. n - 2]的最小编辑距离，A[0 .. m - 2]和B[0 .. n - 1]的最小编辑距离和A[0 .. m - 2]和B[0 .. n - 2]的最小编辑距离 原来是求A[0 .. m - 1]和B[0 .. n - 1]的最小编辑距离 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B的前j个字符B[0 .. j - 1]的最小编辑距离 动态规划组成部分二：转移方程 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离 要求f[m][n] f[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1]) 动态规划组成部分三：初始条件和边界情况 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离\n要求f[m][n]\nf[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1]) 初始条件：一个空串和一个长度为L的串的最小编辑距离是L\nf[0][j] = j (j = 0, 1, 2, ..., n) f[i][0] = i (j = 0, 1, 2, ..., m) 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: int minDistance(std::string\u0026amp; A, std::string\u0026amp; B) { int m = A.size(); int n = B.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(m + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); int i, j; for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { if (i == 0) { // insert, insert, ... f[i][j] = j; continue; } if (j == 0) { // delete, delete, ... f[i][j] = i; continue; } // insert, delete, replace f[i][j] = std::min(std::min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { // 情况四 f[i][j] = std::min(f[i][j], f[i - 1][j - 1]); } } } return f[m][n]; } }; 滚动数组优化 class Solution { public: int minDistance(std::string\u0026amp; A, std::string\u0026amp; B) { int m = A.size(); int n = B.size(); // first std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(2, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); int i, j; // second int old, now = 0; for (i = 0; i \u0026lt;= m; ++i) { // third old = now; now = 1 - now; for (j = 0; j \u0026lt;= n; ++j) { if (i == 0) { f[now][j] = j; continue; } if (j == 0) { f[now][j] = i; continue; } f[now][j] = std::min(std::min(f[old][j], f[now][j - 1]), f[old][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { f[now][j] = std::min(f[now][j], f[old][j - 1]); } } } return f[now][n]; } }; 编辑距离的实际用途 比较两个字符串 显示较错：input \u0026ldquo;Chia\u0026rdquo; 然后根据最小编辑距离1 显示结果\u0026quot;China\u0026quot;，然后根据最小编辑距离2 显示结果\u0026quot;Chinaa\u0026quot;, \u0026hellip; Example: Lintcode 154 Regular Expression Matching Lintcode 154 Regular Expression Matching 动态规划组成部分一：确定状态 双序列型动态规划\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于正则表达式B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非.非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是.，则A[m - 1]一定是和.匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它代表B[n - 2] = c可以重复0次或多次，它们是一个整体c*，需要考虑A[m - 1]是0个c，还是多个c中的最后一个\nA[m - 1]是0个c，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 3]是否匹配 A[m - 1]是多个c中的最后一个，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配 这种情况必须A[m - 1] = c或者c = . 子问题 要求A前m个字符和B前n个字符能否匹配，需要知道A前m个字符和B前n - 1个字符，A前m - 1个字符和B前n个字符以及A前m个字符和B前n - 2个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 动态规划组成部分二：转移方程 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u0026gt; 0，并且B[j - 1] = .或者A[i - 1] = B[j - 1] f[i][j - 2] || (f[i - 1][j] \u0026amp;\u0026amp; (B[j - 2] == . || B[j - 2] == A[i - 1]))，如果B[j - 1] = * 动态规划组成部分三：初始条件和边界情况 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空正则表达式匹配：f[0][0] = true 空正则表达式不能匹配长度\u0026gt; 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 2] 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026amp; s, std::string\u0026amp; p) { int m = s.size(); int n = p.size(); std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f(m + 1, std::vector\u0026lt;bool\u0026gt;(n + 1, false)); int i, j; for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = true; continue; } if (j == 0) { // i \u0026gt; 0 f[i][j] = false; continue; } f[i][j] = false; if (p[j - 1] != \u0026#39;*\u0026#39;) { if (i \u0026gt; 0 \u0026amp;\u0026amp; (p[j - 1] == \u0026#39;.\u0026#39; || p[j - 1] == s[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // c* // 0 c\u0026#39;s if (j \u0026gt; 1) { f[i][j] = f[i][j - 2]; } // \u0026gt;= 1 c\u0026#39;s, c: p[j - 2] if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 1 \u0026amp;\u0026amp; (p[j - 2] == \u0026#39;.\u0026#39; || p[j - 2] == s[i - 1])) { f[i][j] = f[i][j] || f[i - 1][j]; } } } } return f[m][n]; } }; Example: Lintcode 192 Wildcard Matching Lintcode 192 Wildcard Matching 动态规划组成部分一：确定状态 双序列型动态规划\n和Regular Expression Matching很类似，因为.和?作用相同，但是这题中*可以匹配0个或多个任意字符\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于Wildcard B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非?非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是?，则A[m - 1]一定是和?匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它可以匹配0个或任意多个字符，需要考虑A[m - 1]有没有被这个*匹配\nA[m - 1]不被*匹配，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 2]是否匹配 A[m - 1]被*匹配，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配 子问题 要求A前m个字符和B前n个字符能否匹配，需要知道A前m - 1个字符和B前n - 1个字符，A前m个字符和B前n - 1个字符以及A前m - 1个字符和B前n个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 动态规划组成部分二：转移方程 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u0026gt; 0，并且B[j - 1] = ?或者A[i - 1] = B[j - 1] f[i - 1][j] || f[i][j - 1]，如果B[j - 1] = * 动态规划组成部分三：初始条件和边界情况 设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空Wildcard匹配：f[0][0] = true 空Wildcard不能匹配长度\u0026gt; 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 1] 动态规划组成部分四：计算顺序 f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] \u0026hellip; f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026amp; A, std::string\u0026amp; B) { int m = A.size(); int n = B.size(); std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f(m + 1, std::vector\u0026lt;bool\u0026gt;(n + 1, false)); int i, j; for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = true; continue; } if (j == 0) { f[i][j] = false; continue; } // j \u0026gt; 0 f[i][j] = false; if (B[j - 1] != \u0026#39;*\u0026#39;) { if (i \u0026gt; 0 \u0026amp;\u0026amp; (B[j - 1] == \u0026#39;?\u0026#39; || B[j - 1] == A[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // * represents 0 character f[i][j] = f[i][j - 1]; if (i \u0026gt; 0) { f[i][j] = (f[i][j] || f[i - 1][j]); } } } } return f[m][n]; } }; Example: Lintcode 668 Ones and Zeroes：双背包 Lintcode 668 Ones and Zeroes 动态规划组成部分一：确定状态 最后一步：最优策略组成了最多的01串，其中有没有最后一个字符串S_{T - 1} 情况一：没有S_{T - 1} 需要知道前T - 1个01串中，用m个0和n个1最多能组成多少个01串 情况二：有S_{T - 1} 设第T - 1个01串中有a_{T - 1}个0，b_{T - 1}个1 需要知道前T - 1个01串中，用m - a_{T - 1}个0和n - b_{T - 1}个1最多能组成多少个01串 子问题 0和1的个数在变化，如何记录？ 直接放入状态 状态：设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 动态规划组成部分二：转移方程 设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u0026gt;= a_{i - 1} \u0026amp;\u0026amp; k \u0026gt;= b_{i - 1}) 动态规划组成部分三：初始条件和边界情况 设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u0026gt;= a_{i - 1} \u0026amp;\u0026amp; k \u0026gt;= b_{i - 1}) 初始条件：f[0][0 ~ m][0 ~ n] = 0 无论有多少0和1，前0个01串最多能组成0个 边界情况：f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1必须j \u0026gt;= a_{i - 1} \u0026amp;\u0026amp; k \u0026gt;= b_{i - 1} 动态规划组成部分四：计算顺序 f[0][0][0], f[0][0][1], ..., f[0][0][n], f[0][1][0], ..., f[0][1][n], ..., f[0][m][n] f[1][0][0], f[1][0][1], ..., f[1][0][n], f[1][1][0], ..., f[1][1][n], ..., f[1][m][n] \u0026hellip; f[T][0][0], f[T][0][1], ..., f[T][0][n], f[T][1][0], ..., f[T][1][n], ..., f[T][m][n] 答案是max(f[T][0][0], f[T][0][1], ..., f[T][m][n]) 时间复杂度：O(Tmn) 空间复杂度：O(Tmn)，可以用滚动数组优化空间至O(mn) class Solution { public: int findMaxForm(std::vector\u0026lt;std::string\u0026gt;\u0026amp; A, int m, int n) { if (A.size() == 0) { return 0; } int T = A.size(); std::vector\u0026lt;int\u0026gt; cnt0(T, 0); std::vector\u0026lt;int\u0026gt; cnt1(T, 0); int i, j, k; for (i = 0; i \u0026lt; T; ++i) { cnt0[i] = cnt1[i] = 0; std::string s = A[i]; for (j = 0; j \u0026lt; s.size(); ++j) { if (s[j] == \u0026#39;0\u0026#39;) { ++cnt0[i]; } else { ++cnt1[i]; } } } std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; f(T + 1, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(m + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0))); for (i = 0; i \u0026lt;= m; ++i) { for (j = 0; j \u0026lt;= n; ++j) { f[0][i][j] = 0; } } for (i = 1; i \u0026lt;= T; ++i) { for (j = 0; j \u0026lt;= m; ++j) { for (k = 0; k \u0026lt;= n; ++k) { // j 0\u0026#39;s, k 1\u0026#39;s // do not take A[i - 1] f[i][j][k] = f[i - 1][j][k]; // take A[i - 1] if (j \u0026gt;= cnt0[i - 1] \u0026amp;\u0026amp; k \u0026gt;= cnt1[i - 1]) { f[i][j][k] = std::max(f[i][j][k], f[i - 1][j - cnt0[i - 1]][k - cnt1[i - 1]] + 1); } } } } int ans = 0; for (j = 0; j \u0026lt;= m; ++j) { for (k = 0; k \u0026lt;= n; ++k) { ans = std::max(ans, f[T][j][k]); } } return ans; } }; Example: Lintcode 118 Distinct Subsequences Lintcode 118 Distinct Subsequences\n类似于最长公共子序列\nB在A中出现多少次 -\u0026gt; B的每个字符都要在A中出现\nB的“尾巴”是否和A的“尾巴”结成对子\n设f[i][j]为B前j个字符B[0 .. j - 1]在A前i个字符A[0 .. i - 1]中出现多少次\nf[i][j] = f[i - 1][j - 1] | A[i - 1] == B[j - 1] + f[i - 1][j]\nclass Solution { public: int numDistinct(std::string\u0026amp; s, std::string\u0026amp; t) { } }; ","chapter-25-编辑距离-1#Chapter 25: 编辑距离":" Click on this link (Really Important) The most relevant problem LCS: Longest common subsequences LIS: Longest increasing subsequences Relevant Problems Lintcode 640 一次编辑距离 Lintcode 623 K步编辑 ","chapter-26-动态规划难题专场#Chapter 26: 动态规划难题专场":"Lintcode 752 Rogue Knight Sven ","chapter-3-打劫房屋-坐标型前缀型#Chapter 3: 打劫房屋: 坐标型，前缀型":"","chapter-4-最大矩形--最大直方图坐标型#Chapter 4: 最大矩形 \u0026amp;\u0026amp; 最大直方图：坐标型":"Covered all topics of Dynamic Programming\nChapter 1: DP 入门 DP题目特点 最值型动态规划 \u0026amp;\u0026amp; DP组成部分一：确定状态 递归写法的不可行性 递归写法 递归写法的问题 DP组成部分二：转移方程（到此对了一半，比确定状态简单一些） DP组成部分三：初始条件和边界情况 DP组成部分四：计算顺序 Time Complexity Coding 669 计数型动态规划 DP组成部分一：确定状态 DP组成部分二：转移方程 DP组成部分三：初始条件和边界情况 DP组成部分四：计算顺序 Coding 存在型动态规划 DP组成部分一：确定状态 DP组成部分二：转移方程 DP组成部分三：初始条件和边界情况 DP组成部分四：计算顺序 Coding In summary Exercise1: 金字塔 Exercise2: 乘积最大子序列 Chapter 2: 动态规划初探 + 坐标型动态规划 + 位操作型动态规划 初探 坐标型动态规划 题目分析 初始条件和边界情况 Coding 初探 序列型动态规划 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding In summary: seq-type 初探 划分型动态规划 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding 坐标型动态规划：最小路径和 坐标型动态规划：最小路径和\u0026ndash;路径打印 坐标型动态规划：最小路径和\u0026ndash;空间优化 坐标型动态规划：炸弹袭击 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 四个方向 Coding 坐标型动态规划 总结 位操作型动态规划：Counting Bits 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding Exercise: 最长上升子序列 Chapter 3: 打劫房屋: 坐标型，前缀型 坐标型 动态规划 代码思路 前缀型 Chapter 4: 最大矩形 \u0026amp;\u0026amp; 最大直方图：坐标型 最大矩形 直方图最大矩形覆盖 Chapter 5: 最短假期：坐标型 Exercise: 相关题目 Chapter 6: 最小调整代价：背包型 状态 转移方程 思路 1.临界值： 2.状态转移方程： Coding Chapter 7: 香槟塔：坐标型 Step 1 : 如何定义状态？ Step 2 : 临界值是什么？ Step 3 : 状态转移方程怎么写？ Step 4 : DP结果是什么？ 空间优化： Soluton 1: row % 2 Soluton 2: 一维数组 Chapter 8: 飞行棋I Step 1 : 如何定义状态？ Step 2 : 临界值是什么？ Step 3 : 状态转移方程怎么写？ Step 4 : DP结果是什么？ DP Solution Chapter 9: 序列型动态规划 序列型动态规划\u0026ndash;简介 序列型动态规划\u0026ndash;数字翻转 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding Mine Correct Solution Official Solution 序列型动态规划的时间优化\u0026ndash;房屋染色II Mine Correct Answer O(nk^2) 时间优化 Mine correct time optimized solution Official time optimized solution 序列型动态规划\u0026ndash;买卖股票1 动态规划解法 Mine correct solution Official solution: Better 序列型动态规划\u0026ndash;买卖股票2 题目分析 Official solution 序列型动态规划\u0026ndash;买卖股票3: 序列型 题目分析 动态规划组成部分一：确定状态 记录阶段 动态规划组成部分一：确定状态 continued 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution 序列型动态规划\u0026ndash;买卖股票4 题目分析 记录阶段 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution Official Solution : rolling array optimization 序列型动态规划\u0026ndash;小结 初探 最长上升子序列(LIS) 最长序列型动态规划 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 思考：如何做到时间复杂度O(nlogn) Official Solution: O(n^2) phone interview Exercise 602 俄罗斯套娃信封 Mine first solution: Time Limit Exceeded: dp Mine second solution: Time Limit Exceeded: dfs Correct forum official solution 课后习题 Chapter 10: 骰子求和：背包型 背包型 Chapter 11: 最长有效括号：后缀型(与前缀型只区别与计算顺序) Chapter 12: 最大子数组差 Mine solution Official Solution: with some Greedy idea 相关题目 Chapter 13: 工作安排：坐标型 Chapter 14: 染色问题：坐标型 Chapter 15: 最小的窗口子序列：匹配型 The first solution with O(n^2 * (n + m)) approximate to O(n^3) The second solution with O(n * (n + m)) approximate to O(n^2), we should let time less than 10^8, if n is 20000, then it becomes 4 * 10^8 \u0026gt; 10^8, which is not good The thrid solution: Dynamic Programming: Time O(n * m) Space O(n * m) Relative Problems Chapter 16: 划分型、博弈型 和 背包型 动态规划 划分型动态规划 Example: Lintcode 513 Perfect Square：划分型 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding Solution Follow up Example: Lintcode 108 Palindrome Partitioning II 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 回文串判断 回文串种类 生成回文串 在字符串中找到所有回文串 记录回文串 回到原题 Example: Lintcode 437 Copy Books 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding: The First Solution with DP Coding: The Second Solution with Binary Search Summary 博弈型动态规划 Example: Lintcode 394 Coins in a Line 动态规划组成部分一：确定状态 博弈型动态规划：必胜 vs 必败 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution The Second Solution with Time O(1) Space O(1) 背包型动态规划 直觉 Example: Lintcode 92 Backpack 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 DP Official Solution Backpack Official Solution Summary Example: Lintcode 563 Backpack V 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution 进一步空间优化 My Correct Solution Exercise: Lintcode 564 BackPack IV (组合总和 IV) 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Offical Solution Summary Exercise: Single Choice Chapter 17: 背包型 和 区间型 动态规划 01 backpack 打印路径 complete backpack multiple backpack 区间型动态规划 Example: Lintcode 667 Longest Palindrome Subsequence 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution 记忆化搜索方法 与递推方法比较 Coding with Template (important) Example: Lintcode 396 Coins in A Line III （区间型动态规划—博弈问题） 博弈 动态规划组成部分一：确定状态 博弈子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 430 Scramble String 动态规划组成部分一：确定状态 子问题 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 记忆化搜索 Example: Lintcode 168 吹气球 (消去型 \u0026ndash;\u0026gt; 区间型) 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Summary Chapter 18: 石头碰撞：背包型 Chapter 19: 合并金币：区间型 Chapter 20: 外卖满减：01背包 Exercise Lintcode 92 backpack Exercise Lintcode 125 backpack II Exercise Lintcode 563 backpack V Chapter 21: 考试策略：0/0.5/1背包 Exercise Lintcode 1538 卡牌游戏 II Exercise Lintcode 700 杆子分割 Chapter 22: 双序列动态规划 Example: Lintcode 77 最长公共子序列 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 打印最长公共子序列 Example: Lintcode 29 交叉字符串 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 滚动数组优化 Example: Lintcode 119 编辑距离 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 滚动数组优化 编辑距离的实际用途 Example: Lintcode 154 Regular Expression Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 192 Wildcard Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 668 Ones and Zeroes：双背包 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 118 Distinct Subsequences Chapter 23: 毕业旅行 Solution 1: 排列型DFS 分析 AC Optimize: Pruning Solution 2: 状态压缩型动态规划??? Chapter 24: 双色塔 Chapter 25: 编辑距离 Example: Lintcode 119 编辑距离 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 滚动数组优化 编辑距离的实际用途 Example: Lintcode 154 Regular Expression Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 192 Wildcard Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 668 Ones and Zeroes：双背包 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 118 Distinct Subsequences Chapter 23: 毕业旅行 Solution 1: 排列型DFS 分析 AC Optimize: Pruning Solution 2: 状态压缩型动态规划??? Chapter 24: 双色塔 Chapter 25: 编辑距离 (Really Important) The most relevant problem Relevant Problems Chapter 26: 动态规划难题专场 Lintcode 752 Rogue Knight Sven Others Note 动态规划的题型 简历: 最好一页 How to use heap in c++ Others Note 动态规划的题型 简历: 最好一页 How to use heap in c++ Chapter 1: DP 入门 常见DP类型：\n坐标型（20%） 序列型（20%） 划分型（20%） 区间型（15%） 背包型（10%） 最长序列型（5%） 博弈型（5%） 综合型（5%） DP时间空间优化\nFollowUp 常考：滚动数组 或者 降维 DP打印路径\nDP题目特点 计数(求方案数) 有多少种方式走到右下角 有多少种方法选出k个数使得和是sum How many ways (can you / does it)? 求最大最小值(求最值) 从左上角走到右下角路径的最大数字和 最长上升子序列长度 Maximum/ Minimum/ Longest/ Shortest/ Minimum Cost \u0026hellip; 存在性(判断可行性) 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum Yes/No, True/False, 0/1 DP都有方向性：数组顺序固定或不可变(方向性: 从头到尾或者从尾到头)\n状态：把你觉得会影响结果的信息，全部放到数组的下标中去: 觉得有两个信息影响结果，就弄成二维数组；觉得有三个信息影响结果，就弄成三位数组\n状态转移：永远考虑最后一次干了什么事情，最后一步从哪儿来，最后一次做了什么操作\n初始条件：其实就是 用转移方程算不出来，但又需要它的定义，此时需要手工定义 初始条件和边界情况 (人话)：最小的值搞定一下和不要数组越界\n计算顺序：的确定只有一个原则，当你要算f[X]等式左边的时候，右边用到的状态都已经算过了\n最值型动态规划 \u0026amp;\u0026amp; DP组成部分一：确定状态 Lintcode 669: Coin Change DP组成部分一：确定状态 状态在DP中的作用属于定海神针 简单的说，解DP的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么 类似于解数学题中 X, Y, Z 代表什么 确定状态需要两个意识： 最后一步：最优策略中的最后一个决策 当前问题： 虽然我们不知道最优策略是什么，但是最优策略肯定是K枚硬币a1, a2, ..., ak面值加起来是27 所以一定有一枚最后的硬币：ak 除掉这枚硬币，前面硬币的面值加起来是27 - ak Key 1: 我们不关心前面的K - 1枚硬币是怎么拼出27 - ak的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道ak和K，但是我们确定前面的硬币拼出了27 - ak Key 2: 因为是最优策略，所以拼出27 - ak的硬币数一定要最少，否则这就不是最优策略了 子问题 所以我们就要求：最少用多少枚硬币拼出27 - ak 愿问题是 最少用多少枚硬币拼出27 我们将原问题转化成了一个子问题，而且规模更小：27 - ak 为了简化定义，我们设状态f(X) = 最少用多少枚硬币拼出X 递归写法的不可行性 递归写法 int f(int X) { // f(X)=最少用多少枚硬币拼出X if (X == 0) { // 0元钱只要0枚硬币 return 0; } int result = 0x3f3f3f3f; // INT_MAX; // 初始化用无穷大 if (X \u0026gt;= 2) { // 最后一枚硬币是2元 result = std::max(f(X - 2) + 1, result); } if (X \u0026gt;= 5) { // 最后一枚硬币是5元 result = std::max(f(X - 5) + 1, result); } if (X \u0026gt;= 7) { // 最后一枚硬币是7元 result = std::max(f(X - 7) + 1, result); } return result; } 递归写法的问题 做了很多重复计算，效率低下 如何避免？ DP：将计算结果保存下来，并改变计算顺序 DP组成部分二：转移方程（到此对了一半，比确定状态简单一些） DP组成部分二：转移方程 设状态f[X]=最少用多少枚硬币拼出X 对于任意X, $f = min{f[X - 2] + 1, f[X - 5] + 1, f[X - 7] + 1}$ f[X] f[X - 2] + 1 f[X - 5] + 1 f[X - 7] + 1 拼出X所需最少的硬币数 拼出X-2所需最少的硬币数，加上最后一枚硬币2 拼出X-5所需最少的硬币数，加上最后一枚硬币5 拼出X-7所需最少的硬币数，加上最后一枚硬币7 DP组成部分三：初始条件和边界情况 DP组成部分三：初始条件和边界情况 $f = min{f[X - 2] + 1, f[X - 5] + 1, f[X - 7] + 1}$ 两个问题： X - 2, X - 5 或者 X - 7小于0怎么办？ 什么时候停下来？ 如果不能拼出Y，就定义f[Y]=正无穷 例如f[-1] = f[-2] = ... =正无穷 所以f[1] = min{f[-1] + 1, f[-4] + 1, f[-6] + 1} = 正无穷，表示拼不出来1 这道题里初始条件为：f[0] = 0 初始条件其实就是 用转移方程算不出来，但又需要它的定义，此时需要手工定义 初始条件和边界情况 (人话)：最小的值搞定一下和不要数组越界 DP组成部分四：计算顺序 DP组成部分四：计算顺序 拼出X所需的最少硬币数: f[X] = min{f[X - 2] + 1, f[X - 5] + 1, f[X - 7] + 1} 初始条件：f[0] = 0 然后计算f[1], f[2], ..., f[27] 当我们计算到f 时，f[X - 2], f[X - 5], f[X - 7]都已经得到结果了 Key: 计算顺序的确定只有一个原则，当你要算f[X]等式左边的时候，右边用到的状态都已经算过了 Time Complexity 每一步尝试三种硬币，一共27步 与递归算法相比，没有任何重复计算 算法时间复杂度（即需要进行的步数）：时间复杂度 = 27 * 3 如果这道题是：拼出n块钱，有m枚硬币：时间复杂度 = n * m 递归时间复杂读为指数级别 Coding 669 Lintcode 669: Coin Change class Solution { public: // coins // amount // {2, 5, 7} // 27 int coinChange(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int M) { // 0....n: [n+1] // 0...n-1: [n] std::vector\u0026lt;int\u0026gt; f(M + 1); int n = A.size(); // number of kinds of coins // initialization f[0] = 0; int i, j; // f[1], f[2], ..., f[27] for (i = 1; i \u0026lt;= M; ++i) { f[i] = INT_MAX; // last coin A[j] // f[i] = min{f[i - A[0]] + 1, ..., f[i - A[n - 1]] + 1} for (j = 0; j \u0026lt; n; ++j) { if (i \u0026gt;= A[j] \u0026amp;\u0026amp; f[i - A[j]] != INT_MAX) { f[i] = std::min(f[i - A[j]] + 1, f[i]); } } } if (f[M] == INT_MAX) { f[M] = -1; } return f[M]; } }; 计数型动态规划 Lintcode 114 Unique Paths DP组成部分一：确定状态 最后一步：无论机器人用何种方式到达右下角，总有最后挪动的一步：\n向右 或者 向下 右下角坐标设为(m - 1, n - 1)\n那么前一步（倒数第二步）一定是在(m - 2, n - 1)或者(m - 1, n - 2)\n子问题：那么，如果机器人有X种方式从左上角走到(m - 2, n - 1)，有Y种方式从左上角走到(m - 1, n - 2)，则机器人有X + Y种方式走到(m - 1, n - 1)\n求总方式数的计数型动态规划经常用到加法原理: 无重复\u0026amp;无遗漏 问题转化为，机器人有多少种方式从左上角走到(m - 2, n - 1)和(m - 1, n - 2)\n原题要求有多少种方式从左上角走到(m - 1, n - 1)\n子问题\n状态：设f[i][j]为机器人有多少种方式从左上角走到(i, j)\nDP组成部分二：转移方程 对于任意一个格子(i, j), $f[i][j] = f[i - 1][j] + f[i][j - 1]$ f[i][j] f[i - 1][j] f[i][j - 1] 机器人有多少种方式走到(i, j) 机器人有多少种方式走到(i - 1, j) 机器人有多少种方式走到(i, j - 1) DP组成部分三：初始条件和边界情况 初始条件：f[0][0] = 1，因为机器人只有一种方式到左上角 边界情况：i = 0或j = 0，则前一步只能有一个方向过来 \u0026ndash;\u0026gt; f[i][j] = 1 即第一行和第一列都是1 DP组成部分四：计算顺序 f[0][0] = 1 计算第0行：f[0][0], f[0][1], ..., f[0][n - 1] 计算第1行：f[1][0], f[1][1], ..., f[1][n - 1] \u0026hellip; 计算第m-1行：f[m - 1][0], f[m - 1][1], ..., f[m - 1][n - 1] 顺序的定义，不是为写for循环，而是为了转移方程，f[i][j]要用到f[i - 1][j]和f[i][j - 1] 答案是f[m - 1][n - 1] 时间复杂度（计算步数）：O(MN), 空间复杂度（数组大小）：O(MN) Coding class Solution { public: int uniquePaths(int m, int n) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(m, std::vector\u0026lt;int\u0026gt;(n)); int i, j; for (i = 0; i \u0026lt; m; ++i) { // row: top to bottom for (j = 0; j \u0026lt; n; ++j) { // column: left to right if (i == 0 || j == 0) { f[i][j] = 1; } else { f[i][j] = f[i - 1][j] + f[i][j - 1]; } } } return f[m - 1][n - 1]; } }; 存在型动态规划 Lintcode 116 Jump Game DP组成部分一：确定状态 最后一步：如果🐸能跳到最后一块石头n - 1，我们考虑它跳的最后一步\n这一步是从(n - 1之前的)石头i跳过来，i \u0026lt; n - 1\n这需要两个条件同时满足：\n🐸可以跳到石头i(青蛙可以跳到i) 最后一步不超过跳跃的最大距离(i和n - 1的距离不能超过a_i)(即青蛙可以从i跳过来)：n - 1 - i \u0026lt;= a_i 子问题：那么我们需要知道青蛙能不能跳到石头i (i \u0026lt; n - 1)\n而我们原来要求青蛙能不能跳到石头n - 1\n子问题\n状态：设f[j]表示青蛙能不能跳到石头j\nDP组成部分二：转移方程 设f[j]表示青蛙能不能跳到石头j, $f[j] = OR_{0 \u0026lt;= i \u0026lt; j}(f[i]\\ AND\\ i + a[i] \u0026gt;= j)$ f[j] 青蛙能不能跳到石头j OR_{0\u0026lt;=i\u0026lt;j} 枚举上一个跳到的石头(编号)i f[i] 青蛙能不能跳到石头i i + a[i] \u0026gt;= j 最后一步的距离不能超过$a_i$ DP组成部分三：初始条件和边界情况 设f[j]表示青蛙能不能跳到石头j 初始条件：f[0] = true，因为青蛙一开始就在石头0 这道题没有边界情况，因为枚举的i不会越界 DP组成部分四：计算顺序 设f[j]表示青蛙能不能跳到石头j $f[j] = OR_{0 \u0026lt;= i \u0026lt; j}(f[i]\\ AND\\ i + a[i] \u0026gt;= j)$ 初始化f[0] = true 计算f[1], f[2], ..., f[n - 1] 答案是f[n - 1] 时间复杂度：O(N^2)，空间复杂度（数组大小）：O(N) Coding class Solution { public: bool canJump(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(); std::vector\u0026lt;bool\u0026gt; f(n); f[0] = true; // initialization for (int j = 1; j \u0026lt; n; ++j) { f[j] = false; // previous stone i // last jump is from i to j for (int i = 0; i \u0026lt; j; ++i) { if (f[i] \u0026amp;\u0026amp; i + A[i] \u0026gt;= j) { f[j] = true; break; } } } return f[n - 1]; } }; In summary 四个组成部分： 确定状态：确定要开的数组的意义定下来：\n研究最优策略的最后一步 化为子问题（把公共的汉字抽出来，有几个变量就是几维数组） 转移方程\n根据子问题定义直接得到 初始条件和边界情况\n细心，考虑周全（验证初值对不对，f[3]或f[4]的正确性）（边界情况数组不能越界） 计算顺序\n根本原理：利用之前的计算结果（大部分都是从小到达，二维的话就是从上到下然后从左到右） Exercise1: 金字塔 $dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + array[i][j]$\nExercise2: 乘积最大子序列 Lintcode 191 Maximum Product Subarray\nMaximum Product Subarray\n因为负数乘法的原因，需要记录到每个位置为止最大和最小的乘积\n状态：设f[j] =以a[j]结尾的连续子序列的最大乘积，设g[j] = 以a[j]结尾的连续子序列的最小乘积\nf[j] = max{a[j], max{a[j] * f[j - 1], a[j] * g[j - 1]} | j \u0026gt; 0}\ng[j] = min{a[j], min{a[j] * f[j - 1], a[j] * g[j - 1]} | j \u0026gt; 0}\nChapter 2: 动态规划初探 + 坐标型动态规划 + 位操作型动态规划 初探 坐标型动态规划 Lintcode 115 Unique Paths II 题目分析 最后一步一定是从左边(i, j - 1)或上边(i - 1, j)过来 状态f[i][j]表示从左上角有多少种方式走到格子(i, j) 坐标型动态规划：数组下标[i][j]即坐标(i, j) 开的数组不需要加1 f[i][j] = f[i - 1][j] + f[i][j - 1] 初始条件和边界情况 f[i][j] = 机器人有多少种方式从左上角走到(i, j) 如果左上角(0, 0)格或者右下角(m - 1, n - 1)格有障碍，直接输出0 如果(i, j)格有障碍，f[i][j] = 0，表示机器人不能到达此格(0种方式) 初始条件：f[0][0] = 1，f[i][j] = ： 0, 如果(i, j)格有障碍 1, i == 0 \u0026amp;\u0026amp; j == 0 f[i - 1][j], 如果j == 0，即第一列 f[i][j - 1], 如果i == 0，即第一行 f[i - 1][j] + f[i][j - 1]，其他 Coding class Solution { public: int uniquePathsWithObstacles(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A) { if (A.size() == 0 || A[0].size() == 0) { return 0; } int m = A.size(); int n = A[0].size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(m, std::vector\u0026lt;int\u0026gt;(n)); int i, j; for (i = 0; i \u0026lt; m; ++i) { for (j = 0; j \u0026lt; n; ++j) { if (A[i][j] == 1) { //obstacle f[i][j] = 0; continue; } if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = 1; continue; } f[i][j] = 0; // if it is not on 0-th row if (i \u0026gt; 0) { f[i][j] += f[i - 1][j]; } // if it is not on 0-th column if (j \u0026gt; 0) { f[i][j] += f[i][j - 1]; } } } return f[m - 1][n - 1]; } }; 初探 序列型动态规划 Lintcode 515 Paint House\n动态规划里，如果你需要知道一个信息，而状态无法体现这个信息，就把这个信息记录下来\n序列型特点：状态里出现了前这个字\n序列型f[i]代表前i个：0, 1, 2, ..., i - 1\n相较于坐标型：在开初始状态与转移方程的时候序列型有很好的作用 坐标型f[i]代表到i为止：0, 1, 2, ..., i\n动态规划组成部分一：确定状态 最优策略是花费最小的策略 最后一步：最优策略中房子N - 1一定染成了 红、蓝、绿 中的一种 但是相邻两栋房子不能漆成一种颜色 所成如果最优策略中房子N - 1是红色，房子N - 2只能是蓝色或绿色 所成如果最优策略中房子N - 1是蓝色，房子N - 2只能是红色或绿色 所成如果最优策略中房子N - 1是绿色，房子N - 2只能是红色或蓝色 !!!太复杂，如何优化：\n如果直接套用以前的思路，记录油漆前N栋房子的最小花费 根据套路，也需要记录油漆前N - 1栋房子的最小花费 但是，前N - 1栋房子的最小花费的最优策略中，不知道房子N - 2是什么颜色，所以有可能和房子N - 1撞色 !!!错误，正确做法：\n不知道房子N - 2是什么颜色，就把它记录下来 方法：放到状态里 分别记录油漆前N - 1栋房子并且房子N - 2是红色、蓝色、绿色的最小花费 子问题 求油漆前N栋房子并且房子N - 1是红色、蓝色、绿色的最小花费 需要知道油漆前N - 1栋房子并且房子N - 2是红色、蓝色、绿色的最小花费 子问题 状态：设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] f = new int[n + 1][3] 动态规划组成部分二：转移方程 设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] f[i][0] = min{f[i - 1][1] + cost[i - 1][0], f[i - 1][2] + cost[i - 1][0]} f[i][1] = min{f[i - 1][0] + cost[i - 1][1], f[i - 1][2] + cost[i - 1][1]} f[i][2] = min{f[i - 1][0] + cost[i - 1][2], f[i - 1][1] + cost[i - 1][2]} 动态规划组成部分三：初始条件和边界情况 设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] 初始条件：f[0][0] = f[0][1] = f[0][2] = 0 即不油漆任何房子的花费 无边界情况 动态规划组成部分四：计算顺序 设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] 初始化f[0][0], f[0][1], f[0][2] 计算f[1][0], f[1][1], f[1][2] \u0026hellip; 计算f[N][0], f[N][1], f[N][2] 答案是min{f[N][0], f[N][1], f[N][2]}时间复杂度O(N)，空间复杂度O(N) Coding // Version 1 class Solution { public: int minCost(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { int n = costs.size(); if (n == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;int\u0026gt;(3)); // seq-type f[0][0] = f[0][1] = f[0][2] = 0; // initialization // first i houses 前i栋 for (int i = 1; i \u0026lt;= n; ++i) { // house i - 1\u0026#39;s color is j for (int j = 0; j \u0026lt; 3; ++j) { f[i][j] = 0x3f3f3f3f; // house i - 2\u0026#39;s color is k for (int k = 0; k \u0026lt; 3; ++k) { if (j == k) { continue; } f[i][j] = std::min(f[i][j], f[i - 1][k] + costs[i - 1][j]); } } } return std::min(f[n][0], std::min(f[n][1], f[n][2])); } }; // Version 2 class Solution { public: int minCost(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { int n = costs.size(); if (n == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;int\u0026gt;(3)); // seq-type f[0][0] = f[0][1] = f[0][2] = 0; // initialization // first i houses for (int i = 1; i \u0026lt;= n; ++i) { f[i][0] = std::min(f[i - 1][1] + costs[i - 1][0], f[i - 1][2] + costs[i - 1][0]); f[i][1] = std::min(f[i - 1][0] + costs[i - 1][1], f[i - 1][2] + costs[i - 1][1]); f[i][2] = std::min(f[i - 1][0] + costs[i - 1][2], f[i - 1][1] + costs[i - 1][2]); } return std::min(f[n][0], std::min(f[n][1], f[n][2])); } }; In summary: seq-type 序列型动态规划：\u0026hellip;前i个\u0026hellip;最小/方式数/可行性 f[i] 代表前i个：f[0], f[1], ..., f[i - 1] 在设计动态规划的过程中，发现需要知道油漆前N - 1栋房子的最优策略中，房子N - 2的颜色 如果只用f[N - 1]，将无法区分 解决方法：记录下房子N - 2的颜色 在房子N - 2是 红/蓝/绿 色的情况下，油漆前N - 1栋房子的最小花费 问题迎刃而解 序列+状态 初探 划分型动态规划 Lintcode 512 Decode Ways 动态规划组成部分一：确定状态 解密数字串即划分成若干段数字，每段数字对应一个字母 最后一步（最后一段）：对应一个字母 A, B, \u0026hellip;, Z 这个字母加密时变成1, 2, \u0026hellip;, 26 子问题 设数字串长度为N 要求数字串前N个字符的解密方式数 需要知道数字串前N - 1和N - 2个字符的解密方式数 子问题 状态：设数字串S前i个数字解密成字母串有f[i]种方式 动态规划组成部分二：转移方程 设数字串S前i个数字解密成字母串有f[i]种方式 f[i] = f[i - 1] | S[i - 1]对应一个字母 + f[i - 2] | S[i - 2]S[i - 1]对应一个字母 f[i]: 数字串S前i个数字解密成字母串的方式数 f[i - 1] | S[i - 1]对应一个字母: 数字串S前i - 1个数字解密成字母串的方式数 f[i - 2] | S[i - 2]S[i - 1]对应一个字母: 数字串S前i - 2个数字解密成字母串的方式数 动态规划组成部分三：初始条件和边界情况 设数字串S前i个数字解密成字母串有f[i]种方式\n初始条件：f[0] = 1，即空串有1种方式解密\n解密成空串 边界情况：如果i = 1，只看最后一个数字\n动态规划组成部分四：计算顺序 f[0], f[1], ..., f[N] 答案是f[N] 时间复杂度O(N)，空间复杂度O(N) Coding class Solution { public: int numDecodings(std::string\u0026amp; s) { int n = s.size(); if (n == 0) { return 0; } std::vector\u0026lt;int\u0026gt; f(n + 1, 0); int i; f[0] = 1; // initialization; 当物理意义不明确的时候，推断当前的初始化是否能得到正确的结果 // first i digits: s[0], ..., s[i - 1] for (i = 1; i \u0026lt;= n; ++i) { f[i] = 0; // last one digit --\u0026gt; letter if (s[i - 1] != \u0026#39;0\u0026#39;) { f[i] += f[i - 1]; } // last two digits --\u0026gt; letter // s[i - 2]s[i - 1] if (i \u0026gt;= 2 \u0026amp;\u0026amp; (s[i - 2] == \u0026#39;1\u0026#39; || (s[i - 2] == \u0026#39;2\u0026#39; \u0026amp;\u0026amp; s[i - 1] \u0026lt;= \u0026#39;6\u0026#39;))) { f[i] += f[i - 2]; } } return f[n]; } }; 坐标型动态规划：最小路径和 Lintcode 110 Minimum Path Sum // Mine correct version class Solution { public: int minPathSum(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n, std::vector\u0026lt;int\u0026gt;(m)); f[0][0] = grid[0][0]; for (int i = 1; i \u0026lt; m; ++i) { f[0][i] = f[0][i - 1] + grid[0][i]; } for (int i = 1; i \u0026lt; n; ++i) { f[i][0] = f[i - 1][0] + grid[i][0]; } for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt; m; ++j) { f[i][j] = std::min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; } } return f[n - 1][m - 1]; } }; // Official correct version class Solution { public: int minPathSum(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n, std::vector\u0026lt;int\u0026gt;(m)); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = grid[i][j]; continue; } f[i][j] = INT_MAX; // if it has a grid above if (i \u0026gt; 0) { f[i][j] = std::min(f[i][j], f[i - 1][j] + grid[i][j]); } // if it has a grid to the left if (j \u0026gt; 0) { f[i][j] = std::min(f[i][j], f[i][j - 1] + grid[i][j]); } } } return f[n - 1][m - 1]; } }; 坐标型动态规划：最小路径和\u0026ndash;路径打印 最值和可行性都可以打印方案，但存在数不行 class Solution { public: int minPathSum(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n, std::vector\u0026lt;int\u0026gt;(m)); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; pi(n, std::vector\u0026lt;int\u0026gt;(m)); // if f[i][j] depends on f[i - 1][j], pi[i][j] = 0 // if f[i][j] depends on f[i][j - 1], pi[i][j] = 1 for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = grid[i][j]; continue; } f[i][j] = INT_MAX; // if it has a grid above if (i \u0026gt; 0) { f[i][j] = std::min(f[i][j], f[i - 1][j] + grid[i][j]); if (f[i][j] == f[i - 1][j] + grid[i][j]) { pi[i][j] = 0; } } // if it has a grid to the left if (j \u0026gt; 0) { f[i][j] = std::min(f[i][j], f[i][j - 1] + grid[i][j]); if (f[i][j] == f[i][j - 1] + grid[i][j]) { pi[i][j] = 1; } } } } // (n - 1, m - 1) std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; path(n + m - 1, std::vector\u0026lt;int\u0026gt;(2)); int p; int i = n - 1; int j = m - 1; // infer the path backward from (n - 1, m - 1) for (p = n + m - 2; p \u0026gt;= 0; --p) { path[p][0] = i; path[p][1] = j; if (p == 0) { break; } if (pi[i][j] == 0) { --i; } else { --j; } } for (p = 0; p \u0026lt; n + m - 1; ++p) { std::cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; path[p][0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; path[p][1] \u0026lt;\u0026lt; \u0026#34;): \u0026#34; \u0026lt;\u0026lt; grid[path[p][0]][path[p][1]] \u0026lt;\u0026lt; std::endl; } return f[n - 1][m - 1]; } }; # expected result from the test case: [[1,5,7,6,8],[4,7,4,4,9],[10,3,2,3,2]] (0, 0): 1 (1, 0): 4 (1, 1): 7 (2, 1): 3 (2, 2): 2 (2, 3): 3 (2, 4): 2 坐标型动态规划：最小路径和\u0026ndash;空间优化 f[i][j] = std::min{f[i - 1][j], f[i][j - 1]} + A[i][j] 计算第i行时，只需要第i行和第i - 1行的f 所以，只需要保存两行的f值：f[i][0 ... n - 1]和f[i - 1][0 ... n - 1] 用滚动数组实现 开数组时，只开f[0][0 ... n - 1]和f[1][0 ... n - 1] 计算f[0][0], ..., f[0][n - 1]，计算f[1][0], ..., f[1][n - 1] 计算f[2][0 ... n - 1]时，开f[2][0 ... n - 1]，删掉f[0][0 ... n - 1]，因为已经不需要f[0][0 ... n - 1]的值了 计算f[3][0 ... n - 1]时，开f[3][0 ... n - 1]，删掉f[1][0 ... n - 1]，因为已经不需要f[1][0 ... n - 1]的值了 实际操作时，可以不用每次开数组，而是用滚动法 计算f[0][0], ..., f[0][n - 1]，计算f[1][0], ..., f[1][n - 1] 计算f[2][0 ... n - 1]时，把值写在f[0][0 ... n - 1]的数组里 同理，f[3][0 ... n - 1]写在f[1][0 ... n - 1]的数组里 最后f[m - 1][n - 1]存储在f[0][n - 1]（或者f[1][n - 1]）里，直接输出 对于网格上的动态规划，如果f[i][j]只依赖于本行的f[i][x]与前一行的f[i - 1][y]，那么就可以采用滚动数组的方法压缩空间。空间复杂度O(n)\n如果网格行数少列数多（大胖子网格），那么就可以逐列计算，滚动数组的长度为行数，空间复杂度O(M)\nclass Solution { public: int minPathSum(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(2, std::vector\u0026lt;int\u0026gt;(m)); int old, now = 0; // old: f[old][...] is holding f[i - 1][...] // now: f[now][...] is holding f[i][...] for (int i = 0; i \u0026lt; n; ++i) { // swap old and now old = now; now = 1 - now; // 0--\u0026gt;1, 1--\u0026gt;0 // 将所有的 f[i] 变成 f[now]； f[i - 1] 变成 f[old] for (int j = 0; j \u0026lt; m; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[now][j] = grid[i][j]; continue; } f[now][j] = INT_MAX; // if it has a grid above if (i \u0026gt; 0) { f[now][j] = std::min(f[now][j], f[old][j] + grid[i][j]); } // if it has a grid to the left if (j \u0026gt; 0) { f[now][j] = std::min(f[now][j], f[now][j - 1] + grid[i][j]); } } } return f[now][m - 1]; } }; 取模运算(%) 会比这个稍微慢一些\n坐标型动态规划：炸弹袭击 Lintcode 553 Bomb Enemy 动态规划组成部分一：确定状态 我们假设有敌人或有墙的格子也能放炸弹 有敌人的格子：格子里的敌人被炸死，并继续向上爆炸 有墙的格子：炸弹不能炸死任何敌人 在(i, j)格放一个炸弹，它向上能炸死的敌人数是： (i, j)格为空地：(i - 1, j)格向上能炸死的敌人数 (i, j)格为敌人：(i - 1, j)格向上能炸死的敌人数 + 1 (i, j)格为墙：0 子问题 需要知道(i - 1, j)格放一个炸弹向上能炸死的敌人数 原来要求(i, j)格放一个炸弹向上能炸死的敌人数 子问题 状态： Up[i][j]表示(i, j)格放一个炸弹向上能炸死的敌人数 动态规划组成部分二：转移方程 设Up[i][j]表示(i, j)格放一个炸弹向上能炸死的敌人数 Up[i][j]: Up[i - 1][j]，如果(i, j)格是空地 Up[i - 1][j] + 1，如果(i, j)格是敌人 0，如果(i, j)格是墙 动态规划组成部分三：初始条件和边界情况 设Up[i][j]表示(i, j)格放一个炸弹向上能炸死的敌人数\n初始条件： 第0行的Up值和格子内容相关\nUp[0][j] = 0，如果(0, j)格不是敌人 Up[0][j] = 1，如果(0, j)格是敌人 动态规划组成部分四：计算顺序 逐行计算 Up[0][0], Up[0][1], ..., Up[0][n - 1] Up[1][0], Up[1][1], ..., Up[1][n - 1] \u0026hellip; Up[m - 1][0], Up[m - 1][1], ..., Up[m - 1][n - 1] 时间复杂度O(MN)，空间复杂度O(MN) 四个方向 Up[i][j]表示如果(i, j)放一个炸弹向上可以最多炸死多少敌人 一共四个方向 可以类似地计算Down[i][j], Left[i][j], Right[i][j]，注意计算顺序会有改变 (i, j)如果是空地，放一个炸弹最多炸死的敌人数是： Up[i][j] + Down[i][j] + Left[i][j] + Right[i][j] 取最大值即可 时间复杂度和空间复杂度依然为O(MN) Coding class Solution { public: int maxKilledEnemies(std::vector\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { if (grid.size() == 0 || grid[0].size() == 0) { return 0; } int n = grid.size(); int m = grid[0].size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; up(n, std::vector\u0026lt;int\u0026gt;(m)); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; down(n, std::vector\u0026lt;int\u0026gt;(m)); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; left(n, std::vector\u0026lt;int\u0026gt;(m)); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; right(n, std::vector\u0026lt;int\u0026gt;(m)); // up for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { up[i][j] = 0; if (grid[i][j] != \u0026#39;W\u0026#39;) { if (grid[i][j] == \u0026#39;E\u0026#39;) { ++up[i][j]; } if (i \u0026gt; 0) { up[i][j] += up[i - 1][j]; } } } } // down for (int i = n - 1; i \u0026gt;= 0; --i) { for (int j = 0; j \u0026lt; m; ++j) { down[i][j] = 0; if (grid[i][j] != \u0026#39;W\u0026#39;) { if (grid[i][j] == \u0026#39;E\u0026#39;) { ++down[i][j]; } if (i \u0026lt; n - 1) { down[i][j] += down[i + 1][j]; } } } } // left for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { left[i][j] = 0; if (grid[i][j] != \u0026#39;W\u0026#39;) { if (grid[i][j] == \u0026#39;E\u0026#39;) { ++left[i][j]; } if (j \u0026gt; 0) { left[i][j] += left[i][j - 1]; } } } } // right for (int i = 0; i \u0026lt; n; ++i) { for (int j = m - 1; j \u0026gt;= 0; --j) { right[i][j] = 0; if (grid[i][j] != \u0026#39;W\u0026#39;) { if (grid[i][j] == \u0026#39;E\u0026#39;) { ++right[i][j]; } if (j \u0026lt; m - 1) { right[i][j] += right[i][j + 1]; } } } } int result = 0; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { if (grid[i][j] == \u0026#39;0\u0026#39;) { // empty result = std::max(result, up[i][j] + down[i][j] + left[i][j] + right[i][j]); } } } return result; } }; 坐标型动态规划 总结 给定输入为序列或者网格/矩阵 动态规划状态下标为序列下标i或者网格坐标(i, j) f[i]：以第i个元素结尾的某种性质 f[i][j]：到格子(i, j)的路径的性质 初始化设置f[0]的值 / f[0][0 ... n - 1]的值 二维空间优化：如果f[i][j]的值只依赖于当前行和前一行，则可以用滚动数组节省空间 位操作型动态规划：Counting Bits 位操作（二进制） \u0026amp;与，|或，^异或，!非 逐位操作 Lintcode 664 Counting Bits 题目分析 对于每个数0 \u0026lt;= i \u0026lt;= N，直接求i的二进制表示里有多少个1 二进制表示算法：（十进制转二进制算法） 第一步：i mod 2是最低位的bit 第二步：i \u0026lt;- floor(i / 2)，如果i = 0，结束，否则回到第一步 时间复杂度：O(NlogN) 2个数有1位二进制(0 and 1) 2个数有2位二进制(2 and 3) 4个数有3位二进制(3, 4, 5 and 6) 8个数有4位二进制(7, 8, 9, 10, 11, 12, 13 and 14) \u0026hellip; 大约N / 2个数有log{2}N位二进制 用动态规划的话会比上面快一些 动态规划组成部分一：确定状态 观察一个数的二进制位\n$(170)_{10} = (10101010)_2$ 最后一步：观察这个数最后一个二进制位（最低位），去掉它，看剩下多少个1\n$(170)_{10} = (10101010)_2$ $(85)_{10} = (1010101)_2$ 85 的二进制表示里有4个1 170 的二进制表示里有4个1 子问题 要求N的二进制表示中有多少1 在N的二进制去掉最后一位N mod 2（有两种方法：\u0026raquo; and floor(/)），设新的数是Y = (N \u0026gt;\u0026gt; 1)（右移一位） 要知道Y的二进制表示中有多少1 子问题 状态：设f[i]表示i的二进制表示中有多少个1 知识点：和位操作相关的动态规划一般用值作状态\n动态规划组成部分二：转移方程 设f[i]表示i的二进制表示中有多少个1\nf[i] = f[i \u0026gt;\u0026gt; 1] + (i mod 2)\n动态规划组成部分三：初始条件和边界情况 设f[i]表示i的二进制表示中有多少个1\nf[i] = f[i \u0026gt;\u0026gt; 1] + (i mod 2)\n初始条件：f[0] = 0\n动态规划组成部分四：计算顺序 f[0], f[1], f[2], ..., f[N] 时间复杂度O(N) 空间复杂度O(N) Coding class Solution { public: std::vector\u0026lt;int\u0026gt; countBits(int num) { std::vector\u0026lt;int\u0026gt; f(num + 1); f[0] = 0; for (int i = 1; i \u0026lt;= num; ++i) { f[i] = f[i \u0026gt;\u0026gt; 1] + (i % 2); } return f; } }; Exercise: 最长上升子序列 Lintcode Longest Increasing Continuous Subsequence class Solution { public: int longestIncreasingContinuousSubsequence(std::vector\u0026lt;int\u0026gt;\u0026amp; a) { } }; Chapter 3: 打劫房屋: 坐标型，前缀型 Lintcode 392 打劫房屋 坐标型 dp[坐标] = 行走到这个坐标的最优值\n转移：上一个坐标从哪里来，比如：上一次打劫了哪个房屋，或上一次行走了那个坐标\n动态规划 由抢房屋的性质可以看出，抢前i个房屋能得到的最大值，与后面如何抢的方案无关，只与前i - 1个房屋的最优方案有关。这满足了动态规划的无后效性和最优子结构 同时，由于题目不能抢相邻房屋，那么如果抢了第i个房屋，就不能抢第i - 1个房屋，可以得出前i个的最优方案也与前i - 2个的最优方案有关 代码思路 将要不要打劫的这个决策，记录到状态当中去(每走到一个坐标(房子)，都有两种情况:打劫/不打劫):\n可以设dp[i][0]为如果不抢第i个房屋，前i个房屋的最优方案为多少 设dp[i][1]为如果抢第i个房屋，前i个房屋的最优方案为多少 可以得出一下的状态转移方程式： $dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])$ 因为如果不打劫当前的房子，从前一个位置选择一个最大值 $dp[i][1] = A[i] + dp[i - 1][0]$ 因为如果打劫当前的房子，之前的房子只能选择不打劫 class Solution { public: long long houseRobber(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(); if (n == 0) { return 0; } std::vector\u0026lt;std::vector\u0026lt;long long\u0026gt;\u0026gt; dp(n, std::vector\u0026lt;long long\u0026gt;(2, 0)); dp[0][0] = 0; dp[0][1] = A[0]; for (int i = 1; i \u0026lt; n; ++i) { // 如果不抢第i个，取前i - 1个位置dp较大值 dp[i][0] = std::max(dp[i - 1][0], dp[i - 1][1]); // 如果抢第i个，前一个不抢，考虑从前i - 2个位置的dp值转移，即i - 1选择不打劫 dp[i][1] = A[i] + dp[i - 1][0]; } long long result = std::max(dp[n - 1][0], dp[n - 1][1]); return result; } }; from typing import ( List, ) class Solution: def house_robber(self, a: List[int]) -\u0026gt; int: 前缀型 坐标型关心走到哪儿，前缀型不关心\n前缀型永远是用前缀来表示子状态: 看前i个数怎样怎样，和前j个数或前i - 1个数的怎样怎样，之间的关系\n$$\\begin{align} dp[i] \u0026amp;= 前`i`个数取出的最大和(不关心第`i`个取或者不取) \\\\ \u0026amp;= max(dp[i - 2] \u0026#43; a[i], dp[i - 1]) 以此来避免取相邻的两个房子 \\\\ 优化：dp[i \\% 3] \u0026amp;= 前`i`个数取出的最大和(不关心第`i`个取或者不取) \\\\ \u0026amp;= max(dp[(i - 2) \\% 3] \u0026#43; a[i], dp[(i - 1) \\% 3]) 以此来避免取相邻的两个房子 \\end{align}$$ Chapter 4: 最大矩形 \u0026amp;\u0026amp; 最大直方图：坐标型 单调栈：求一个位置往左看或者往右看，第一个小于等于它的数的时候，用单调栈\n最大矩形 Lintcode 510 最大矩形\n这题和Lintcode 122 直方图最大矩形覆盖很相似，只需要求出以每一行作为底最大的矩形是多少，每一行都有一个height数组，利用单调栈，每次更新height数组，height数组代表的是这一列上面有多少个连续的1，即矩形的高度，以每一行作为底（直方图最下面）时最大矩形面积，然后记录最大值即可。\n初始化dp数组，用dp数组记录当前位置上方有多少个连续1。对于每一行作为底，利用单调栈求高度，寻找最大的底乘高。\n注意这个栈是 从栈底到栈顶依次是从小到大的。如果栈中的数比当前的数大（或着等于）就要处理栈顶的（记录左右两边的比它小的第一个数）。\n然后如果遍历完之后，单独处理栈，此时所有元素右边都不存在比它小的height[j]表示目前的底上（第1行），j位置往上（包括j位置）有多少连续的1。\n不断更新最大面积。\n时间复杂度O(mn): dp的O(nm)和单调栈的O(n) 空间复杂度O(mn): dp的大小（下面的代码的空间复杂度可以优化成O(n)） class Solution { public: int maximalRectangle(std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return 0; } int ans = 0; int n = matrix.size(); int m = matrix[0].size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n, std::vector\u0026lt;int\u0026gt;(m + 1)); for (int i = 0; i \u0026lt; n; ++i) { // 每个位置上方有多少连续的1 for (int j = 0; j \u0026lt; m; ++j) { if (i == 0 \u0026amp;\u0026amp; matrix[i][j]) { dp[i][j] = 1; continue; } if (matrix[i][j]) { dp[i][j] = dp[i - 1][j] + 1; } } } for (int i = 0; i \u0026lt; n; ++i) { // 把每一行作为底找最大矩形 ans = std::max(ans, largestRectangleArea(dp[i])); } return ans; } private: int largestRectangleArea(std::vector\u0026lt;int\u0026gt;\u0026amp; heights) { std::deque\u0026lt;int\u0026gt; S; heights[heights.size() - 1] = 0; int sum = 0; for (int i = 0; i \u0026lt; heights.size(); ++i) { if (S.empty() || heights[i] \u0026gt; heights[S.back()]) { S.push_back(i); } else { int temp = S.back(); S.pop_back(); sum = std::max(sum, heights[temp] * (S.empty() ? i : i - S.back() - 1)); --i; // 拿着右边界，寻找左边界 } } return sum; } }; 直方图最大矩形覆盖 Lintcode 122 直方图最大矩形覆盖 // LHC version: Monotonic-stack answer class Solution { public: int largestRectangleArea(std::vector\u0026lt;int\u0026gt;\u0026amp; height) { std::deque\u0026lt;int\u0026gt; S; std::vector\u0026lt;int\u0026gt; heights = height; heights.push_back(-1); int sum = 0; for (int i = 0; i \u0026lt; heights.size(); ++i) { if (S.empty() || heights[i] \u0026gt; heights[S.back()]) { S.push_back(i); } else { int temp = S.back(); S.pop_back(); sum = std::max(sum, heights[temp] * (S.empty() ? i : i - S.back() - 1)); --i; // 拿着右边界，寻找左边界 } } return sum; } }; // Correct Monotonic-stack answer from other students class Solution { public: int largestRectangleArea(std::vector\u0026lt;int\u0026gt;\u0026amp; heights) { if (heights.size() == 0) { return 0; } std::deque\u0026lt;int\u0026gt; stack; int sum = 0; for (int i = 0; i \u0026lt;= heights.size(); ++i) { int curt = (i == heights.size()) ? -1 : heights[i]; while (!stack.empty() \u0026amp;\u0026amp; curt \u0026lt;= heights[stack.back()]) { int h = heights[stack.back()]; stack.pop_back(); int w = stack.empty() ? i : i - stack.back() - 1; sum = std::max(sum, h * w); } stack.push_back(i); } return sum; } }; ","chapter-5-最短假期坐标型#Chapter 5: 最短假期：坐标型":" Lintcode 267 最短假期\n转移方程：\n如果今天工作（运动），那么只能由昨天运动（工作）或休息转移而来 如果今天休息，那么可以由昨天三种状态（工作，运动，休息）转移 状态：dp[i][j]第i天干了j这个事情(j: 工作，健身，休息) 的最小休息天数\ndp[i][0], dp[i][1], dp[i][2]分别表示去公司工作、去健身房锻炼、去休息 状态转移方程： dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + 1 设假期天数为n 时间复杂度：从左至右扫描数组，每次由三个DP方程进行转移。时间复杂度为O(n) 空间复杂度：DP数组规模为3*n。空间复杂度O(n) class Solution { public: int minimumRestDays(std::vector\u0026lt;int\u0026gt;\u0026amp; company, std::vector\u0026lt;int\u0026gt;\u0026amp; gym) { int n = company.size(); // dp[i][0]表示第i天工作的最小休息天数，dp[i][1]表示锻炼，dp[i][2]表示休息 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n, std::vector\u0026lt;int\u0026gt;(3)); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; 3; ++j) { dp[i][j] = 0x3f3f3f3f; } } // 临界值第一天 dp[0][0] = dp[0][1] = 0; if (company[0] == 0) { dp[0][0] = 1; } if (gym[0] == 0) { dp[0][1] = 1; } dp[0][2] = 1; for (int i = 1; i \u0026lt; n; ++i) { if (company[i] == 1) { dp[i][0] = std::min(dp[i - 1][1], dp[i - 1][2]); } if (gym[i] == 1) { dp[i][1] = std::min(dp[i - 1][0], dp[i - 1][2]); } dp[i][2] = std::min(dp[i - 1][0], std::min(dp[i - 1][1], dp[i - 1][2])) + 1; } return std::min(dp[n - 1][0], std::min(dp[n - 1][1], dp[n - 1][2])); } }; Exercise: 相关题目 Lintcode 151 买卖股票的最佳时机III\nLintcode 515 房屋染色\n","chapter-6-最小调整代价背包型#Chapter 6: 最小调整代价：背包型":" Lintcode 91 最小调整代价 Solution 状态 令dp[i][j]表示从左到右调整到前i个数时，将第i个数的数值调整为j所需要付出的最小代价。 整个调整的过程中要满足相邻两数之差不超过target\n转移方程 dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - A[i])) k是把第i - 1个数调整为k k和j差值不超过target j - target \u0026lt;= k \u0026lt;= j + target 思路 已知每个整数范围[1,100]，那么对于每个元素，为了调整到该元素和与之相邻的元素的差不大于target，该元素调整的范围就在[1,100]。所以对于数组A[]的每一位元素，我们都需要进行[1,100]范围内的可能状态的转移。\n令dp[i][j]表示元素A[i]=j时，A[i]与A[i-1]差值不大于target所需要付出的最小代价。\n当A[i]=j时，可行的A[i-1]的范围为[max(1, j - target)，min(100, j + target)]。而dp[i][j]为所有可行的A[i-1]中，花费代价最小的一种可能，再加上A[i]调整到 j 所需花费abs(j - A[i])。\n当A[i]=j时，k在[max(1, j - target)，min(100, j + target)]范围内时，我们可以写出以下式子：\n1.临界值： dp[0][j] = abs(j - A[0])\n2.状态转移方程： dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - A[i])) 最后在所有最后一位的可能解dp[n-1][i]中的最小值，就是我们所求的最小代价。 假设数组长度为n 空间复杂度O(10000*n) 时间复杂度O(n^2) Coding class Solution { public: int minAdjustmentCost(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int target) { int n = A.size(); // dp[i][j]表示元素A[i]=j时，A[i]与A[i-1]差值不大于target所需要付出的最小代价 int dp[n][101]; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= 100; ++j) { // 初始化为极大值 dp[i][j] = 0x3f3f3f3f; } } for (int i = 0; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= 100; ++j) { if (i == 0) { // 临界值：第一个元素A[0]调整为j的代价 dp[0][j] = abs(j - A[0]); } else { // left为A[i]=j时，A[i-1]与A[i]差值不大于target的A[i-1]最小值 // right为A[i]=j时，A[i-1]与A[i]差值不大于target的A[i-1]最大值 int left = max(1, j - target); int right = min(100, j + target); for (int k = left; k \u0026lt;= right; ++k) { // 当A[i-1]=k时，答案为A[i-1]=k的代价dp[i-1][k]，加上A[i]=j的调整代价abs(j-A[i]) dp[i][j] = std::min(dp[i][j], dp[i - 1][k] + abs(j - A[i])); } } } } int mincost = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= 100; ++i) { mincost = min(mincost, dp[n - 1][i]); } return mincost; } }; ","chapter-7-香槟塔坐标型#Chapter 7: 香槟塔：坐标型":" Lintcode 1018 香槟塔 状态：dp[i][j]流入多少水，至于剩下多少水是根据流入的量算出来的\nStep 1 : 如何定义状态？ 令dp[i][j]为(i, j)位置的杯子的流入香槟总体积占比\nStep 2 : 临界值是什么？ dp[0][0] = poured 将所有的香槟都倒在顶端 Step 3 : 状态转移方程怎么写？ (i, j)的杯子流入的香槟总体积 = ((i - 1, j - 1)香槟体积 - 1 + (i - 1, j)香槟体积 - 1) / 2.0 状态转移方程为：dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] - 2) / 2.0 Step 4 : DP结果是什么？ min(dp[query_row][query_glass], 1) 这个杯子能装的香槟永远不会超过一杯 class Solution { public: double champagneTower(int poured, int query_row, int query_glass) { double dp[101][101]; dp[0][0] = poured; for (int row = 1; row \u0026lt;= query_row; ++row) { for (int i = 0; i \u0026lt;= row; ++i) { if (i == 0) { dp[row][i] = std::max(0.0, (dp[row - 1][i] - 1) / 2.0); } else if (i == row) { dp[row][i] = std::max(0.0, (dp[row - 1][i - 1] - 1) / 2.0); } else { dp[row][i] = std::max(0.0, (dp[row - 1][i - 1] + dp[row - 1][i] - 2) / 2.0); // here is wrong, we should compare both left and right with the 0 } } } return std::min(dp[query_row][query_glass], 1.0); } }; don\u0026rsquo;t forget to minus one\nthe reason we use std::max there is that to keep volume of each cup to be positive\n空间优化： Soluton 1: row % 2 class Solution { public: double champagneTower(int poured, int query_row, int query_glass) { double dp[2][101]; dp[0][0] = poured; for (int row = 1; row \u0026lt;= query_row; ++row) { for (int i = 0; i \u0026lt;= row; ++i) { if (i == 0) { dp[row % 2][i] = std::max(0.0, (dp[(row - 1) % 2][i] - 1) / 2.0); } else if (i == row) { dp[row % 2][i] = std::max(0.0, (dp[(row - 1) % 2][i - 1] - 1) / 2.0); } else { dp[row % 2][i] = std::max(0.0, (dp[(row - 1) % 2][i - 1] + dp[(row - 1) % 2][i] - 2) / 2.0); // here is wrong, we should compare both left and right with the 0 } } } return std::min(dp[query_row % 2][query_glass], 1.0); } }; Soluton 2: 一维数组 // Solution 2 class Solution { public: double champagneTower(int poured, int query_row, int query_glass) { double dp[101]; dp[0] = poured; for (int row = 1; row \u0026lt;= query_row; ++row) { for (int i = row; i \u0026gt;= 0; --i) { if (i == 0) { dp[i] = std::max(0.0, (dp[i] - 1) / 2.0); } else if (i == row) { dp[i] = std::max(0.0, (dp[i - 1] - 1) / 2.0); } else { dp[i] = std::max(0.0, (dp[i - 1] + dp[i] - 2) / 2.0); // here is wrong, we should compare both left and right with the 0 } } } return std::min(dp[query_glass], 1.0); } }; ","chapter-8-飞行棋i#Chapter 8: 飞行棋I":" Lintcode 1565 飞行棋I\n只能向右走，有方向性所以可以用动态规划\nOther notes: 拓扑排序的一个功能就是检测图里是否有循环依赖 拓扑排序与动态规划的关系： 一个题目能够被动态规划，那么把状态看作点，把状态的依赖关系看作边的话，那所构成的图当中一定可以被拓扑排序 有循环依赖就不能产生拓扑排序，有循环依赖就不能使用动态规划 Step 1 : 如何定义状态？ 令dp[i]表示从位置1到位置i的最小投掷骰子次数 Step 2 : 临界值是什么？ 当位置i 属于 [2, 7]的时候，可以通过投掷一次骰子抵达，即dp[i] = 1。 并且dp[1] = 0 Step 3 : 状态转移方程怎么写？ 如果投掷骰子：dp[i] = min(dp[i], dp[i - j] + 1), j 属于 [1, 6] 当前位置投掷一次骰子所能走到的位置的dp值是当前dp值加一。 如果有另外相连的位置：dp[相连的位置] = min(dp[相连的位置], dp[i])，这里实际上是更新后面的结果 可以不需要投掷骰子直接向前走 Step 4 : DP结果是什么？ 棋盘的长度 length 的 dp 值即为答案: dp[length] DP Solution Time Complexity O(n)\nSpace Complexity O(n)\nclass Solution { public: int modernLudo(int length, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; connections) { if (length == 1) { return 0; } if (length \u0026lt;= 7) { return 1; } // connected[i] = j 表示i与j相连 std::vector\u0026lt;int\u0026gt; connected(length + 1); std::vector\u0026lt;int\u0026gt; dp(length + 1); // initialization for (int i = 1; i \u0026lt;= length; ++i) { connected[i] = i; dp[i] = 0x3f3f3f3f; } dp[1] = 0; for (int i = 0; i \u0026lt; connections.size(); ++i) { connected[connections[i][0]] = connections[i][1]; } for (int i = 2; i \u0026lt;= length; ++i) { if (i - 6 \u0026lt; 1) { dp[i] = 1; } else { for (int j = 1; j \u0026lt;= 6; ++j) { dp[i] = std::min(dp[i], dp[i - j] + 1); } } dp[connected[i]] = std::min(dp[connected[i]], dp[i]); } return dp[length]; } }; ","chapter-9-序列型动态规划#Chapter 9: 序列型动态规划":" 序列型动态规划\u0026ndash;简介 给定一个序列 动态规划方程f[i]中的下标i表示前i个元素a[0], a[1], ..., a[i - 1]的某种性质 坐标型的f[i]表示以a[i]为结尾的某种性质 初始化中，f[0]表示空序列的性质 坐标型动态规划的初始条件f[0]就是指以a_0为结尾的子序列的性质 序列型动态规划\u0026ndash;数字翻转 Lintcode 843 数字翻转 动态规划组成部分一：确定状态 最后一步：最优策略中，最后一位数是否翻转 但需要知道前一位数已经变成0还是1 并且前N - 1位数最少翻转多少次，满足要求（无01子串） 不知道的信息加入状态里 状态 用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 动态规划组成部分二：转移方程 用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 $f[i][j] = min_{(k, j) ≠ (0, 1)}(f[i - 1][k] + 1_{A[i - 1] ≠ j})$ 动态规划组成部分三：初始条件和边界情况 用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 $f[i][j] = min_{(k, j) ≠ (0, 1)}(f[i - 1][k] + 1_{A[i - 1] ≠ j})$ 初始条件： f[0][0] = f[0][1] = 0 动态规划组成部分四：计算顺序 用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 $f[i][j] = min_{(k, j) ≠ (0, 1)}(f[i - 1][k] + 1_{A[i - 1] ≠ j})$ 答案是min(f[N][0], f[N][1]) 算法时间复杂度O(N)，空间复杂度O(N)，可以用滚动数组优化至O(1) Coding Mine Correct Solution class Solution { public: int flipDigit(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt;= 1) { return 0; } int f[n + 1][2]; f[0][0] = 0; f[0][1] = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (nums[i - 1] == 1) { f[i][0] = std::min(f[i - 1][1] + 1, f[i - 1][0] + 1); f[i][1] = f[i - 1][1]; } else { f[i][0] = std::min(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][1] + 1; } } return std::min(f[n][0], f[n][1]); } }; index in nums should minus 1\nI think my solution is better than offical\nOfficial Solution class Solution { public: int flipDigit(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt;= 1) { return 0; } int f[n + 1][2]; f[0][0] = 0; f[0][1] = 0; // first i digits: nums[0, ..., i - 1] for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { f[i][j] = 0x3f3f3f3f; // nums[i - 1]--\u0026gt;j, should I flip? int t = 0; if (nums[i - 1] != j) { t = 1; } // nums[i - 2]--\u0026gt;k for (int k = 0; k \u0026lt; 2; ++k) { if (k == 0 \u0026amp;\u0026amp; j == 1) { continue; } f[i][j] = std::min(f[i][j], f[i - 1][k] + t); } } } return std::min(f[n][0], f[n][1]); } }; 序列型动态规划的时间优化\u0026ndash;房屋染色II Lintcode 516 房屋染色II\n时间优化有三个可以做的事情：\n看式子，并展开(也许会发现里面有重复) 画图 小例子 Mine Correct Answer O(nk^2) class Solution { public: int minCostII(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { if (costs.size() == 0) { return 0; } int n = costs.size(); int m = costs[0].size(); if (n == 1 \u0026amp;\u0026amp; m == 1) { return costs[0][0]; } int dp[n + 1][m]; for (int i = 0; i \u0026lt; m; ++i) { dp[0][i] = 0; } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { dp[i][j] = costs[i - 1][j]; int min_cost = 0x3f3f3f3f; for (int k = 0; k \u0026lt; m; ++k) { if (k == j) { continue; } min_cost = std::min(min_cost, dp[i][j] + dp[i - 1][k]); } dp[i][j] = min_cost; } } int ans = 0x3f3f3f3f; for (int i = 0; i \u0026lt; m; ++i) { ans = std::min(ans, dp[n][i]); } return ans; } }; follow up: can you make it faster?\nMine solution is O(nk^2), how to make it faster\n时间优化 优化方法 记录下最小值f[i - 1][a]和次小值f[i - 1][b] 如果去掉的是最小值，则f[i][a] = f[i - 1][b] + cost[i - 1][a] 如果去掉的不是最小值，则f[i][j] = f[i - 1][a] + cost[i - 1][j] 时间复杂度降为O(nk) Mine correct time optimized solution class Solution { public: int minCostII(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { if (costs.size() == 0) { return 0; } int n = costs.size(); int m = costs[0].size(); if (n == 1 \u0026amp;\u0026amp; m == 1) { return costs[0][0]; } int dp[n + 1][m]; for (int i = 0; i \u0026lt; m; ++i) { dp[0][i] = 0; } // record min and second_minimum number std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; min_secondmin(2, std::vector\u0026lt;int\u0026gt;(2, 0x3f3f3f3f)); for (int i = 1; i \u0026lt;= n; ++i) { int index_min = min_secondmin[0][0]; int first_min = min_secondmin[0][1]; int second_min = min_secondmin[1][1]; min_secondmin[0][1] = min_secondmin[1][1] = 0x3f3f3f3f; for (int j = 0; j \u0026lt; m; ++j) { dp[i][j] = costs[i - 1][j]; if (i == 1 \u0026amp;\u0026amp; dp[i][j] \u0026lt; min_secondmin[0][1]) { min_secondmin[1][1] = min_secondmin[0][1]; min_secondmin[1][0] = min_secondmin[0][0]; min_secondmin[0][1] = dp[i][j]; min_secondmin[0][0] = j; continue; } if (i == 1 \u0026amp;\u0026amp; dp[i][j] \u0026lt; min_secondmin[1][1]) { min_secondmin[1][1] = dp[i][j]; min_secondmin[1][0] = j; } if (i == 1) { continue; } if (j == index_min) { // j is the smallest and choose the second smallest dp[i][j] += second_min; } else { // j is not the smallest one and choose the smallest dp[i][j] += first_min; } if (dp[i][j] \u0026lt; min_secondmin[0][1]) { min_secondmin[1][1] = min_secondmin[0][1]; min_secondmin[1][0] = min_secondmin[0][0]; min_secondmin[0][1] = dp[i][j]; min_secondmin[0][0] = j; continue; } if (dp[i][j] \u0026lt; min_secondmin[1][1]) { min_secondmin[1][1] = dp[i][j]; min_secondmin[1][0] = j; } } } int ans = 0x3f3f3f3f; for (int i = 0; i \u0026lt; m; ++i) { ans = std::min(ans, dp[n][i]); } return ans; } }; Official time optimized solution class Solution { public: int minCostII(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { int n = costs.size(); if (n == 0) { return 0; } int m = costs[0].size(); if (m == 0) { return 0; } if (n == 1 \u0026amp;\u0026amp; m == 1) { return costs[0][0]; } int dp[n + 1][m]; int f[n + 1][m]; int i, j, k, a, b; for (int i = 0; i \u0026lt; m; ++i) { f[0][i] = 0; } // first i houses: 0 ... i - 1 for (i = 1; i \u0026lt;= n; ++i) { // find minimum and 2nd minimum among // f[i - 1][0], ..., f[i - 1][m - 1] a = b = -1; // this is index for (k = 0; k \u0026lt; m; ++k) { if (a == -1 || f[i - 1][k] \u0026lt; f[i - 1][a]) { // new minimum is f[i - 1][k] b = a; // old minimum becomes now the 2nd minimum a = k; // new minimum is f[i - 1][k] } else { if (b == -1 || f[i - 1][k] \u0026lt; f[i - 1][b]) { b = k; } } } for (j = 0; j \u0026lt; m; ++j) { if (j != a) { // remove an element which is NOT the minimum f[i][j] = f[i - 1][a] + costs[i - 1][j]; } else { // remove an element which IS the minimum f[i][j] = f[i - 1][b] + costs[i - 1][j]; } } } int ans = 0x3f3f3f3f; for (int i = 0; i \u0026lt; m; ++i) { ans = std::min(ans, f[n][i]); } return ans; } }; remember the strategy to calculate minimum and the 2nd minimum with one time iteration\na == -1 || f[a] ....\n序列型动态规划\u0026ndash;买卖股票1 Lintcode 149 买卖股票1 动态规划解法 从 0 到 N - 1 枚举 j, 即第几天卖 时刻保存当前为止（即 0 ~ j - 1 天）的最低加个P_i 最大的P_j - P_i 即为答案 Mine correct solution class Solution { public: int maxProfit(std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n \u0026lt;= 1) { return 0; } int min_index = 0; int max_profit = 0; for (int j = 1; j \u0026lt; n; ++j) { if (prices[j] \u0026lt; prices[min_index]) { min_index = j; continue; } if (max_profit \u0026lt; prices[j] - prices[min_index]) { max_profit = prices[j] - prices[min_index]; } } return max_profit; } }; Official solution: Better class Solution { public: int maxProfit(std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n \u0026lt;= 1) { return 0; } int min = prices[0]; int res = 0; for (int j = 1; j \u0026lt; n; ++j) { // The minimum among prices[0] ... prices[j - 1] is stored in min res = std::max(res, prices[j] - min); min = std::min(min, prices[j]); } return res; } }; 序列型动态规划\u0026ndash;买卖股票2 Lintcode 150 买卖股票2 题目分析 买卖任意多次 最优策略是如果今天的价格比明天的价格低，就今天买，明天卖（贪心） 凡事我们自己想出来的贪心算法都需要证明一下： 所有的贪心的证明都是：假设最优策略不是这样，可以改成这样，且不会更差 正确性证明可以从这里下手： 如果最优策略第10天买，第15天卖，我们可以把它分解成5天(即改成这样)，结果不会变差 Official solution // 贪心 class Solution { public: int maxProfit(std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.size() == 0) { return 0; } int res = 0; for (int i = 0; i \u0026lt; prices.size() - 1; ++i) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } // res += std::max(prices[i + 1] - prices[i], 0) } return res; } }; 序列型动态规划\u0026ndash;买卖股票3: 序列型 Lintcode 151 买卖股票3 e.g. 输入：[4,4,6,1,1,4,2,5] 输出：6（4买入，6卖出，1买入，5卖出，收益为(6 - 4) + (5 - 1) = 6)\n题目分析 题目大意和 I, II 基本相似 只能最多两次买卖 所以需要记录已经买卖了多少次 动态规划组成部分一：确定状态 最后一步：最优策略中，最后一次卖发生在第 j 天 枚举最后一次买发生在第几天 但是不知道之前有没有买卖过 记录阶段 不知道有没有买过，就记录下来 阶段可以保持：即不进行买卖操作 在阶段2，继续持有，获利为当天价格减昨天价格（当天获利，当天结算） 阶段可以变化：买或卖 在阶段2，卖了一股后，进入阶段3 动态规划组成部分一：确定状态 continued 最优策略一定是前 N 天（第 N - 1 天）结束后，处于\n阶段1: 没买卖过；阶段3: 买卖过一次；阶段5: 买卖过两次 状态：f[i][j]表示前i天（第 i - 1天）结束后，在阶段j的最大获利\n例如，如果要求前 N 天（第 N - 1 天）结束后，在阶段5的最大获利，设为f[N][5]\n情况1: 第 N - 2 天就在阶段5 \u0026mdash; f[N - 1][5] 情况2: 第 N - 2 天还在阶段4（第二次持有股票），第 N - 1 天卖掉 f[N - 1][4] + (P_{N - 1} - P_{N - 2}) 例如，如果要求前 N 天（第 N - 1 天）结束后，在阶段4的最大获利，设为f[N][4]\n情况1: 第 N - 2 天就在阶段4 \u0026mdash; f[N - 1][4] + (P_{N - 1} - P_{N - 2}) 情况2: 第 N - 2 天还在阶段3 \u0026mdash; f[N - 1][3] 子问题 要求f[N][1], ..., f[N][5] 需要知道f[N - 1][1], ..., f[N - 1][5] 子问题 动态规划组成部分二：转移方程 f[i][j]: 前i天（第 i - 1天）结束后，处在阶段j，最大获利 动态规划组成部分三：初始条件和边界情况 刚开始（前 0 天）处于阶段1 f[0][1] = 0 f[0][2] = f[0][3] = f[0][4] = f[0][5] = -inf 阶段 1, 3, 5: f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + P_{i - 1} - P_{i - 2}) 阶段 2, 4: f[i][j] = max(f[i - 1][j] + P_{i - 1} - P_{i - 2}, f[i - 1][j - 1]) 如果 j - 1 \u0026lt; 1 或 i - 2 \u0026lt; 0，对应项不计入 max 因为最多买卖两次，所以答案是max(f[N][1], f[N][3], f[N][5])，即清仓状态下最后一天最大获利 动态规划组成部分四：计算顺序 初始化f[0][1], ..., f[0][5] f[1][1], ..., f[1][5] \u0026hellip; f[N][1], ..., f[N][5] 时间复杂度：O(N), 空间复杂度：O(N), 优化后可以O(1), 因为f[i][1..5]只依赖于f[i - 1][1..5] Official Solution class Solution { public: int maxProfit(std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n == 0) { return 0; } int f[n + 1][5 + 1]; int i, j, k; for (k = 1; k \u0026lt;= 5; ++k) { f[0][k] = 0xcfcfcfcf; // impossible } f[0][1] = 0; for (i = 1; i \u0026lt;= n; ++i) { // 阶段 1, 3, 5：f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]) for (j = 1; j \u0026lt;= 5; j += 2) { // keep state f[i][j] = f[i - 1][j]; // sell today if (j \u0026gt; 1 \u0026amp;\u0026amp; i \u0026gt; 1 \u0026amp;\u0026amp; f[i - 1][j - 1] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]); } } // 阶段 2, 4：f[i][j] = max(f[i - 1][j] + prices[i - 1] - prices[i - 2], f[i - 1][j - 1]) for (j = 2; j \u0026lt;= 5; j += 2) { // buy today f[i][j] = f[i - 1][j - 1]; // keep state, calculate profit today if (i \u0026gt; 1 \u0026amp;\u0026amp; f[i - 1][j] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j] + prices[i - 1] - prices[i - 2]); } } } int res = 0; for (j = 1; j \u0026lt;= 5; j += 2) { res = std::max(res, f[n][j]); } return res; } }; 序列型动态规划\u0026ndash;买卖股票4 Lintcode 393 买卖股票4 题目分析 首先，如果 K 很大，K \u0026gt; N / 2，则题目可以化简成为Best Time to Buy and Sell Stock II, 每天买入当且仅当价格比下一天低 Best Time to Buy and Sell Stock III 相当于这题中K = 2 所以我们可以借鉴之前的解法 记录阶段 阶段1: 没买卖过 阶段3: 买卖过一次，现在空仓 阶段5: 买卖过两次，现在空仓 \u0026hellip; 阶段2K + 1: 买卖过K次，现在空仓 阶段2: 第一次持有，还没有卖 阶段4: 第二次持有，还没有卖 阶段6: 第三次持有，还没有卖 \u0026hellip; 阶段2K: 第K次持有，还没有卖 动态规划组成部分二：转移方程 f[i][j]: 前i天（第i - 1天）结束后，处在阶段j，最大获利 动态规划组成部分三：初始条件和边界情况 刚开始（前 0 天）处于阶段1 f[0][1] = 0 f[0][2] = f[0][3] = f[0][4] = f[0][**2K + 1**] = -inf 阶段 1, 3, 5, \u0026hellip;, 2K + 1: f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + P_{i - 1} - P_{i - 2}) 阶段 2, 4, \u0026hellip;, 2K: f[i][j] = max(f[i - 1][j] + P_{i - 1} - P_{i - 2}, f[i - 1][j - 1]) 如果 j - 1 \u0026lt; 1 或 i - 2 \u0026lt; 0，对应项不计入 max 因为最多买卖K次，所以答案是max(f[N][1], f[N][3], ..., f[N][**2K + 1**])，即清仓状态下最后一天最大获利 动态规划组成部分四：计算顺序 初始化f[0][1], ..., f[0][**2K + 1**] f[1][1], ..., f[1][**2K + 1**] \u0026hellip; f[N][1], ..., f[N][**2K + 1**] 时间复杂度：O(NK), 空间复杂度：O(NK), 优化后可以O(1), 因为f[i][1..**2K + 1**]只依赖于f[i - 1][1..**2K + 1**] Official Solution class Solution { public: int maxProfit(int K, std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n == 0) { return 0; } int i, j, k; if (K \u0026gt; n / 2) { int ans = 0; for (i = 0; i \u0026lt; n - 1; ++i) { if (prices[i + 1] - prices[i] \u0026gt; 0) { ans += prices[i + 1] - prices[i]; } } return ans; } int f[n + 1][2 * K + 1 + 1]; for (k = 1; k \u0026lt;= 2 * K + 1; ++k) { f[0][k] = 0xcfcfcfcf; // impossible } f[0][1] = 0; for (i = 1; i \u0026lt;= n; ++i) { // 阶段 1, 3, 2 * K + 1：f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]) for (j = 1; j \u0026lt;= 2 * K + 1; j += 2) { // keep state f[i][j] = f[i - 1][j]; // sell today if (j \u0026gt; 1 \u0026amp;\u0026amp; i \u0026gt; 1 \u0026amp;\u0026amp; f[i - 1][j - 1] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]); } } // 阶段 2, 2 * K：f[i][j] = max(f[i - 1][j] + prices[i - 1] - prices[i - 2], f[i - 1][j - 1]) for (j = 2; j \u0026lt;= 2 * K; j += 2) { // buy today f[i][j] = f[i - 1][j - 1]; // keep state, calculate profit today if (i \u0026gt; 1 \u0026amp;\u0026amp; f[i - 1][j] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j] + prices[i - 1] - prices[i - 2]); } } } int res = 0; for (j = 1; j \u0026lt;= 2 * K + 1; j += 2) { res = std::max(res, f[n][j]); } return res; } }; Official Solution : rolling array optimization class Solution { public: int maxProfit(int K, std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n == 0) { return 0; } int i, j, k; if (K \u0026gt; n / 2) { int ans = 0; for (i = 0; i \u0026lt; n - 1; ++i) { if (prices[i + 1] - prices[i] \u0026gt; 0) { ans += prices[i + 1] - prices[i]; } } return ans; } // rolling array optimization int f[2][2 * K + 1 + 1]; int old, now = 0; for (k = 1; k \u0026lt;= 2 * K + 1; ++k) { f[now][k] = 0xcfcfcfcf; // impossible } f[now][1] = 0; for (i = 1; i \u0026lt;= n; ++i) { // 先交换old, now old = now; now = 1 - now; // 阶段 1, 3, 2 * K + 1：f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]) for (j = 1; j \u0026lt;= 2 * K + 1; j += 2) { // keep state f[now][j] = f[old][j]; // sell today if (j \u0026gt; 1 \u0026amp;\u0026amp; i \u0026gt; 1 \u0026amp;\u0026amp; f[old][j - 1] != 0xcfcfcfcf) { f[now][j] = std::max(f[now][j], f[old][j - 1] + prices[i - 1] - prices[i - 2]); } } // 阶段 2, 2 * K：f[i][j] = max(f[i - 1][j] + prices[i - 1] - prices[i - 2], f[i - 1][j - 1]) for (j = 2; j \u0026lt;= 2 * K; j += 2) { // buy today f[now][j] = f[old][j - 1]; // keep state, calculate profit today if (i \u0026gt; 1 \u0026amp;\u0026amp; f[old][j] != 0xcfcfcfcf) { f[now][j] = std::max(f[now][j], f[old][j] + prices[i - 1] - prices[i - 2]); } } } int res = 0; for (j = 1; j \u0026lt;= 2 * K + 1; j += 2) { res = std::max(res, f[now][j]); } return res; } }; 序列型动态规划\u0026ndash;小结 当思考序列型动态规划最后一步时，这一步的选择依赖于前一步的某种状态 题目 最后一步需要知道的信息 序列 + 状态 Paint House 房子N - 1 油漆成红色，则房子N - 2不能油漆成红色 记录油漆前N - 1栋房子并且房子N - 2是红、蓝、绿色的最小花费 Digital Flip 翻转A[i]时，A[i - 1]A[i]不能是01 记录翻转前N - 1位并且第N - 2位是0/1的最小翻转次数 Best Time to Buy and Sell Stock III 第j天卖股票，第i天买股票(i \u0026lt; j)时，需要知道第i天之前是不是已经买了股票 记录前N天买卖股票最大获利，并且第N - 1天：1.未买卖股票；2.买了第一次股票还没卖；\u0026hellip;；5.已经第二次卖了股票 初始化时，f[0]代表前0个元素/前0天当情况 与坐标型动态规划区别 计算时，f[i]代表前i个元素（即元素0~i-1）的某种性质 初探 最长上升子序列(LIS) 最长序列型动态规划 题目给定一个序列\n要求找出符合条件的最长子序列\n方法\n记录以每个元素i结尾的最长子序列的长度 计算时，在i之前枚举子序列上一个元素是哪个 为坐标型动态规划\nLintcode 76 Longest Increasing Subsequence\n动态规划组成部分一：确定状态 最后一步：对于最优的策略，一定有最后一个元素a[j] 第一种情况：最优策略种最长上升子序列就是{a[j]}，答案是1 第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素是a[i]，并且a[i] \u0026lt; a[j]（不一定是连续的） 因为是最优策略，那么它选中的以a[i]结尾的上升子序列一定是最长的 子问题 因为不确定最优策略中a[j]前一个元素a[i]是哪个，需要枚举每个i 求以a[i]结尾的最长上升子序列 本来是求以a[j]结尾的最长上升子序列 化为子问题：i\u0026lt;j 状态：设f[j] = 以a[j]结尾的最长上升子序列的长度 动态规划组成部分二：转移方程 f[j] = 以a[j]结尾的最长上升子序列的长度 f[j] = max(1, f[i] + 1 | i \u0026lt; j and a[i] \u0026lt; a[j]) 动态规划组成部分三：初始条件和边界情况 情况2必须满足： i \u0026gt;= 0 a[j] \u0026gt; a[i]，满足单调性 初始条件：空 动态规划组成部分四：计算顺序 f[j] = 以a[j]结尾的最长上升子序列的长度 计算f[0], f[1], f[2], ..., f[n - 1] 答案是max(f[0], f[1], f[2], \u0026hellip;, f[n - 1]) 算法时间复杂度O(n^2), 空间复杂度O(n) 思考：如何做到时间复杂度O(nlogn) Official Solution: O(n^2) class Solution { public: int longestIncreasingSubsequence(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int f[n]; int max = 0; for (int j = 0; j \u0026lt; n; ++j) { f[j] = 1; // previous element `nums[i]` for (int i = 0; i \u0026lt; j; ++i) { if (nums[i] \u0026lt; nums[j]) { f[j] = std::max(f[j], f[i] + 1); } } max = std::max(f[j], max); } return max; } }; phone interview 组里做什么 下一步什么时候 Exercise 602 俄罗斯套娃信封 Lintcode 602 俄罗斯套娃信封\n信封按照长度从小到大排序后（相同长度按照宽度从大到小），找宽度的 Longest Increasing Subsequence\nnormal: O(n^2)\nchallenge: O(nlogn) （后面再介绍）\nMine first solution: Time Limit Exceeded: dp class Solution { public: int maxEnvelopes(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; envelopes) { int n = envelopes.size(); if (n \u0026lt;= 1) { return n; } int f[n]; std::sort(envelopes.begin(), envelopes.end(), [](const auto\u0026amp; l, const auto\u0026amp; r) { return (l[0] == r[0]) ? l[1] \u0026gt; r[1] : l[0] \u0026lt; r[0]; } ); int max = 0; for (int j = 0; j \u0026lt; n; ++j) { f[j] = 1; for (int i = 0; i \u0026lt; j; ++i) { if (envelopes[i][1] \u0026lt; envelopes[j][1]) { f[j] = std::max(f[j], f[i] + 1); } } max = std::max(f[j], max); } return max; } }; Mine second solution: Time Limit Exceeded: dfs class Solution { public: int maxEnvelopes(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; envelopes) { int n = envelopes.size(); if (n \u0026lt;= 1) { return n; } std::sort(envelopes.begin(), envelopes.end()); int ans = 0; dfs(envelopes, 0, 0, ans); return ans; } private: void dfs(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; envelopes, int current, int num, int\u0026amp; ans) { ans = std::max(ans, num); for (int i = current; i \u0026lt; envelopes.size(); ++i) { if (current == 0 || envelopes[i][0] \u0026gt; envelopes[current - 1][0] \u0026amp;\u0026amp; envelopes[i][1] \u0026gt; envelopes[current - 1][1]) { dfs(envelopes, i + 1, num + 1, ans); } } } }; Correct forum official solution 此处使用二分优化最长上升子序列，在dp数组中二分查找第一个大于等于当前数的位置，然后dp[i]=k，即第i处的最长上升子序列长度为k。 class Solution { public: int maxEnvelopes(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; envelopes) { int n = envelopes.size(); if (n == 0) { return 0; } auto cmp = [](const auto\u0026amp; x, const auto\u0026amp; y) { return x[0] == y[0] ? x[1] \u0026gt; y[1] : x[0] \u0026lt; y[0]; }; std::sort(envelopes.begin(), envelopes.end(), cmp); std::vector\u0026lt;int\u0026gt; dp(n), height(n+1, INT_MAX); for (int i = 0; i \u0026lt; n; ++i) { int k = std::lower_bound(height.begin(), height.end(), envelopes[i][1]) - height.begin(); dp[i] = k; height[k] = envelopes[i][1]; } int ans = 0; for (int i = 0; i \u0026lt; n; ++i) { ans = std::max(ans, dp[i]); } return ans + 1; } }; 课后习题 ","others-note#Others Note":" 动态规划的题型 坐标型：Triangle, Unique Paths, Jump Game\n前缀型：\n匹配型：Longest Increasing Subsequence, Wildcard Matching 划分型：Word Break 区间型：Stone Game\n背包型：Backpack series\n博弈型：Coins in a Line\n状态压缩型：Traveling Salesman Problem\n树型：Binary Tree Maximum Path Sum\n图型：（面试基本没考过）\n常见DP类型：\n坐标型（20%）\n序列型（20%）\n划分型（20%）\n区间型（15%）\n背包型（10%）\n博弈型（5%）\n最长序列型（5%）\n综合型（5%）\nleft: 清华动态规划专题课\n美团：最长公共子序列 微软：最长上升子序列 阿里巴巴、腾讯：最长回文子串 猿辅导：零钱兑换II 第一章 动态规划了入门 第二章 动态规划初探+坐标型动态规划+位操作型动态规划 第九章 序列型动态规划 第十六章 划分型，博弈型和背包型动态规划 第十七章 背包型动态规划和区间型动态规划 第二十二章 双序列动态规划 right: 国内大厂高频动规题详解\n简历: 最好一页 清楚简洁，简明扼要，但不要太花里胡哨。不要有错字，错词或者语法错误 Project \u0026amp; Experience: 一定要和申请的职位相关 写清楚Contribution。避免写成产品介绍，主要写我做了什么，必要的时候写用了什么工具。e.g. I drove \u0026hellip;, drove \u0026hellip;, design \u0026hellip; 可以放一些数字: reduce pipline time by 51.7% 选最喜欢，最擅长，贡献最大的三个projects 倒背如流细节 How to use heap in c++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #define assertm(exp, msg) assert(((void)msg, exp)) #define print(input) for (auto\u0026amp; elem : input) std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; std::endl int main() { auto cmp = [](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a, const std::pair\u0026lt;int, int\u0026gt;\u0026amp; b) {return a.second \u0026lt; b.second;}; std::set\u0026lt;std::pair\u0026lt;int, int\u0026gt;, decltype(cmp)\u0026gt; heap; heap.insert(std::make_pair(1, 3)); heap.insert(std::make_pair(31, 1)); heap.insert(std::make_pair(4, 4)); heap.insert(std::make_pair(2, 2)); heap.insert(std::make_pair(5, 5)); auto it = heap.begin(); it = std::next(it, 2); it = std::prev(it, 1); std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; heap.size() \u0026lt;\u0026lt; std::endl; int index = 31; auto it2 = std::find_if(heap.begin(), heap.end(), [\u0026amp;index](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a) {return a.first == index;}); heap.erase(it2); it = heap.begin(); std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; heap.size() \u0026lt;\u0026lt; std::endl; return 0; } ","others-note-1#Others Note":" 动态规划的题型 坐标型：Triangle, Unique Paths, Jump Game\n前缀型：\n匹配型：Longest Increasing Subsequence, Wildcard Matching 划分型：Word Break 区间型：Stone Game\n背包型：Backpack series\n博弈型：Coins in a Line\n状态压缩型：Traveling Salesman Problem\n树型：Binary Tree Maximum Path Sum\n图型：（面试基本没考过）\n常见DP类型：\n坐标型（20%） 序列型（20%） 划分型（20%） 区间型（15%） 背包型（10%） 最长序列型（5%） 博弈型（5%） 综合型（5%） left: 清华动态规划专题课\n美团：最长公共子序列 微软：最长上升子序列 阿里巴巴、腾讯：最长回文子串 猿辅导：零钱兑换II 第一章 动态规划了入门 第二章 动态规划初探+坐标型动态规划+位操作型动态规划 第九章 序列型动态规划 第十六章 划分型，博弈型和背包型动态规划 第十七章 背包型动态规划和区间型动态规划 第二十二章 双序列动态规划 right: 国内大厂高频动规题详解\n简历: 最好一页 清楚简洁，简明扼要，但不要太花里胡哨。不要有错字，错词或者语法错误 Project \u0026amp; Experience: 一定要和申请的职位相关 写清楚Contribution。避免写成产品介绍，主要写我做了什么，必要的时候写用了什么工具。e.g. I drove \u0026hellip;, drove \u0026hellip;, design \u0026hellip; 可以放一些数字: reduce pipline time by 51.7% 选最喜欢，最擅长，贡献最大的三个projects 倒背如流细节 How to use heap in c++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #define assertm(exp, msg) assert(((void)msg, exp)) #define print(input) for (auto\u0026amp; elem : input) std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; std::endl int main() { auto cmp = [](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a, const std::pair\u0026lt;int, int\u0026gt;\u0026amp; b) {return a.second \u0026lt; b.second;}; std::set\u0026lt;std::pair\u0026lt;int, int\u0026gt;, decltype(cmp)\u0026gt; heap; heap.insert(std::make_pair(1, 3)); heap.insert(std::make_pair(31, 1)); heap.insert(std::make_pair(4, 4)); heap.insert(std::make_pair(2, 2)); heap.insert(std::make_pair(5, 5)); auto it = heap.begin(); it = std::next(it, 2); it = std::prev(it, 1); std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; heap.size() \u0026lt;\u0026lt; std::endl; int index = 31; auto it2 = std::find_if(heap.begin(), heap.end(), [\u0026amp;index](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a) {return a.first == index;}); heap.erase(it2); it = heap.begin(); std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; heap.size() \u0026lt;\u0026lt; std::endl; return 0; } "},"title":"Dynamic Programming"},"/blog/monotonic_stack/":{"data":{"1#1":"","2#2":"Coverd all topics of Monotonic Stack\n1 Lintcode 1852 最终优惠价 解释 只要单调栈中的元素开始出栈，证明它们应该开始被计算结果。\u0026lt;==\u0026gt; 如果它们要被计算结果，我们要把他们出栈。 总结 单调栈在入栈之前，要判断单调性存不存在：如果不存在，我们要不断地弹出，直到单调性重新存在。 复杂度分析 由于每个下标都最多入栈、出栈各一次 总时间复杂度为O(n + n) = O(n) 空间复杂度为O(n) 单调栈的特点：时空复杂度O(n)、编程复杂度低，思维复杂度高 注意 单调栈的单调性，从一开始到最后，都应该保持一致。 单个元素，单调性存在。 如果发现我的算法需要将一个元素，反复入栈，反复出栈，就不是单调栈算法，不符合单调栈最基本的特点。 Template for i from 0 to (n - 1) while 栈不空 and 单调性不存在 记录此时的答案 # 一般情况下是放在弹出栈之前的(弹前，弹中，弹后) stack.pop() stack.push(i) # 是下标，不是值 Answer class Solution { public: std::vector\u0026lt;int\u0026gt; finalDiscountedPrice(std::vector\u0026lt;int\u0026gt;\u0026amp; prices) { std::deque\u0026lt;int\u0026gt; stack; std::vector\u0026lt;int\u0026gt; results(prices.begin(), prices.end()); for (int i = 0; i \u0026lt; prices.size(); ++i) { while (!stack.empty() \u0026amp;\u0026amp; prices[stack.back()] \u0026gt;= prices[i]) { results[stack.back()] = prices[stack.back()] - prices[i]; stack.pop_back(); } stack.push_back(i); } return results; } }; def final_discounted_price(self, prices: List[int]) -\u0026gt; List[int]: stack = [] results = list(prices) for i in range(len(prices)): while stack and prices[stack[-1]] \u0026gt;= prices[i]: results[stack[-1]] = prices[stack[-1]] - prices[i] stack.pop(-1) stack.append(i) return results Time Complexity 与同向双指针类似，在双指针中，每个元素最多被每个指针扫过一次，所以每个元素最多被扫过两次，总共2n次 ==\u0026gt; O(N) # 同向双指针模版 end = 0 for start in range(len): # 不满足则循环到满足搭配为止 while end \u0026lt; len and (start 到 end 之间不满足条件): end += 1 if start 到 end 之间满足条件: 处理 start 到 end 这段区间(处理start, end这次搭配) 单调栈中，每一个下标最多入栈或出栈一次（即只入，或入+出），总共2n次 ==\u0026gt; O(N) 2 Lintcode 285 高楼大厦 ","3#3":" Lintcode 362 滑动窗口的最大值 Leetcode 239 Sliding Window Maximum ","answer#Answer":"","follow-up-思路#Follow Up 思路":"待补充。。。","template#Template":"","time-complexity#Time Complexity":"","复杂度分析#复杂度分析":"","总结#总结":"","注意#注意":"","解法一brute-force#解法一：Brute Force":" 枚举下标，分别向左向右，计算能看到多少个楼 需要记录当前看到的最高楼 highest 通过打擂台算法不断更新 highest, 每次更新就说明又看到了一个楼 记录更新的次数即可 Answer: Brute Force class Solution { public: /** * @param arr: the height of all buildings * @return: how many buildings can he see at the location of each building */ std::vector\u0026lt;int\u0026gt; tallBuilding(std::vector\u0026lt;int\u0026gt;\u0026amp; arr) { // 一定能看到当前位置的楼 std::vector\u0026lt;int\u0026gt; results(arr.size(), 1); for (int i = 0; i \u0026lt; arr.size(); ++i) { // 向右看能看到多少楼 CountBuildings(arr, results, i, i + 1, arr.size(), 1); // 向左看能看到多少楼 CountBuildings(arr, results, i, i - 1, -1, -1); } return results; } private: void CountBuildings(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, std::vector\u0026lt;int\u0026gt;\u0026amp; results, int index, int start, int end, int delta) { int highest = 0xcfcfcfcf; int can_be_seen = 0; for (int i = start; i != end; i += delta) { if (highest \u0026lt; arr[i]) { highest = arr[i]; ++can_be_seen; } } results[index] += can_be_seen; } }; def tall_building(self, arr: List[int]) -\u0026gt; List[int]: # 一定能看到当前位置的楼 results = [1] * len(arr) for i in range(len(arr)): # 向右看能看到多少楼 self.count_buildings(arr, results, i, range(i + 1, len(arr))) # 向左看能看到多少楼 self.count_buildings(arr, results, i, range(i - 1, -1, -1)) return results def count_buildings(self, arr, results, index, index_list): highest, can_be_seen = float(\u0026#34;-inf\u0026#34;), 0 for i in index_list: if highest \u0026lt; arr[i]: highest = arr[i] can_be_seen += 1 results[index] += can_be_seen 复杂度分析：Brute Force 遍历每个下标 i: O(N) 每个下标 i 向左右查找整个数组: O(N) 总时间复杂度: O(N^2) 空间复杂度: O(N) ","解法一枚举所有窗口#解法一：枚举所有窗口":" 本题仍然属于子数组问题 最直接的办法依然是枚举子数组 由于子数组长度已给出，所以不需要枚举终点 每个子数组打擂台算出最大值 Answer: 枚举所有窗口: Time Limit Exceeded class Solution { public: std::vector\u0026lt;int\u0026gt; maxSlidingWindow(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::vector\u0026lt;int\u0026gt; results; if (nums.size() == 0) { return results; } int n = nums.size(); for (int i = 0; i \u0026lt; n - k + 1; ++i) { int max_value = 0xcfcfcfcf; for (int j = i; j \u0026lt; i + k; ++j) { max_value = std::max(max_value, nums[j]); } results.push_back(max_value); } return results; } }; class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: if not nums: return [] results = [] n = len(nums) for i in range(0, n - k + 1): max_value = -float(\u0026#34;inf\u0026#34;) for j in range(i, i + k): max_value = max(max_value, nums[j]) results.append(max_value) return results 复杂度分析：枚举所有窗口 窗口的长度给定，只需要枚举起点:O(n) 打擂台计算窗口内的最大值:O(k) 总时间复杂度:O(n * k) 需要存放答案，空间复杂度:O(n) ","解法二monotonic-stack#解法二：Monotonic Stack":" 对于疑似单调栈的问题，一定要通过样例模拟 从头到尾，从尾到头进行两次单调栈 分别站在某个位置上向左，向右能看见多少楼房 入栈前的栈的大小就是能看见的房子数量 Answer: Monotonic Stack class Solution { public: /** * @param arr: the height of all buildings * @return: how many buildings can he see at the location of each building */ std::vector\u0026lt;int\u0026gt; tallBuilding(std::vector\u0026lt;int\u0026gt;\u0026amp; arr) { // 一定能看到当前位置的楼 std::vector\u0026lt;int\u0026gt; results(arr.size(), 1); // 向右看能看到多少楼 CountBuildings(arr, results, 0, arr.size(), 1); // 向左看能看到多少楼 CountBuildings(arr, results, arr.size() - 1, -1, -1); return results; } private: void CountBuildings(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, std::vector\u0026lt;int\u0026gt;\u0026amp; results, int start, int end, int delta) { std::deque\u0026lt;int\u0026gt; stack; for (int i = start; i != end; i += delta) { results[i] += stack.size(); // 在这里记录答案，与模版不同 while (!stack.empty() \u0026amp;\u0026amp; arr[stack.back()] \u0026lt;= arr[i]) { stack.pop_back(); } stack.push_back(i); } } }; def tall_building(self, arr: List[int]) -\u0026gt; List[int]: # 一定能看到当前位置的楼 results = [1] * len(arr) # 向右看能看到多少楼 self.count_buildings(arr, results, range(len(arr))) # 向左看能看到多少楼 self.count_buildings(arr, results, range(len(arr) - 1, -1, -1)) return results def count_buildings(self, arr, results, index_list): stack = [] for i in index_list: results[i] += len(stack) # 在这里记录答案，与模版不同 while stack and arr[stack[-1]] \u0026lt;= arr[i]: stack.pop(-1) stack.append(i) ","解释#解释":""},"title":"Monotonic Stack"},"/blog/note_recursion/":{"data":{"":"","chapter-1-参数传递和递归#Chapter 1: 参数传递和递归":"","chapter-2-单向递归--递归vs循环#Chapter 2: 单向递归\u0026ndash;递归vs循环":"","chapter-3-单向递归--递归的妙用#Chapter 3: 单向递归\u0026ndash;递归的妙用":"","chapter-4-双向递归--二叉树的遍历与递归树#Chapter 4: 双向递归\u0026ndash;二叉树的遍历与递归树":"","chapter-5-双向递归--二叉树的分治#Chapter 5: 双向递归\u0026ndash;二叉树的分治":"","chapter-6-多向递归--组合类问题#Chapter 6: 多向递归\u0026ndash;组合类问题":"","chapter-7-多向递归--排列类问题#Chapter 7: 多向递归\u0026ndash;排列类问题":"","chapter-8-非递归--二叉树类#Chapter 8: 非递归\u0026ndash;二叉树类":"","chapter-9-非递归--排列组合类#Chapter 9: 非递归\u0026ndash;排列组合类":"Covered all topics of Recursion\nChapter 1: 参数传递和递归 Chapter 2: 单向递归\u0026ndash;递归vs循环 二阶阶乘 普通递归 普通递归 \u0026ndash;\u0026gt; 尾递归 尾递归 \u0026ndash;\u0026gt; 迭代 颠倒二进制位 普通递归 普通递归 \u0026ndash;\u0026gt; 尾递归 尾递归 \u0026ndash;\u0026gt; 迭代 Exercise: 寻找最大值 普通递归 普通递归 \u0026ndash;\u0026gt; 尾递归 尾递归 \u0026ndash;\u0026gt; 迭代 Chapter 3: 单向递归\u0026ndash;递归的妙用 两两交换链表中的节点 递归的方式 迭代的方式 经典二分查找问题 普通写法的递归方式: Time Limit Exceeded 二分查找的递归方式 快速幂 普通写法的递归方式: 递归求解a^n 递归求解(a^n) % b: Fail 快速幂的递归方式: Pass 快速幂的迭代形式: Pass Exercise: 14. 二分查找 classic method recursion method recursion method version 2 Exercise: 458. 目标最后位置 classic method recursion method recursion method version 2 In summary: Chapter 4: 双向递归\u0026ndash;二叉树的遍历与递归树 二叉树的深度优先遍历 递归，二叉树的遍历： 斐波那契数列 memorization of fibonacci 汉诺塔 Exercise: 1300. 巴什博弈 memorization optimization 递归的核心思想：由大化小：Best Solution In summary Chapter 5: 双向递归\u0026ndash;二叉树的分治 分治法 vs 递归 适合分治法的数据结构 二叉树上分治模版(template of Divide and Conquer for Binary Tree) 二叉树的最大深度 最大二叉树 通过遍历序确定二叉树(important) 前序遍历和中序遍历树构造二叉树 中序遍历和后序遍历树构造二叉树 前序遍历和后序遍历树构造二叉树 Chapter 6: 多向递归\u0026ndash;组合类问题 子集 1. 二叉树遍历解法 2. 组合数解法 子集II: ???? 1. 二叉树遍历解法 2. 组合数解法 数字组合 1. 二叉树遍历解法 2. 组合数解法 Exercise: 1208. 目标和 1. Solution Wrong answer: counter will always be 0 Approach 1.1 for python: Time Limit Exceeded Approach 1.2 for python: Time Limit Exceeded Approach 1.3 for python: Time Limit Exceeded 2. 组合数解法 Chapter 7: 多向递归\u0026ndash;排列类问题 全排列 排列问题递归树 带重复元素的排列 如何从全排列问题转化过来 第k个排列 求解第k个排列 求解一个排列是第几个排列 下一个排列（非递归） Exercise: 990. 美丽排列 Chapter 8: 非递归\u0026ndash;二叉树类 递归改非递归 用栈实现二叉树非递归遍历 前序遍历 中序遍历 后序遍历 用Morris算法实现二叉树非递归遍历 前序遍历 中序遍历 后序遍历 先右子树再左子树的前序遍历 VS 后序遍历 如何通过Morris解决后序遍历：先将问题转化成异样的前序遍历，然后再翻转Morris的结果 两种解法对比 Exercise: 169. 汉诺塔 Chapter 9: 非递归\u0026ndash;排列组合类 组合类问题非递归（三种解法） 二叉树遍历解法 组合数思路解法 二进制枚举解法 排列类问题非递归 用手写栈模拟递归解法 下一个排列解法 Chapter 1: 参数传递和递归 栈空间一般用于存放对象的引用，值类型变量和函数调用信息，堆空间才是用于存放对象本身的\n. and [] 修改的是对象本身，不是引用\n递归的三要素：Recursion\n递归的定义（代表什么含义，接受什么参数，返回什么值） 递归的拆解（把大问题拆成小问题) 递归的出口（到什么时候结束） # 1. 递归的定义 def print_n(n): # 3. 递归的出口 if n \u0026lt; 1: return # 2. 递归的拆解 print_n(n - 1) print(n) 时间复杂度： 迭代O(n), 递归O(n)\n空间复杂度： 迭代O(1), 递归O(n)\n内存中的堆和栈：\n堆空间： - 存放new得到的对象\n- 无限制（剩余内存的大小） 栈空间： - 存放对象的引用\n- 值类型变量\n- C++函数中的数组\n- 有限制，一般很小，MB量级\n- 函数调用栈 递归需谨慎：\n递归调用容易爆栈 人为调用栈不会爆栈 除非C/C++的函数中定义大数组——危险行为 import sys limit = sys.getrecursionlimit() sys.setrecursionlimit(...) Chapter 2: 单向递归\u0026ndash;递归vs循环 二阶阶乘 Lintcode 771 普通递归 递归的定义 doubleFactorial(n) 接收一个正整数n 返回n的二阶阶乘 递归的拆解 求解doubleFactorial(n - 2) 在doubleFactorial(n - 2)的基础上乘n 递归的出口 doubleFactorial(1) = 1 doubleFactorial(2) = 2 class Solution { public: long long doubleFactorial(int n) { if (n \u0026lt;= 2) { return n; } long long temp = doubleFactorial(n - 2); return n * temp; } }; class Solution: def double_factorial(self, n: int) -\u0026gt; int: if n \u0026lt;= 2: return n temp = self.double_factorial(n - 2) return n * temp class Solution { public: long long doubleFactorial(int n) { if (n \u0026lt;= 2) { return n; } return n * doubleFactorial(n - 2); } }; class Solution: def double_factorial(self, n: int) -\u0026gt; int: if n \u0026lt;= 2: return n return n * self.double_factorial(n - 2) 普通递归 \u0026ndash;\u0026gt; 尾递归 尾递归：\n尾递归的特点： 函数中所有递归形式的调用都出现在函数的末尾 递归调用不属于表达式的一部分（在回归过程中不用做任何操作） 尾递归的作用： 尾递归的调用不会在栈中去创建一个新的 而是覆盖当前的活动记录 为什么可以尾递归： 在回归过程中不用做任何操作 // 在回归过程中不能做任何操作 // 事先处理掉乘n的操作 // 把结果作为参数传递给递归函数 class Solution { public: long long doubleFactorial(int n) { return doubleFactorial(n , 1); } private: long long doubleFactorial(int n, long long result) { if (n \u0026lt;= 2) { return n * result; } return doubleFactorial(n - 2, n * result); } }; class Solution: def double_factorial(self, n, result=1): if n \u0026lt;= 2: return n * result return self.double_factorial(n - 2, n * result) 不是所有语言都支持尾递归优化：\n不支持：python, java, C++ 支持：kotlin(tailrec) 以上四种语言都支持尾递归写法，但是支持尾递归优化都只有kotlin 尾递归 \u0026ndash;\u0026gt; 迭代 尾递归优化：就是把递归改成迭代形式\n不支持尾递归优化的语言，解决stackoverflow： 把递归改成迭代形式 Note：所谓的尾递归优化，就是把递归改成迭代形式。所以如果语言不支持尾递归优化，需要手动将尾递归改成迭代形式。 支持尾递归优化的语言，是由编译器自动将尾递归的代码翻译成迭代形式的代码。\n如何改成迭代： 模拟递归中调用下一层的参数传递过程: 1.先做完本层递归的事儿 2.再计算出下一层递归的各个参数 3.然后把值赋给当前层的各个参数 template:(C++) public: ReturnType FunctionName(parameters) { while (true) { do something ... get new parameters parameters = new parameters } } template:(python) def functionName(parameters): while True: do something ... get new parameters parameters = new parameters class Solution { public: long long doubleFactorial(int n) { return doubleFactorial(n , 1); } private: long long doubleFactorial(int n, long long result) { while (true) { // do something if (n \u0026lt;= 2) { return n * result; } // get new parameters int next_n = n - 2; long next_result = n * result; // parameters = new parameters n = next_n; result = next_result; } } }; class Solution: def doubleFactorial(self, n, result=1): while True: # do something if n \u0026lt;= 2: return n * result # get new parameters next_n, next_result = n - 2, n * result # parameters = new parameters n, result = next_n, next_result 颠倒二进制位 Lintcode 1333 普通递归 递归的定义 reverseBits(n, pos) 翻转一个pos位无符号整数n的二进制位并返回 Hints: 把n看成长度为pos的一个数组 递归的拆解 求出n的最后一位二进制位last 翻转n前面的pos-1位 把last放到最前面 递归的出口 n只有1位 pos == 1 class Solution { public: long long reverseBits(long long n) { return reverseBits(n, 32); } private: long long reverseBits(long long n, int pos) { if (pos == 1) { return n; } long long last = n \u0026amp; 1; long long ret = reverseBits(n \u0026gt;\u0026gt; 1, pos - 1); long long result = (last \u0026lt;\u0026lt; (pos - 1)) + ret; return result; } }; class Solution: def reverse_bits(self, n: int, pos=32) -\u0026gt; int: if pos == 1: return n last = n \u0026amp; 1 ret = self.reverse_bits(n \u0026gt;\u0026gt; 1, pos - 1) result = (last \u0026lt;\u0026lt; (pos - 1)) + ret return result 普通递归 \u0026ndash;\u0026gt; 尾递归 在回归过程中不能做任何操作 事先处理掉 (last \u0026laquo; (pos - 1)) + ret 的操作 事先把(last \u0026laquo; (post - 1)) 加到result里 再把result作为参数传给下一层递归 class Solution { public: long long reverseBits(long long n) { return reverseBits(n, 32, 0); } private: long long reverseBits(long long n, int pos, long long result) { if (pos == 1) { return n + result; } long long last = n \u0026amp; 1; result += last \u0026lt;\u0026lt; (pos - 1); return reverseBits(n \u0026gt;\u0026gt; 1, pos - 1, result); } }; class Solution: def reverse_bits(self, n, pos=32, result=0) -\u0026gt; int: if pos == 1: return n + result last = n \u0026amp; 1 result += (last \u0026lt;\u0026lt; (pos - 1)) return self.reverse_bits(n \u0026gt;\u0026gt; 1, pos - 1, result) 尾递归 \u0026ndash;\u0026gt; 迭代 do something?\npos == 1 last = n \u0026amp; 1 get new parameters\nnew_n = n \u0026raquo; 1 new_pos = pos - 1 new_result = result + last \u0026laquo; (pos - 1) parameters = new parameters\nn = new_n pos = new_pos result = new_result class Solution { public: long long reverseBits(long long n) { return reverseBits(n, 32, 0); } private: long long reverseBits(long long n, int pos, long long result) { while (true) { // do something if (pos == 1) { return n + result; } long long last = n \u0026amp; 1; // get new parameters long long new_n = n \u0026gt;\u0026gt; 1; int new_pos = pos - 1; long long new_result = result + (last \u0026lt;\u0026lt; (pos - 1)); // parameters = new parameters n = new_n; pos = new_pos; result = new_result; } } }; class Solution: def reverse_bits(self, n, pos=32, result=0) -\u0026gt; int: while True: # do something if pos == 1: return n + result last = n \u0026amp; 1 # get new parameters new_n, new_pos, new_result = n \u0026gt;\u0026gt; 1, pos - 1, result + (last \u0026lt;\u0026lt; (pos - 1)) # parameters = new parameters n, pos, result = new_n, new_pos, new_result Exercise: 寻找最大值 Lintcode 297 普通递归 递归的定义 maxNum(nums, index) 递归的拆解 nums[index] vs maxNum(\u0026hellip;) 递归的出口 index = nums.size() - 1 class Solution { public: int maxNum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { return maxNum(nums, 0); } private: int maxNum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int index) { if (index == nums.size() - 1) { return nums[index]; } int ret = maxNum(nums, index + 1); return nums[index] \u0026gt; ret ? nums[index] : ret; } }; from typing import ( List, ) class Solution: def max_num(self, nums: List[int], index=0) -\u0026gt; int: if index == len(nums) - 1: return nums[index] ret = self.max_num(nums, index + 1) return nums[index] if nums[index] \u0026gt; ret else ret 普通递归 \u0026ndash;\u0026gt; 尾递归 class Solution { public: int maxNum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { return maxNum(nums, 0, nums[0]); } private: int maxNum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int index, int result) { if (index == nums.size() - 1) { return nums[index] \u0026gt; result ? nums[index] : result; } result = result \u0026gt; nums[index] ? result : nums[index]; return maxNum(nums, index + 1, result); } }; from typing import ( List, ) class Solution: def max_num(self, nums: List[int], index=0, result=float(\u0026#34;-inf\u0026#34;)) -\u0026gt; int: if index == len(nums) - 1: return nums[index] if nums[index] \u0026gt; result else result result = result if result \u0026gt; nums[index] else nums[index] return self.max_num(nums, index + 1, result) 尾递归 \u0026ndash;\u0026gt; 迭代 class Solution { public: int maxNum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { return maxNum(nums, 0, nums[0]); } private: int maxNum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int index, int result) { while (true) { if (index == nums.size() - 1) { return nums[index] \u0026gt; result ? nums[index] : result; } int new_index = index + 1; int new_result = result \u0026gt; nums[index] ? result : nums[index]; index = new_index; result = new_result; } } }; from typing import ( List, ) class Solution: def max_num(self, nums: List[int], index=0, result=float(\u0026#34;-inf\u0026#34;)) -\u0026gt; int: while True: if index == len(nums) - 1: return nums[index] if nums[index] \u0026gt; result else result new_index, new_result = index + 1, result if result \u0026gt; nums[index] else nums[index] index, result = new_index, new_result Chapter 3: 单向递归\u0026ndash;递归的妙用 两两交换链表中的节点 Lintcode 451 递归的方式 递归的定义 swapPairs(head) 两两交换链表head中的节点 返回交换后的链表表头 递归的拆解 取下head中的前两个节点并交换 swapPairs(head.next.next) 连接前两个节点和后面部分链表 递归的出口 链表中节点数量不足两个 不用交换，直接返回当前表头 class Solution { public: ListNode* swapPairs(ListNode* head) { if (head == nullptr || head-\u0026gt;next == nullptr) { return head; } ListNode* first = head; ListNode* second = head-\u0026gt;next; ListNode* suffix = swapPairs(second-\u0026gt;next); second-\u0026gt;next = first; first-\u0026gt;next = suffix; return second; } }; from lintcode import ( ListNode, ) class Solution: def swap_pairs(self, head: ListNode) -\u0026gt; ListNode: if head is None or head.next is None: return head first, second = head, head.next suffix = self.swap_pairs(second.next) second.next = first first.next = suffix return second 迭代的方式 class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; head = dummy; while (head-\u0026gt;next != nullptr \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* first = head-\u0026gt;next; ListNode* second = first-\u0026gt;next; // head-\u0026gt;first-\u0026gt;second-\u0026gt;... // =\u0026gt; head-\u0026gt;second-\u0026gt;first-\u0026gt;... head-\u0026gt;next = second; first-\u0026gt;next = second-\u0026gt;next; second-\u0026gt;next = first; head = first; } return dummy-\u0026gt;next; } }; from lintcode import ( ListNode, ) class Solution: def swap_pairs(self, head: ListNode) -\u0026gt; ListNode: dummy = ListNode(0) dummy.next = head head = dummy while head.next is not None and head.next.next is not None: first = head.next second = head.next.next # head-\u0026gt;first-\u0026gt;second-\u0026gt;... # =\u0026gt; head-\u0026gt;second-\u0026gt;first-\u0026gt;... head.next = second first.next = second.next second.next = first head = first return dummy.next 经典二分查找问题 Lintcode 457 普通写法的递归方式: Time Limit Exceeded 递归的定义 findPosition(nums, start, end, target) 在nums数组[start, end]区间上查找target 递归的拆解 findPosition(nums, start + 1, end, target) 递归的出口 start \u0026gt; end: return -1 nums[start] == target: return start class Solution { public: int findPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { return findPosition(nums, 0, nums.size() - 1, target); } private: int findPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end, int\u0026amp; target) { if (start \u0026gt; end) { return -1; } if (nums[start] == target) { return start; } return findPosition(nums, start + 1, end, target); } }; class Solution: def findPosition(self, nums, target, start=0, end=None): if end is None: end = len(nums) - 1 if start \u0026gt; end: return -1 if nums[start] == target: return start return self.findPosition(nums, target, start + 1, end) 二分查找的递归方式 递归的定义 findPosition(nums, start, end, target) 在nums数组[start, end]区间上查找target 递归的拆解 找到start到end这个范围的中间值middle 如果middle这个位置小了 findPosition(nums, middle + 1, end, target) 如果middle这个位置大了 findPosition(nums, start, middle - 1, target) 递归的出口 start \u0026gt; end; return -1 nums[middle] == target: return middle class Solution { public: int findPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { return findPosition(nums, 0, nums.size() - 1, target); } private: int findPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end, int\u0026amp; target) { if (start \u0026gt; end) { return -1; } int middle = start + (end - start) / 2; if (nums[middle] \u0026lt; target) { findPosition(nums, middle + 1, end, target); } else if (nums[middle] \u0026gt; target) { findPosition(nums, start, middle - 1, target); } else { return middle; } } }; class Solution: def findPosition(self, nums, target): return self.findPosition_helper(nums, 0, len(nums) - 1, target) def findPosition_helper(self, nums, start, end, target): if start \u0026gt; end: return -1 middle = (start + end) // 2 if nums[middle] \u0026lt; target: # keyword return is requried???? return self.findPosition_helper(nums, middle + 1, end, target) elif nums[middle] \u0026gt; target: # keyword return is requried???? return self.findPosition_helper(nums, start, middle - 1, target) else: return middle python doesn\u0026rsquo;t support function overloading\n快速幂 Lintcode 140 普通写法的递归方式: 递归求解a^n 递归的定义 fastPower(a, n) 计算a^n 递归的拆解 a * fastPower(a, n - 1) 递归的出口 n == 0 return 1 同余定理： x * y % z = (x % z) * (y % z) % z\na % b = (a + b) % b = (a + 2 * b) % b \u0026hellip; = (a + k * b) % b, k 是任意整数 x 和 (x % z) 取余相差了整数个z y 和 (y % z) 取余相差了整数个z 递归求解(a^n) % b: Fail 递归的定义 fastPower(a, b, n) 计算(a^n) % b 递归的拆解 同余定理 (x * y) % z \u0026ndash;\u0026gt; ((x % z) * (y % z)) % z x \u0026ndash;\u0026gt; a y \u0026ndash;\u0026gt; a^(n - 1) z \u0026ndash;\u0026gt; b 递归的出口 n == 0 return 1 % b 递归时间复杂度 = 函数参数的可能组合 * 每层递归的处理时间\n函数参数的可能组合 O(n) 每层递归的时间 O(1) class Solution { public: int fastPower(int a, int b, int n) { if (n == 0) { return 1 % b; } int x = a % b; int y = fastPower(a, b, n - 1); return x * y % b; } }; class Solution: def fast_power(self, a: int, b: int, n: int) -\u0026gt; int: if n == 0: return 1 % b x = a % b y = self.fast_power(a, b, n - 1) return x * y % b 快速幂的递归方式: Pass 递归的定义 fastPower(a, b, n) 计算(a^n) % b 递归的拆解 n % 2 == 0 x \u0026ndash;\u0026gt; a^(n/2) y \u0026ndash;\u0026gt; a^(n/2) n % 2 == 1 x \u0026ndash;\u0026gt; a^(n/2) y \u0026ndash;\u0026gt; a^(n/2) * a z \u0026ndash;\u0026gt; b 递归的出口 n == 0 return 1 % b class Solution { public: int fastPower(int a, int b, int n) { if (n == 0) { return 1 % b; } // here must be long long, cannot be int long long x = fastPower(a, b, n / 2); long long y = n % 2 != 0 ? (x * a % b) : x; return x * y % b; } }; class Solution: def fast_power(self, a: int, b: int, n: int) -\u0026gt; int: if n == 0: return 1 % b x = self.fast_power(a, b, n // 2) y = x * a % b if n % 2 != 0 else x return x * y % b 快速幂的迭代形式: Pass class Solution { public: int fastPower(int a, int b, int n) { int result = 1 % b; while (n != 0) { if (n % 2 == 1) { result = (long long)result * a % b; } a = (long long)a * a % b; n /= 2; } return result; } }; class Solution: def fast_power(self, a: int, b: int, n: int) -\u0026gt; int: result = 1 % b while n != 0: if n % 2 == 1: result = result * a % b a = a * a % b n //= 2 return result Exercise: 14. 二分查找 Lintcode 14 classic method class Solution { public: int binarySearch(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) { return -1; } int left = 0; int right = nums.size() - 1; while (left + 1 \u0026lt; right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026gt; target) { right = mid; } else if (nums[mid] \u0026lt; target) { left = mid; } else { right = mid; } } if (nums[left] == target) { return left; } if (nums[right] == target) { return right; } return -1; } }; recursion method class Solution { public: int binarySearch(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { return binarySearch(nums, target, 0, nums.size() - 1); } private: int binarySearch(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int start, int end) { if (start \u0026gt; end) { return -1; } // optional base case if (nums[start] == target) { return start; } int mid = start + (end - start) / 2; if (nums[mid] \u0026gt; target) { return binarySearch(nums, target, start, mid - 1); } else if (nums[mid] \u0026lt; target) { return binarySearch(nums, target, mid + 1, end); } else { if (mid - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[mid - 1] == nums[mid]) { return binarySearch(nums, target, start, mid - 1); } else { return mid; } } } }; class Solution: def binarySearch(self, nums, target): return self._binary_search_helper(nums, target, 0, len(nums) - 1) def _binary_search_helper(self, nums, target, start, end): if start \u0026gt; end: return -1 mid = (start + end) // 2 if nums[mid] \u0026lt; target: # return keyword is required return self._binary_search_helper(nums, target, mid + 1, end) elif nums[mid] \u0026gt; target: # return keyword is required return self._binary_search_helper(nums, target, start, mid - 1) else: if mid - 1 \u0026gt;= 0 and nums[mid - 1] == nums[mid]: return self._binary_search_helper(nums, target, start, mid - 1) else: return mid recursion method version 2 class Solution { public: int binarySearch(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { return binarySearch(nums, target, 0, nums.size() - 1); } int binarySearch(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int left, int right) { if (left \u0026gt; right) { return -1; } int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { return binarySearch(nums, target, mid + 1, right); } if (nums[mid] \u0026gt; target) { return binarySearch(nums, target, left, mid - 1); } int temp = binarySearch(nums, target, left, mid - 1); if (temp != -1) { return temp; } return mid; } }; Exercise: 458. 目标最后位置 Lintcode 458 classic method class Solution { public: int lastPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) { return -1; } int left = 0; int right = nums.size() - 1; while (left + 1 \u0026lt; right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026gt; target) { right = mid; } else if (nums[mid] \u0026lt; target) { left = mid; } else { left = mid; } } if (nums[right] == target) { return right; } else if (nums[left] == target) { return left; } return -1; } }; recursion method class Solution { public: int lastPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { return lastPosition(nums, target, 0, nums.size() - 1); } int lastPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int left, int right) { if (left \u0026gt; right) { return -1; } if (nums[right] == target) { return right; } int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { return lastPosition(nums, target, mid + 1, right); } else if (nums[mid] \u0026gt; target) { return lastPosition(nums, target, left, mid - 1); } else { if (mid + 1 \u0026lt;= nums.size() - 1 \u0026amp;\u0026amp; nums[mid + 1] == nums[mid]) { return lastPosition(nums, target, mid + 1, right); } else { return mid; } } } }; from typing import ( List, ) class Solution: def last_position(self, nums: List[int], target: int) -\u0026gt; int: return self._last_position_helper(nums, target, 0, len(nums) - 1) def _last_position_helper(self, nums, target, left, right): if left \u0026gt; right: return -1 if nums[right] == target: return right mid = (left + right) // 2 if nums[mid] \u0026lt; target: return self._last_position_helper(nums, target, mid + 1, right) elif nums[mid] \u0026gt; target: return self._last_position_helper(nums, target, left, mid - 1) else: if mid + 1 \u0026lt; len(nums) - 1 and nums[mid + 1] == nums[mid]: return self._last_position_helper(nums, target, mid + 1, right) else: return mid recursion method version 2 class Solution { public: int lastPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { return lastPosition(nums, target, 0, nums.size() - 1); } int lastPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int left, int right) { if (left \u0026gt; right) { return -1; } int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { return lastPosition(nums, target, mid + 1, right); } if (nums[mid] \u0026gt; target) { return lastPosition(nums, target, left, mid - 1); } int temp = lastPosition(nums, target, mid + 1, right); if (temp != -1) { return temp; } return mid; } }; In summary: 两两交换链表中的节点\n递归比迭代更加好想，好写，不易出bug 但是递归有可能发生爆栈 经典二分查找问题 和 快速幂问题\n和递归的核心思想由大化小完美贴合的两个算法 换种递归拆分的方法会让时间复杂度和栈深度降低很多 由于每次砍掉一半，递归深度不会太深，没有爆栈风险 Chapter 4: 双向递归\u0026ndash;二叉树的遍历与递归树 二叉树的深度优先遍历 前序遍历(Preorder Traversal)\n根节点 -\u0026gt; 左子树 -\u0026gt; 右子树 Root -\u0026gt; Left -\u0026gt; Right 中序遍历\n左子树 -\u0026gt; 根节点 -\u0026gt; 右子树 Left -\u0026gt; Root -\u0026gt; Right 后序遍历\n左子树 -\u0026gt; 右子树 -\u0026gt; 根节点 Left -\u0026gt; Right -\u0026gt; Root 递归，二叉树的遍历： Lintcode 66 preorder Lintcode 67 inorder Lintcode 68 postorder 递归的定义 preorderTraversal(root) \u0026mdash;- 前序遍历 inorderTraversal(root) \u0026mdash;- 中序遍历 postorderTraversal(root) \u0026mdash;- 后序遍历 递归的拆解 先处理自己 再处理左子树 然后处理右子树 \u0026mdash;- 前序遍历 先处理左子树 再处理自己 然后处理右子树 \u0026mdash;- 中序遍历 先处理左子树 再处理右子树 然后处理自己 \u0026mdash;- 后序遍历 递归的出口 root是一颗空树 \u0026mdash;- 前序遍历、中序遍历、后序遍历 class Solution { public: std::vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { std::vector\u0026lt;int\u0026gt; nodes; preorder_traversal(root, nodes); return nodes; } private: void preorder_traversal(TreeNode* root, std::vector\u0026lt;int\u0026gt;\u0026amp; nodes) { if (root == nullptr) { return; } nodes.push_back(root-\u0026gt;val); preorder_traversal(root-\u0026gt;left, nodes); preorder_traversal(root-\u0026gt;right, nodes); } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def preorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: nodes = list() self.preorder_traversal_helper(root, nodes) return nodes def preorder_traversal_helper(self, root, nodes): if root is None: return nodes.append(root.val) self.preorder_traversal_helper(root.left, nodes) self.preorder_traversal_helper(root.right, nodes) 斐波那契数列 递归树(后序遍历) Lintcode 366 fibonacci 递归的定义 fibonacci(n) 求解斐波那契数列第n项 递归的拆解 fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2) 递归的出口 fibonacci(1) = 0 fibonacci(2) = 1 // Time Limit Exceeded class Solution { public: int fibonacci(int n) { if (n \u0026lt;= 2) { return n - 1; } return fibonacci(n - 1) + fibonacci(n - 2); } }; memorization of fibonacci class Solution { public: int fibonacci(int n) { std::unordered_map\u0026lt;int, int\u0026gt; memo; return fibonacci(n, memo); } private: int fibonacci(int n, std::unordered_map\u0026lt;int, int\u0026gt;\u0026amp; memo) { if (memo.find(n) != memo.end()) { return memo[n]; } if (n \u0026lt;= 2) { return n - 1; } int result = fibonacci(n - 1, memo) + fibonacci(n - 2, memo); memo[n] = result; return result; } }; class Solution: def fibonacci(self, n: int, memo = None) -\u0026gt; int: if memo is None: memo = dict() if n in memo: return memo[n] if n \u0026lt;= 2: return n - 1 result = self.fibonacci(n - 1, memo) + self.fibonacci(n - 2, memo) memo[n] = result return result 汉诺塔 递归树(中序遍历) 拆解的时候只考虑当前层 Lintcode 169 tower of Hanoi 递归的定义 helper(n, start, end, temp, moves) 把n个盘子从start移到end 可以借助temp进行移动 移动的方案存到moves里 递归的拆解 把前n - 1个盘子从start移到temp helper(n - 1, start, temp, end, moves) 把第n个盘子从start移到end 把前n-1个盘子从temp移到end helper(n - 1, temp, end, start, moves) 递归的出口 n == 1 直接把盘子从start移到end class Solution { public: std::vector\u0026lt;std::string\u0026gt; towerOfHanoi(int n) { std::vector\u0026lt;std::string\u0026gt; moves; towerOfHanoi(n, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;, moves); return moves; } private: void towerOfHanoi(int n, char start, char end, char temp, std::vector\u0026lt;std::string\u0026gt;\u0026amp; moves) { if (n == 1) { moves.push_back(move(start, end)); return; // don\u0026#39;t forgot this return } towerOfHanoi(n - 1, start, temp, end, moves); moves.push_back(move(start, end)); towerOfHanoi(n - 1, temp, end, start, moves); } std::string move(char start, char end) { return std::string() + \u0026#34;from \u0026#34; + start + \u0026#34; to \u0026#34; + end; } }; from typing import ( List, ) class Solution: def tower_of_hanoi(self, n: int) -\u0026gt; List[str]: moves = list() self.helper(n, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;, moves) return moves def helper(self, n, start, end, temp, moves): if n == 1: moves.append(self.move(start, end)) return # don\u0026#39;t forgot this return self.helper(n - 1, start, temp, end, moves) moves.append(self.move(start, end)) self.helper(n - 1, temp, end, start, moves) def move(self, start, end): return \u0026#34;from \u0026#34; + start + \u0026#34; to \u0026#34; + end Exercise: 1300. 巴什博弈 Lintcode 1300 递归的定义 canWinBash(n) 有n个石子，先手拿能否获胜 递归的拆解 canWinBash(n - 1) ==\u0026gt; 拿走1个 canWinBash(n - 2) ==\u0026gt; 拿走2个 canWinBash(n - 3) ==\u0026gt; 拿走3个 递归的出口 n \u0026lt;= 3 // Time Limit Exceeded class Solution { public: bool canWinBash(int n) { if (n \u0026lt;= 3) { return true; } return !canWinBash(n - 1) || !canWinBash(n - 2) || !canWinBash(n - 3); } }; # Time Limit Exceeded class Solution: def can_win_bash(self, n: int) -\u0026gt; bool: if n \u0026lt;= 3: return True; return not self.can_win_bash(n - 1) \\ or not self.can_win_bash(n - 2) \\ or not self.can_win_bash(n - 3) memorization optimization // Time Limit Exceeded class Solution { public: bool canWinBash(int n) { std::unordered_map\u0026lt;int, bool\u0026gt; memo; bool result = canWinBash(n, memo); return result; } private: bool canWinBash(int n, std::unordered_map\u0026lt;int, bool\u0026gt;\u0026amp; memo) { if (memo.find(n) != memo.end()) { return memo[n]; } if (n \u0026lt;= 3) { return true; } bool temp = !canWinBash(n - 1) || !canWinBash(n - 2) || !canWinBash(n - 3); memo[n] = temp; return temp; } }; 递归的核心思想：由大化小：Best Solution class Solution { public: bool canWinBash(int n) { return n % 4 != 0; } }; class Solution: def can_win_bash(self, n: int) -\u0026gt; bool: return n % 4 != 0 In summary 斐波那契数列\n有递归式的数列可以直接根据递归式写递归 递归树(后序遍历) 汉诺塔\n递归的时候只考虑当前层，否则参数多转移多的递归会很乱 递归树(中序遍历) Chapter 5: 双向递归\u0026ndash;二叉树的分治 分治法 vs 递归 分治法：分治法 是一种 算法 递归：递归 是一种 程序设计方式\n适合分治法的数据结构 数组：一个大数组可以拆分为若干个不相交的子数组 二叉树：整棵二叉树的左子树和右子树都是二叉树 二叉树上分治模版(template of Divide and Conquer for Binary Tree) class Solution { public: 返回结果类型 DivideConquer(TreeNode* root) { if (root == nullptr) { 处理空树应该返回的结果 } // if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { // 处理叶子应该返回的结果 // 如果叶子的返回结果可以通过两个空节点的返回结果得到 // 就可以省略这一段代码 // 一般可省略 // } 左子树的返回结果 = DivideConquer(root-\u0026gt;left) 右子树的返回结果 = DivideConquer(root-\u0026gt;right) 整棵树的结果 = 按照一定方法合并左右子树的结果 } }; def devide_conquer(root): if root is None: 处理空树应该返回的结果 # if root.left is None and root.right is None: # 处理叶子应该返回的结果 # 如果叶子的返回结果可以通过两个空节点的返回结果得到 # 就可以省略这一段代码 # 一般可省略 左子树的返回结果 = self.divide_conquer(root.left) 右子树的返回结果 = self.divide_conquer(root.right) 整棵树的结果 = 按照一定方法合并左右子树的结果 二叉树的最大深度 Lintcode 97 递归的定义 maxDepth(root) 以root为根的二叉树的最大深度是多少 递归的拆解 maxDepth(root.left) maxDepth(root.right) 递归的出口 root是一棵空树的根 class Solution { public: int maxDepth(TreeNode* root) { if (root == nullptr) { return 0; } return std::max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)) + 1; } }; from lintcode import ( TreeNode, ) class Solution: def max_depth(self, root: TreeNode) -\u0026gt; int: if root is None: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 最大二叉树 Lintcode 1106 递归的定义 buildTree(nums, start, end) 以nums数组的start～end区间构建最大二叉树 递归的拆解 找到nums数组start～end区间上的最大元素位置记做position root = nums[position] root.left = buildTree(nums, start, position - 1); root.right = buildTree(nums, position + 1, end); 递归的出口 nums数组或start～end区间为空的时候 class Solution { public: TreeNode* constructMaximumBinaryTree(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { return buildTree(nums, 0, nums.size() - 1); } private: TreeNode* buildTree(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end) { if (start \u0026gt; end) { return nullptr; } int position = start; for (int i = start + 1; i \u0026lt;= end; ++i) { if (nums[i] \u0026gt; nums[position]) { position = i; } } TreeNode* root = new TreeNode(nums[position]); root-\u0026gt;left = buildTree(nums, start, position - 1); root-\u0026gt;right = buildTree(nums, position + 1, end); return root; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def construct_maximum_binary_tree(self, nums: List[int]) -\u0026gt; TreeNode: return self.buildTree(nums, 0, len(nums) - 1) def buildTree(self, nums, start, end): if start \u0026gt; end: return None position = start for i in range(start + 1, end + 1): if nums[i] \u0026gt; nums[position]: position = i root = TreeNode(nums[position]) root.left = self.buildTree(nums, start, position - 1) root.right = self.buildTree(nums, position + 1, end) return root 通过遍历序确定二叉树(important) 前序遍历和中序遍历树构造二叉树 唯一\nLintcode 73 递归的定义 buildTree(preorder, pre_start, pre_end, inorder, in_start, in_end) 以preorder数组的pre_start~pre_end区间为前序遍历 以inorder数组的in_start~in_end区间为中序遍历 构建二叉树 递归的拆解 preorder[pre_start]: 前序遍历第一个访问到的节点必是根 inorder中preorder[pre_start]左边的部分是左子树，右边的部分是右子树 root.left = buildTree(preorder, pre_start + 1, pre_start + leftLen, inorder, in_start, position - 1) root.right = buildTree(preorder, pre_end - rightLen + 1, pre_end, inorder, position + 1, in_end) 递归的出口 preorder数组或inorder数组区间为空的时候 class Solution { public: TreeNode* buildTree(std::vector\u0026lt;int\u0026gt;\u0026amp; preorder, std::vector\u0026lt;int\u0026gt;\u0026amp; inorder) { return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); } private: TreeNode* buildTree(std::vector\u0026lt;int\u0026gt;\u0026amp; preorder, int pre_start, int pre_end, std::vector\u0026lt;int\u0026gt;\u0026amp; inorder, int in_start, int in_end) { if (pre_start \u0026gt; pre_end) { return nullptr; } if (in_start \u0026gt; in_end) { return nullptr; } TreeNode* root = new TreeNode(preorder[pre_start]); int position = FindPosition(inorder, preorder[pre_start]); int left_len = position - in_start; int right_len = in_end - position; root-\u0026gt;left = buildTree(preorder, pre_start + 1, pre_start + left_len, inorder, in_start, position - 1); root-\u0026gt;right = buildTree(preorder, pre_end - right_len + 1, pre_end, inorder, position + 1, in_end); return root; } int FindPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for (int i = 0; i \u0026lt; nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def build_tree(self, preorder: List[int], inorder: List[int]) -\u0026gt; TreeNode: return self.build_tree_helper(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1) def build_tree_helper(self, preorder, pre_start, pre_end, inorder, in_start, in_end): if pre_start \u0026gt; pre_end: return None if in_start \u0026gt; in_end: return None root = TreeNode(preorder[pre_start]) position = inorder.index(preorder[pre_start]) left_len = position - in_start right_len = in_end - position root.left = self.build_tree_helper(preorder, pre_start + 1, pre_start + left_len, inorder, in_start, position - 1) root.right = self.build_tree_helper(preorder, pre_end - right_len + 1, pre_end, inorder, position + 1, in_end) return root 中序遍历和后序遍历树构造二叉树 唯一\nLintcode 72 class Solution { public: TreeNode* buildTree(std::vector\u0026lt;int\u0026gt;\u0026amp; inorder, std::vector\u0026lt;int\u0026gt;\u0026amp; postorder) { return buildTree(postorder, 0, postorder.size() - 1, inorder, 0, inorder.size() - 1); } private: TreeNode* buildTree(std::vector\u0026lt;int\u0026gt;\u0026amp; postorder, int post_start, int post_end, std::vector\u0026lt;int\u0026gt;\u0026amp; inorder, int in_start, int in_end) { if (post_start \u0026gt; post_end) { return nullptr; } if (in_start \u0026gt; in_end) { return nullptr; } int position = FindPosition(inorder, postorder[post_end]); int left_len = position - in_start; int right_len = in_end - position; TreeNode* root = new TreeNode(postorder[post_end]); root-\u0026gt;left = buildTree(postorder, post_start, post_start + left_len - 1, inorder, in_start, position - 1); root-\u0026gt;right = buildTree(postorder, post_end - right_len, post_end - 1, inorder, position + 1, in_end); return root; } int FindPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for (int i = 0; i \u0026lt; nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def build_tree(self, inorder: List[int], postorder: List[int]) -\u0026gt; TreeNode: return self.build_tree_helper(postorder, 0, len(postorder) - 1, inorder, 0, len(inorder) - 1) def build_tree_helper(self, postorder, post_start, post_end, inorder, in_start, in_end): if post_start \u0026gt; post_end: return None if in_start \u0026gt; in_end: return None root = TreeNode(postorder[post_end]) position = inorder.index(postorder[post_end]) left_len = position - in_start right_len = in_end - position root.left = self.build_tree_helper(postorder, post_start, post_start + left_len - 1, inorder, in_start, position - 1) root.right = self.build_tree_helper(postorder, post_end - right_len, post_end - 1, inorder, position + 1, in_end) return root 前序遍历和后序遍历树构造二叉树 不唯一\nLintcode 1593 递归的定义 buildTree(pre, preStart, preEnd, post, postStart, postEnd) 以pre数组的preStart ~ preEnd区间为前序遍历 以post数组的postStart ~ postEnd区间为后序遍历 构建二叉树 递归的拆解 pre[preStart]: 前序遍历第一个访问到的节点必是根 post中pre[preStart + 1]以及左边的部分是左子树，右边的部分是右子树 root.left = buildTree(pre, preStart + 1, preStart + leftLen, post, postStart, postStart + leftLen - 1) root.right = buildTree(pre, preEnd - rightLen + 1, preEnd, post, postEnd - rightLen, postEnd - 1) 递归的出口 pre数组或post数组区间为空的时候 class Solution { public: TreeNode* constructFromPrePost(std::vector\u0026lt;int\u0026gt;\u0026amp; pre, std::vector\u0026lt;int\u0026gt;\u0026amp; post) { return BuildTree(pre, 0, pre.size() - 1, post, 0, post.size() - 1); } private: TreeNode* BuildTree(std::vector\u0026lt;int\u0026gt;\u0026amp; pre, int pre_start, int pre_end, std::vector\u0026lt;int\u0026gt;\u0026amp; post, int post_start, int post_end) { if (pre_start \u0026gt; pre_end) { return nullptr; } if (post_start \u0026gt; post_end) { return nullptr; } // here is optional if (pre[pre_start] != post[post_end]) { return nullptr; } TreeNode* root = new TreeNode(pre[pre_start]); // here is required. 是递归出口。这里属于模版里面需要特殊处理的叶子节点。如果不处理叶子节点，后面pre_start + 1, 就会数组越界。如果不是叶子节点，就再处理后面的左子树和右子树。 if (pre_start == pre_end || post_start == post_end) { return root; } int position = FindPosition(post, pre[pre_start + 1]); int left_len = position - post_start + 1; int right_len = post_end - position - 1; // 将争议节点并入左子树 root-\u0026gt;left = BuildTree(pre, pre_start + 1, pre_start + left_len, post, post_start, post_start + left_len - 1); root-\u0026gt;right = BuildTree(pre, pre_end - right_len + 1, pre_end, post, post_end - right_len, post_end - 1); return root; } int FindPosition(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for (int i = 0; i \u0026lt; nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def construct_from_pre_post(self, pre: List[int], post: List[int]) -\u0026gt; TreeNode: return self.build_tree(pre, 0, len(pre) - 1, post, 0, len(post) - 1) def build_tree(self, pre, pre_start, pre_end, post, post_start, post_end): if pre_start \u0026gt; pre_end: return None if post_start \u0026gt; post_end: return None if pre[pre_start] != post[post_end]: return None root = TreeNode(pre[pre_start]) # leaf node if pre_start == pre_end or post_start == post_end: return root position = post.index(pre[pre_start + 1]) left_len = position - post_start + 1 right_len = post_end - position - 1 root.left = self.build_tree(pre, pre_start + 1, pre_start + left_len, post, post_start, post_start + left_len - 1) root.right = self.build_tree(pre, pre_end - right_len + 1, pre_end, post, post_end - right_len, post_end - 1) return root Chapter 6: 多向递归\u0026ndash;组合类问题 子集 Lintcode 17 1. 二叉树遍历解法 类似于单向递归\n递归的定义 helper(nums, start, end, combinations, combination) ==\u0026gt; 由于end在递归调用中没有发生变化，所以可以抹掉end helper(nums, start, combinations, combination) 递归的拆解 选取第start个数 不选第start个数 递归的出口 start~end区间为空的时候 =\u0026gt; start越出nums范围的时候 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsets(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination) { if (start == nums.size()) { combinations.push_back(combination); // push_back make a copy of the argument and stores it in the vector return; // let return void } combination.push_back(nums[start]); Helper(nums, start + 1, combinations, combination); combination.pop_back(); Helper(nums, start + 1, combinations, combination); } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: combinations = list() nums.sort() # required in this question self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() if start == len(nums): # ==, not \u0026gt; combinations.append(list(combination)) # deep copy by list(...) return combination.append(nums[start]) self.helper(nums, start + 1, combinations, combination) combination.pop() self.helper(nums, start + 1, combinations, combination) 2. 组合数解法 优化: 铲除多余节点 和之前写的递归套路不太一样\n状态的转移放在了for循环里 递归的隐式出口 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsets(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination) { // 树上没有重复的节点，每一个节点都是需要的子集 combinations.push_back(combination); // 从start开始往后找 for (int i = start; i \u0026lt; nums.size(); ++i) { combination.push_back(nums[i]); Helper(nums, i + 1, combinations, combination); combination.pop_back(); } } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() # 树上没有重复的节点，每一个节点都是需要的子集 combinations.append(list(combination)) # 从start开始往后找 for i in range(start, len(nums)): combination.append(nums[i]) self.helper(nums, i + 1, combinations, combination) combination.pop() 子集II: ???? Lintcode 18 1. 二叉树遍历解法 递归的定义 helper(nums, start, combinations, combination, refuse) refuse 表示前面相同的数字是否都拿走了，如果有一个没拿走，我就不能拿当前这个数 递归的拆解 选取第start个数 不选第start个数 递归的出口 start越出nums范围的时候 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination, false); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination, bool refuse) { if (start == nums.size()) { combinations.push_back(combination); return; } Helper(nums, start + 1, combinations, combination, true); if (refuse \u0026amp;\u0026amp; nums[start] == nums[start - 1]) { return; } combination.push_back(nums[start]); Helper(nums, start + 1, combinations, combination, false); combination.pop_back(); } }; from typing import ( List, ) class Solution: def subsets_with_dup(self, nums: List[int]) -\u0026gt; List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None, False) return combinations def helper(self, nums, start, combinations, combination, refuse): if combination == None: combination = list() if start == len(nums): combinations.append(list(combination)) return self.helper(nums, start + 1, combinations, combination, True) if refuse and nums[start] == nums[start - 1]: return combination.append(nums[start]) self.helper(nums, start + 1, combinations, combination, False) combination.pop() 2. 组合数解法 // Mine version class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination) { // 去重 if (std::find(combinations.begin(), combinations.end(), combination) == combinations.end()) { combinations.push_back(combination); } for (int i = start; i \u0026lt; nums.size(); ++i) { combination.push_back(nums[i]); Helper(nums, i + 1, combinations, combination); combination.pop_back(); } } }; // Official version class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination) { combinations.push_back(combination); for (int i = start; i \u0026lt; nums.size(); ++i) { if (i != start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } combination.push_back(nums[i]); Helper(nums, i + 1, combinations, combination); combination.pop_back(); } } }; # Mine version from typing import ( List, ) class Solution: def subsetsWithDup(self, nums: List[int]) -\u0026gt; List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() # 去重 if combination not in combinations: combinations.append(list(combination)) for i in range(start, len(nums)): combination.append(nums[i]) self.helper(nums, i + 1, combinations, combination) combination.pop() # Official version from typing import ( List, ) class Solution: def subsetsWithDup(self, nums: List[int]) -\u0026gt; List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() combinations.append(list(combination)) for i in range(start, len(nums)): if i != start and nums[i] == nums[i - 1]: continue combination.append(nums[i]) self.helper(nums, i + 1, combinations, combination) combination.pop() 数字组合 Lintcode 135 1. 二叉树遍历解法 递归的定义 helper(nums, now, combinations, combination) 递归的拆解 选取第now个数 选取某个数之后，还能再选这个数 不选第now个数 不选某个数之后，就不能再选这个数 递归的出口 选取的数的和 到达target的时候 now越过nums范围的时候 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(std::vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; // remove duplicates and sort std::set\u0026lt;int\u0026gt; candidates_set{candidates.begin(), candidates.end()}; candidates = {candidates_set.begin(), candidates_set.end()}; Helper(candidates, 0, combinations, combination, target); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int now, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination, int target) { if (target \u0026lt;= 0) { if (target == 0) { combinations.push_back(combination); } return; } if (now \u0026gt;= nums.size()) { return; } combination.push_back(nums[now]); Helper(nums, now, combinations, combination, target - nums[now]); combination.pop_back(); Helper(nums, now + 1, combinations, combination, target); } }; from typing import ( List, ) class Solution: def combination_sum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: combinations = list() candidates = sorted(set(candidates)) self._helper(candidates, 0, combinations, None, target) return combinations def _helper(self, nums, now, combinations, combination, target): if combination is None: combination = list() if target \u0026lt;= 0: if target == 0: combinations.append(list(combination)) # copy value return if now \u0026gt;= len(nums): return combination.append(nums[now]) self._helper(nums, now, combinations, combination, target - nums[now]) combination.pop() self._helper(nums, now + 1, combinations, combination, target) 2. 组合数解法 递归的定义 helper(nums, start, combinations, combination) 递归的拆解 选取第start个数 选取某个数之后，还能再选这个数 不选第start个数 不选某个数之后，就不能再选这个数 递归的出口 选取的数的和 到达target的时候 start越过nums范围的时候 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(std::vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::set\u0026lt;int\u0026gt; candidates_set{candidates.begin(), candidates.end()}; candidates = {candidates_set.begin(), candidates_set.end()}; Helper(candidates, 0, combinations, combination, target); return combinations; } private: void Helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int now, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; combinations, std::vector\u0026lt;int\u0026gt;\u0026amp; combination, int target) { if (target == 0) { // target == 0 instead of target - nums[start] == 0 combinations.push_back(combination); return; } for (int i = now; i \u0026lt; nums.size(); ++i) { if (target - nums[i] \u0026gt;= 0) { // needed combination.push_back(nums[i]); Helper(nums, i, combinations, combination, target - nums[i]); // i instead of i + 1 combination.pop_back(); } } } }; from typing import ( List, ) class Solution: def combination_sum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: combinations = list() candidates = sorted(set(candidates)) self._helper(candidates, 0, combinations, None, target) return combinations def _helper(self, nums, start, combinations, combination, target): if combination is None: combination = list() if target == 0: combinations.append(list(combination)) return for i in range(start, len(nums)): if (target - nums[i] \u0026gt;= 0): combination.append(nums[i]) self._helper(nums, i, combinations, combination, target - nums[i]) combination.pop() Exercise: 1208. 目标和 Lintcode 1208 1. Solution 递归的定义 // 全子集的二叉树解法 helper(nums, start, combinations, combination) start \u0026ndash;\u0026gt; now_index combinations \u0026ndash;\u0026gt; counter // counter 储存最终找到的方案数量 combination \u0026ndash;\u0026gt; now_sum // combination 记录当前所选取的这些方案。 对于当前问题我们不关心+1-2\u0026hellip;， 我们只关心他们最终的和, 不关心是怎么得出这个和的 // s 用于比较 now_sum // 当前问题\nhelper(nums, now_index, now_sum, s, counter) 递归的拆解 // 全子集的二叉树解法 选取第 start 个数 不选第 start 个数 // 当前问题\n第 now_index 个数前面放 \u0026lsquo;+\u0026rsquo; 第 now_index 个数前面放 \u0026lsquo;-\u0026rsquo; 递归的出口 // 全子集的二叉树解法 start 越出 nums 范围的时候 // 当前问题\nnow_index 越出 nums 范围的时候 Wrong answer: counter will always be 0 class Solution { public: int findTargetSumWays(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int s) { int counter = 0; helper(nums, 0, 0, s, counter); return counter; } private: void helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int now_index, int now_sum, int s, int counter) { // void helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int now_index, int now_sum, int s, int\u0026amp; counter) { // corrected if (now_index == nums.size()) { counter += now_sum == s ? 1 : 0; return; } now_sum += nums[now_index]; helper(nums, now_index + 1, now_sum, s, counter); now_sum -= nums[now_index]; now_sum -= nums[now_index]; helper(nums, now_index + 1, now_sum, s, counter); now_sum += nums[now_index]; } }; from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u0026gt; int: counter = 0 self.helper(nums, 0, 0, s, counter) return counter def helper(self, nums, now_index, now_sum, s, counter): if now_index == len(nums): counter += 1 if now_sum == s else 0 return now_sum += nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum -= nums[now_index] now_sum -= nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum += nums[now_index] Approach 1.1 for python: Time Limit Exceeded from typing import ( List, ) class Result: def __init__(self, val): self.val = val class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u0026gt; int: # counter = 0 counter = Result(0) self.helper(nums, 0, 0, s, counter) # return counter return counter.val def helper(self, nums, now_index, now_sum, s, counter): if now_index == len(nums): # counter += 1 if now_sum == s else 0 counter.val += 1 if now_sum == s else 0 return now_sum += nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum -= nums[now_index] now_sum -= nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum += nums[now_index] Approach 1.2 for python: Time Limit Exceeded from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u0026gt; int: # counter = 0 counter = [0] self.helper(nums, 0, 0, s, counter) # return counter return counter[0] def helper(self, nums, now_index, now_sum, s, counter): if now_index == len(nums): # counter += 1 if now_sum == s else 0 counter[0] += 1 if now_sum == s else 0 return now_sum += nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum -= nums[now_index] now_sum -= nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum += nums[now_index] Approach 1.3 for python: Time Limit Exceeded from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u0026gt; int: # counter = 0 # self.helper(nums, 0, 0, s, counter) # return counter return self.helper(nums, 0, 0, s) # def helper(self, nums, now_index, now_sum, s, counter): def helper(self, nums, now_index, now_sum, s): if now_index == len(nums): # counter += 1 if now_sum == s else 0 return 1 if now_sum == s else 0 counter = 0 now_sum += nums[now_index] # self.helper(nums, now_index + 1, now_sum, s, counter) counter += self.helper(nums, now_index + 1, now_sum, s) now_sum -= nums[now_index] now_sum -= nums[now_index] # self.helper(nums, now_index + 1, now_sum, s, counter) counter += self.helper(nums, now_index + 1, now_sum, s) now_sum += nums[now_index] return counter 2. 组合数解法 递归的定义 helper(nums, start_index, now_sum, s) 递归的拆解 在 start_index 后面的位置中选择一个 将其符号修改成 \u0026lsquo;+\u0026rsquo; 并进入递归下一层 递归的出口 start_index 越出 nums 范围的时候 // Accepted #include \u0026lt;numeric\u0026gt; // include numeric for std::accumulate class Solution { public: int findTargetSumWays(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int s) { int now_sum = -std::accumulate(nums.begin(), nums.end(), 0); return helper(nums, 0, now_sum, s); } private: int helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start_index, int now_sum, int s) { int counter = now_sum == s ? 1 : 0; for (int i = start_index; i \u0026lt; nums.size(); ++i) { now_sum += 2 * nums[i]; counter += helper(nums, i + 1, now_sum, s); now_sum -= 2 * nums[i]; } return counter; } }; # Time limit exceeded from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u0026gt; int: now_sum = -sum(nums) return self.helper(nums, 0, now_sum, s) def helper(self, nums, start_index, now_sum, s): counter = 1 if now_sum == s else 0 for i in range(start_index, len(nums)): now_sum += 2 * nums[i] counter += self.helper(nums, i + 1, now_sum, s) now_sum -= 2 * nums[i] return counter Chapter 7: 多向递归\u0026ndash;排列类问题 全排列 Lintcode 15 排列问题递归树 递归的定义 helper(nums, permutations, permutation, visited) 不需要 start 和 end 两个指针 递归的拆解 在 nums 里选择一个还未选择的数 递归的出口 所有数都被选中的时候 visited 的大小达到了 length 或者 permutation 的大小达到了 length class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permute(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permutations; std::vector\u0026lt;int\u0026gt; permutation; std::unordered_set\u0026lt;int\u0026gt; visited; helper(nums, permutations, permutation, visited); return permutations; } private: void helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; permutations, std::vector\u0026lt;int\u0026gt;\u0026amp; permutation, std::unordered_set\u0026lt;int\u0026gt;\u0026amp; visited) { if (visited.size() == nums.size()) { permutations.push_back(permutation); return; // can be ignored } for (int i = 0; i \u0026lt; nums.size(); ++i) { if (visited.find(nums[i]) != visited.end()) { continue; } permutation.push_back(nums[i]); visited.insert(nums[i]); helper(nums, permutations, permutation, visited); permutation.pop_back(); visited.erase(nums[i]); } } }; return?\nfrom typing import ( List, ) class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: permutations = list() self.helper(nums, permutations, None, None) return permutations def helper(self, nums, permutations, permutation, visited): if permutation is None: permutation = list() if visited is None: visited = set() if len(visited) == len(nums): permutations.append(list(permutation)) return # can be ignored for num in nums: if num in visited: continue permutation.append(num) visited.add(num) self.helper(nums, permutations, permutation, visited) permutation.pop() visited.remove(num) return?\n带重复元素的排列 Lintcode 16 递归的定义\nhelper(nums, permutations, permutation, visited) 递归的拆解\n在 nums 里选择一个还未选择的数 且这个数前面相同的数都被选过了 递归的出口\n所有数都被选中的时候 如何从全排列问题转化过来 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permuteUnique(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permutations; std::sort(nums.begin(), nums.end()); // important std::vector\u0026lt;int\u0026gt; permutation; std::vector\u0026lt;bool\u0026gt; visited(nums.size(), false); helper(nums, permutations, permutation, visited); return permutations; } private: void helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; permutations, std::vector\u0026lt;int\u0026gt;\u0026amp; permutation, std::vector\u0026lt;bool\u0026gt;\u0026amp; visited) { if (permutation.size() == nums.size()) { permutations.push_back(permutation); return; } for (int i = 0; i \u0026lt; nums.size(); ++i) { if (visited[i]) { continue; } if (i - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !visited[i - 1]) { continue; } permutation.push_back(nums[i]); visited[i] = true; helper(nums, permutations, permutation, visited); permutation.pop_back(); visited[i] = false; } } }; from typing import ( List, ) class Solution: def permute_unique(self, nums: List[int]) -\u0026gt; List[List[int]]: permutations = list() nums = sorted(nums) # sort self.helper(nums, permutations, None, None) return permutations def helper(self, nums, permutations, permutation, visited): if permutation is None: permutation = list() if visited is None: visited = [False] * len(nums) if len(permutation) == len(nums): permutations.append(list(permutation)) return # can be ignored for i in range(len(nums)): if visited[i]: continue if i - 1 \u0026gt;= 0 and nums[i] == nums[i - 1] and not visited[i - 1]: continue permutation.append(nums[i]) visited[i] = True self.helper(nums, permutations, permutation, visited) permutation.pop() visited[i] = False 第k个排列 Lintcode 388 递归的定义\nhelper(nums, k, result) 由于每次修改的位置在中间 无法为 nums 添加 start 和 end 两个指针 递归的拆解\n找到第 k 个排列的第一个元素 再用剩下的元素到下一层构造后面的部分 递归的出口\nnums 数组为空的时候 class Solution { public: std::string getPermutation(int n, int k) { std::vector\u0026lt;int\u0026gt; nums(n); for (int i = 0; i \u0026lt; n; ++i) { nums[i] = i + 1; } std::string result; helper(nums, k, result); return result; } private: void helper(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, std::string\u0026amp; result) { if (nums.size() == 0) { return; } // e.g. numbers of result after fixing the first element int factorial = 1; for (int i = 1; i \u0026lt; nums.size(); ++i) { factorial *= i; } int first = (k - 1) / factorial; result += std::to_string(nums[first]); nums.erase(nums.begin() + first); helper(nums, (k - 1) % factorial + 1, result); // ??? } }; class Solution: def get_permutation(self, n: int, k: int) -\u0026gt; str: nums = list(range(1, n + 1)) result = list() self.helper(nums, k, result) return \u0026#34;\u0026#34;.join(result) def helper(self, nums, k, result): if not nums: return # e.g. numbers of result after fixing the first element factorial = 1 for i in range(1, len(nums)): factorial *= i first = (k - 1) // factorial result.append(str(nums[first])) nums.pop(first) print(nums) self.helper(nums, (k - 1) % factorial + 1, result) # ??? 求解第k个排列 求解一个排列是第几个排列 下一个排列（非递归） Lintcode 52 class Solution { public: std::vector\u0026lt;int\u0026gt; nextPermutation(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int index = -1; // e.g. nums={3,2,5,4,1}, find index of 2 for (int i = nums.size() - 2; i \u0026gt;= 0; --i) { if (nums[i] \u0026lt; nums[i + 1]) { index = i; break; } } if (index == -1) { reverse(nums, 0, nums.size() - 1); return nums; } // set initial last_bigger is index of 5, and then find the smallest bigger number than 2 int last_bigger = index + 1; for (int i = nums.size() - 1; i \u0026gt; index; --i) { if (nums[i] \u0026gt; nums[index]) { last_bigger = i; break; } } // e.g. {3,2,5,4,1} --\u0026gt; {3,4,5,2,1} int temp = nums[index]; nums[index] = nums[last_bigger]; nums[last_bigger] = temp; // e.g. {3,4,5,2,1} --\u0026gt; {3,4,1,2,5} reverse(nums, index + 1, nums.size() - 1); return nums; } private: void reverse(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end) { while (start \u0026lt; end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; ++start; --end; } } }; from typing import ( List, ) class Solution: def next_permutation(self, nums: List[int]) -\u0026gt; List[int]: index = -1 for i in range(len(nums) - 2, -1, -1): if nums[i] \u0026lt; nums[i + 1]: index = i break else: return nums[::-1] last_bigger = index + 1 for i in range(len(nums) - 1, index, -1): if nums[i] \u0026gt; nums[index]: last_bigger = i break nums[index], nums[last_bigger] = nums[last_bigger], nums[index] return nums[: index + 1] + nums[len(nums) - 1 : index : -1] Exercise: 990. 美丽排列 Lintcode 990 递归的定义\nhelper(n, visited, counter) 不需要知道具体排列 把返回值用上可以省略 counter 递归的拆解\n选一个还未选择的且能放到第i位的数 递归的出口\n所有数都被选中的时候 class Solution { public: int countArrangement(int N) { std::unordered_set\u0026lt;int\u0026gt; visited; return helper(N, visited); } private: int helper(int n, std::unordered_set\u0026lt;int\u0026gt;\u0026amp; visited) { if (visited.size() == n) { return 1; } int counter = 0; for (int num = 1; num \u0026lt;= n; ++num) { if (visited.find(num) != visited.end()) { continue; } // (visited.size() + 1) 代表`i` if (num % (visited.size() + 1) != 0 \u0026amp;\u0026amp; (visited.size() + 1) % num != 0) { continue; } visited.insert(num); counter += helper(n, visited); visited.erase(num); } return counter; } }; class Solution: def count_arrangement(self, n: int) -\u0026gt; int: return self.helper(n, None) def helper(self, n, visited): if visited is None: visited = set() if len(visited) == n: return 1 counter = 0 for num in range(1, n + 1): if num in visited: continue # (visited.size() + 1) 代表`i` if num % (len(visited) + 1) and (len(visited) + 1) % num: continue visited.add(num) counter += self.helper(n, visited) visited.remove(num) return counter Chapter 8: 非递归\u0026ndash;二叉树类 递归改非递归 尾递归 改成迭代形式：只要是线性递归，都能改成迭代形式 非尾递归 模拟系统调用栈：当遇到非线性递归（二叉递归，多叉递归） 用特殊思路来完成递归要做的事儿 Morris算法 不算是递归改成非递归 用栈实现二叉树非递归遍历 前序遍历 Lintcode 66 #include \u0026lt;deque\u0026gt; struct State { State(TreeNode* node, int count) : node(node), count(count) {} TreeNode* node; int count; }; class Solution { public: std::vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(root, 0)); std::vector\u0026lt;int\u0026gt; values; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); TreeNode* node = now-\u0026gt;node; int count = now-\u0026gt;count; if (node == nullptr) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); // can be ignore stack.push_back(new State(node-\u0026gt;right, 0)); stack.push_back(new State(node, 2)); // can be ignore stack.push_back(new State(node-\u0026gt;left, 0)); stack.push_back(new State(node, 1)); } if (count == 1) { values.push_back(node-\u0026gt;val); } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def preorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: stack = [(root, 0)] values = [] while stack: node, count = stack.pop() if node is None: continue if count == 0: stack.append((node, 3)) # can be ignore stack.append((node.right, 0)) stack.append((node, 2)) # can be ignore stack.append((node.left, 0)) stack.append((node, 1)) if count == 1: values.append(node.val) return values 中序遍历 Lintcode 67 #include \u0026lt;deque\u0026gt; struct State { State(TreeNode* node, int count) : node(node), count(count) {} TreeNode* node; int count; }; class Solution { public: std::vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(root, 0)); std::vector\u0026lt;int\u0026gt; values; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); TreeNode* node = now-\u0026gt;node; int count = now-\u0026gt;count; if (node == nullptr) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); // can be ignore stack.push_back(new State(node-\u0026gt;right, 0)); stack.push_back(new State(node, 2)); stack.push_back(new State(node-\u0026gt;left, 0)); stack.push_back(new State(node, 1)); // can be ignore } if (count == 2) { values.push_back(node-\u0026gt;val); } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def inorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: stack = [(root, 0)] values = [] while stack: node, count = stack.pop() if node is None: continue if count == 0: stack.append((node, 3)) # can be ignore stack.append((node.right, 0)) stack.append((node, 2)) stack.append((node.left, 0)) stack.append((node, 1)) # can be ignore if count == 2: values.append(node.val) return values 后序遍历 Lintcode 68 #include \u0026lt;deque\u0026gt; struct State { State(TreeNode* node, int count) : node(node), count(count) {} TreeNode* node; int count; }; class Solution { public: std::vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(root, 0)); std::vector\u0026lt;int\u0026gt; values; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); TreeNode* node = now-\u0026gt;node; int count = now-\u0026gt;count; if (node == nullptr) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); stack.push_back(new State(node-\u0026gt;right, 0)); stack.push_back(new State(node, 2)); // can be ignore stack.push_back(new State(node-\u0026gt;left, 0)); stack.push_back(new State(node, 1)); // can be ignore } if (count == 3) { values.push_back(node-\u0026gt;val); } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def postorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: stack = [(root, 0)] values = [] while stack: node, count = stack.pop() if node is None: continue if count == 0: stack.append((node, 3)) stack.append((node.right, 0)) stack.append((node, 2)) # can be ignore stack.append((node.left, 0)) stack.append((node, 1)) # can be ignore if count == 3: values.append(node.val) return values 用Morris算法实现二叉树非递归遍历 前序遍历 Lintcode 66 树上的节点最多只会被访问两次，而对于没有左孩子的节点只会访问一次（把两次访问合二为一）\ne.g. 2在中序遍历下的前驱节点是7; 1在中序遍历下的前驱节点是4\nclass Solution { public: std::vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { std::vector\u0026lt;int\u0026gt; values; TreeNode* now = root; while (now != nullptr) { if (now-\u0026gt;left != nullptr) { TreeNode* temp = now-\u0026gt;left; while (temp-\u0026gt;right != nullptr \u0026amp;\u0026amp; temp-\u0026gt;right != now) { temp = temp-\u0026gt;right; // 一直找到temp 为中序遍历的前驱节点 } if (temp-\u0026gt;right == now) { temp-\u0026gt;right = nullptr; now = now-\u0026gt;right; } else { values.push_back(now-\u0026gt;val); temp-\u0026gt;right = now; now = now-\u0026gt;left; } } else { values.push_back(now-\u0026gt;val); now = now-\u0026gt;right; } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def preorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: values = [] now = root while now: if now.left: temp = now.left while temp.right and temp.right != now: temp = temp.right if temp.right == now: temp.right = None now = now.right else: values.append(now.val) temp.right = now now = now.left else: values.append(now.val) now = now.right return values 中序遍历 Lintcode 67 class Solution { public: std::vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { std::vector\u0026lt;int\u0026gt; values; TreeNode* now = root; while (now != nullptr) { if (now-\u0026gt;left != nullptr) { TreeNode* temp = now-\u0026gt;left; while (temp-\u0026gt;right != nullptr \u0026amp;\u0026amp; temp-\u0026gt;right != now) { temp = temp-\u0026gt;right; // 一直找到temp 为中序遍历的前驱节点 } if (temp-\u0026gt;right == now) { values.push_back(now-\u0026gt;val); // the only difference against the preorder_traversal temp-\u0026gt;right = nullptr; now = now-\u0026gt;right; } else { temp-\u0026gt;right = now; now = now-\u0026gt;left; } } else { values.push_back(now-\u0026gt;val); now = now-\u0026gt;right; } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def inorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: values = [] now = root while now: if now.left: temp = now.left while temp.right and temp.right != now: temp = temp.right if temp.right == now: values.append(now.val) # the only difference against the preorder_traversal temp.right = None now = now.right else: temp.right = now now = now.left else: values.append(now.val) now = now.right return values 后序遍历 Lintcode 68 先右子树再左子树的前序遍历 VS 后序遍历 刚好是反着的关系\ndef helper(self, root, nodes): if root is None: return nodes.append(root.val) self.helper(root.right, nodes) self.helper(root.left, nodes) e.g. result = {2,1,5,4,3,7,6}\ndef helper(self, root, nodes): if root is None: return self.helper(root.left, nodes) self.helper(root.right, nodes) nodes.append(root.val) e.g. result = {6,7,3,4,5,1,2}\n如何通过Morris解决后序遍历：先将问题转化成异样的前序遍历，然后再翻转Morris的结果 class Solution { public: std::vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { std::vector\u0026lt;int\u0026gt; values; TreeNode* now = root; while (now != nullptr) { if (now-\u0026gt;right != nullptr) { TreeNode* temp = now-\u0026gt;right; while (temp-\u0026gt;left != nullptr \u0026amp;\u0026amp; temp-\u0026gt;left != now) { temp = temp-\u0026gt;left; } if (temp-\u0026gt;left == now) { temp-\u0026gt;left = nullptr; now = now-\u0026gt;left; } else { values.push_back(now-\u0026gt;val); temp-\u0026gt;left = now; now = now-\u0026gt;right; } } else { values.push_back(now-\u0026gt;val); now = now-\u0026gt;left; } } std::reverse(values.begin(), values.end()); return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def postorder_traversal(self, root: TreeNode) -\u0026gt; List[int]: values = list() now = root while now: if now.right: temp = now.right while temp.left and temp.left != now: temp = temp.left if temp.left == now: temp.left = None now = now.left else: values.append(now.val) temp.left = now now = now.right else: values.append(now.val) now = now.left values.reverse() return values 两种解法对比 用Morris实现的解法 时间复杂度：O(n) 空间复杂度：O(1) 对树结构的修改：是（之后有重新修改回去了） 用栈来实现的解法（递归与非递归都一样） 时间复杂度：O(n) 空间复杂度：O(n) 对树结构的修改：否 Exercise: 169. 汉诺塔 Lintcode 169 #include \u0026lt;deque\u0026gt; struct Node { Node(int n, char start, char end, char temp) : n(n), start(start), end(end), temp(temp) {} Node* get_left() { // int n = this-\u0026gt;n - 1; // char start = this-\u0026gt;start; // char end = this-\u0026gt;temp; // char temp = this-\u0026gt;end; // return new Node(n, start, end, temp); return new Node(n - 1, start, temp, end); } Node* get_right() { // int n = this-\u0026gt;n - 1; // char start = this-\u0026gt;temp; // char end = this-\u0026gt;end; // char temp = this-\u0026gt;start; // return new Node(n, start, end, temp); return new Node(n - 1, temp, end, start); } std::string move() { // return std::string(\u0026#34;from \u0026#34;) + this-\u0026gt;start + \u0026#34; to \u0026#34; + this-\u0026gt;end; return std::string(\u0026#34;from \u0026#34;) + start + \u0026#34; to \u0026#34; + end; } int n; char start, end, temp; }; struct State { State(Node* node, int count) : node(node), count(count) {} Node* node; int count; }; class Solution { public: std::vector\u0026lt;std::string\u0026gt; towerOfHanoi(int n) { std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(new Node(n, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;), 0)); std::vector\u0026lt;std::string\u0026gt; moves; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); Node* node = now-\u0026gt;node; int count = now-\u0026gt;count; if (node-\u0026gt;n == 0) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); // can be ignore stack.push_back(new State(node-\u0026gt;get_right(), 0)); stack.push_back(new State(node, 2)); stack.push_back(new State(node-\u0026gt;get_left(), 0)); stack.push_back(new State(node, 1)); // can be ignore } if (count == 2) { moves.push_back(node-\u0026gt;move()); } } return moves; } }; from typing import ( List, ) class Node: def __init__(self, n, start, end, temp): self.n = n self.start = start self.end = end self.temp = temp def get_left(self): n = self.n - 1 start = self.start end = self.temp temp = self.end return Node(n, start, end, temp) def get_right(self): n = self.n - 1 start = self.temp end = self.end temp = self.start return Node(n, start, end, temp) def move(self): return \u0026#34;from \u0026#34; + self.start + \u0026#34; to \u0026#34; + self.end class Solution: def tower_of_hanoi(self, n: int) -\u0026gt; List[str]: stack = [(Node(n, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;), 0)] moves = [] while stack: node, count = stack.pop() if node.n == 0: continue if count == 0: stack.append((node, 3)) # can be ignore stack.append((node.get_right(), 0)) stack.append((node, 2)) stack.append((node.get_left(), 0)) stack.append((node, 1)) # can be ignore if count == 2: moves.append(node.move()) return moves Chapter 9: 非递归\u0026ndash;排列组合类 组合类问题非递归（三种解法） Lintcode 17 二叉树遍历解法 1. 参考：二叉树遍历解法(递归) struct State { State(int node, int count) : node(node), count(count) {} int node, count; }; class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsets(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(0, 0)); while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); int node = now-\u0026gt;node; int count = now-\u0026gt;count; if (node == nums.size()) { combinations.push_back(combination); continue; } if (count == 0) { stack.push_back(new State(node, 3)); stack.push_back(new State(node + 1, 0)); stack.push_back(new State(node, 2)); stack.push_back(new State(node + 1, 0)); stack.push_back(new State(node, 1)); } if (count == 1) { combination.push_back(nums[node]); } if (count == 2) { combination.erase(combination.begin() + combination.size() - 1); } } return combinations; } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: combination = [] combinations = [] nums = sorted(nums) stack = [(0, 0)] while stack: node, count = stack.pop() if node == len(nums): combinations.append(list(combination)) continue if count == 0: stack.append((node, 3)) stack.append((node + 1, 0)) stack.append((node, 2)) stack.append((node + 1, 0)) stack.append((node, 1)) if count == 1: combination.append(nums[node]) if count == 2: combination.pop() return combinations 组合数思路解法 2. 参考：组合数解法(递归) struct State { State(int node, int count) : node(node), count(count) {} int node, count; }; class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsets(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::vector\u0026lt;int\u0026gt; combination; std::sort(nums.begin(), nums.end()); std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(0, 0)); while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); int node = now-\u0026gt;node; int count = now-\u0026gt;count; if (count == 0) { combinations.push_back(combination); for (int i = node; i \u0026lt; nums.size(); ++i) { stack.push_back(new State(i, 2)); stack.push_back(new State(i + 1, 0)); stack.push_back(new State(i, 1)); } } if (count == 1) { combination.push_back(nums[node]); } if (count == 2) { combination.erase(combination.begin() + combination.size() - 1); } } return combinations; } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: combination = [] combinations = [] nums = sorted(nums) stack = [(0, 0)] while stack: node, count = stack.pop() if count == 0: combinations.append(list(combination)) for i in range(node, len(nums)): stack.append((i, 2)) stack.append((i + 1, 0)) stack.append((i, 1)) if count == 1: combination.append(nums[node]) if count == 2: combination.pop() return combinations 二进制枚举解法 Time complexity O(n * 2^n)\nclass Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; subsets(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; combinations; std::sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { std::vector\u0026lt;int\u0026gt; combination; for (int j = 0; j \u0026lt; n; ++j) { if ((i \u0026amp; (1 \u0026lt;\u0026lt; j)) != 0) { combination.push_back(nums[j]); } } combinations.push_back(combination); } return combinations; } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: combinations = [] nums = sorted(nums) n = len(nums) for i in range(0, (1 \u0026lt;\u0026lt; n)): combination = [] for j in range(n): if i \u0026amp; (1 \u0026lt;\u0026lt; j): combination.append(nums[j]) combinations.append(combination) return combinations 排列类问题非递归 Lintcode 15 用手写栈模拟递归解法 参考：全排列 struct State { State(int node, int count) : node(node), count(count) {} int node, count; }; class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permute(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;int\u0026gt; permutation; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permutations; std::unordered_set\u0026lt;int\u0026gt; visited; std::deque\u0026lt;State*\u0026gt; stack; stack.push_back(new State(0, 0)); while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); int node = now-\u0026gt;node; int count = now-\u0026gt;count; if (count == 0) { // didn\u0026#39;t use node here when count is 0 if (visited.size() == nums.size()) { permutations.push_back(permutation); continue; } for (int i = 0; i \u0026lt; nums.size(); ++i) { // begin from 0 instead of node if (visited.find(nums[i]) != visited.end()) { continue; } stack.push_back(new State(i, 2)); stack.push_back(new State(i + 1, 0)); // here i + 1 can be anything stack.push_back(new State(i, 1)); } } if (count == 1) { permutation.push_back(nums[node]); visited.insert(nums[node]); } if (count == 2) { permutation.pop_back(); visited.erase(nums[node]); } } return permutations; } }; from typing import ( List, ) class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: permutation = list() permutations = list() visited = set() stack = [(0, 0)] while stack: node, count = stack.pop() if count == 0: # didn\u0026#39;t use node here when count is 0 if len(visited) == len(nums): permutations.append(list(permutation)) continue for i in range(len(nums)): # begin from 0 instead of node if nums[i] in visited: continue stack.append((i, 2)) stack.append((i + 1, 0)) # here i + 1 can be anything stack.append((i, 1)) if count == 1: permutation.append(nums[node]) visited.add(nums[node]) if count == 2: permutation.pop() visited.remove(nums[node]) return permutations 下一个排列解法 参考：下一个排列（非递归） class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permute(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; permutations; std::sort(nums.begin(), nums.end()); // only for corner case where nums is [] if (nums.empty()) { std::vector\u0026lt;int\u0026gt; permutation; permutations.push_back(permutation); } while (!nums.empty()) { std::vector\u0026lt;int\u0026gt; permutation; for (int i = 0; i \u0026lt; nums.size(); ++i) { permutation.push_back(nums[i]); } permutations.push_back(permutation); nums = NextPermutation(nums); } return permutations; } private: std::vector\u0026lt;int\u0026gt; NextPermutation(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int index = -1; for (int i = nums.size() - 2; i \u0026gt;= 0; --i) { if (nums[i] \u0026lt; nums[i + 1]) { index = i; break; } } if (index == -1) { // Reverse(nums, 0, nums.size() - 1); // return nums; return {}; } int last_bigger = index + 1; for (int i = nums.size() - 1; i \u0026gt; index; --i) { if (nums[i] \u0026gt; nums[index]) { last_bigger = i; break; } } int temp = nums[index]; nums[index] = nums[last_bigger]; nums[last_bigger] = temp; Reverse(nums, index + 1, nums.size() - 1); return nums; } void Reverse(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end) { while (start \u0026lt; end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; ++start; --end; } } }; from typing import ( List, ) class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: permutations = list() nums = sorted(nums) while nums is not None: permutations.append(list(nums)) nums = self.next_permutation(nums) return permutations def next_permutation(self, nums: List[int]) -\u0026gt; List[int]: index = -1 for i in range(len(nums) - 2, -1, -1): if nums[i] \u0026lt; nums[i + 1]: index = i break else: # return nums[::-1] return None last_bigger = index + 1 for i in range(len(nums) - 1, index, -1): if nums[i] \u0026gt; nums[index]: last_bigger = i break nums[index], nums[last_bigger] = nums[last_bigger], nums[index] return nums[: index + 1] + nums[len(nums) - 1 : index : -1] We can convert kth permutation problem as well.\n第k个排列是尾递归，可以转化成迭代的形式\nfor 1 .. n!: get kth permutation\n"},"title":"Recursion"},"/blog/segment_tree/":{"data":{"":"Covered topics of Segment Tree and Binary Index Tree\n","chapter-1-线段树-segment-tree#Chapter 1 线段树 Segment Tree":" 如果仅涉及区间上的查询，而不涉及修改，那么用前缀和即可。\n线段树的性质：\n除表示单点的一个节点是叶子节点外，其他每一个表示区间的节点都有两颗子树 每一个节点分出了左右节点的区间长度为父亲节点长度的一半（左边向上取整，右边向下取整） 每一个节点存储的值都是左右节点进行对应运算得出的。这个运算是根据要求而定的。如：求和的是和，求最大值的是max Node: range-max struct SegmentTreeNode { SegmentTreeNode(int start, int end, int max) : start(start), end(end), max(max), left_child(nullptr), right_child(nullptr) {} int start; int end; int max; SegmentTreeNode* left_child; SegmentTreeNode* right_child; }; Build: template (O(n)) SegmentTreeNode* build(int start, int end) { if (start \u0026gt; end) { return nullptr; } if (start == end) { return new SegmentTreeNode(start, end); } SegmentTreeNode* root = new SegmentTreeNode(start, end); if (start != end) { int mid = start + (end - start) / 2; root-\u0026gt;left_child = build(start, mid); root-\u0026gt;right_child = build(mid + 1, end); } return root; } Example: build range-max (O(n)) SegmentTreeNode* build(int start, int end, std::vector\u0026lt;int\u0026gt;\u0026amp; A) { if (start \u0026gt; end) { return nullptr; } if (start == end) { return new SegmentTreeNode(start, end, A[start]); } SegmentTreeNode* node = new SegmentTreeNode(start, end, A[start]); if (start != end) { int mid = start + (end - start) / 2; node-\u0026gt;left_child = build(start, mid, A); node-\u0026gt;right_child = build(mid + 1, end, A); } if (node-\u0026gt;left_child != nullptr \u0026amp;\u0026amp; node-\u0026gt;left_child-\u0026gt;max \u0026gt; node-\u0026gt;max) { node-\u0026gt;max = node-\u0026gt;left_child-\u0026gt;max; } if (node-\u0026gt;right_child != nullptr \u0026amp;\u0026amp; node-\u0026gt;right_child-\u0026gt;max \u0026gt; node-\u0026gt;max) { node-\u0026gt;max = node-\u0026gt;right_child-\u0026gt;max; } return node; } Modify: range-max (O(logn)) void modify(SegmentTreeNode* root, int index, int value) { // if (root-\u0026gt;start == root-\u0026gt;end) { // if (root-\u0026gt;start == root-\u0026gt;end \u0026amp;\u0026amp; root-\u0026gt;end == index) { if (root-\u0026gt;start == index \u0026amp;\u0026amp; root-\u0026gt;end == index) { root-\u0026gt;max = value; return; } int mid = root-\u0026gt;start + (root-\u0026gt;end - root-\u0026gt;start) / 2; if (root-\u0026gt;start \u0026lt;= index \u0026amp;\u0026amp; index \u0026lt;= mid) { modify(root-\u0026gt;left_child, index, value); } if (mid \u0026lt; index \u0026amp;\u0026amp; index \u0026lt;= root-\u0026gt;end) { modify(root-\u0026gt;right_child, index, value); } // non-leaf always has two children root-\u0026gt;max = std::max(root-\u0026gt;left_child-\u0026gt;max, root-\u0026gt;right_child-\u0026gt;max); } Query: range-max (O(logn)) [start, end] 包含于 [node-\u0026gt;start, node-\u0026gt;end]\nint query(SegmentTreeNode* root, int left, int right) { if (left == root-\u0026gt;start \u0026amp;\u0026amp; right == root-\u0026gt;end) { return root-\u0026gt;max; } int mid = root-\u0026gt;start + (root-\u0026gt;end - root-\u0026gt;start) / 2; int left_max = 0xcfcfcfcf; // some default minimum integer int right_max = 0xcfcfcfcf; // some default minimum integer if (left \u0026lt;= mid) { if (mid \u0026lt; right) { left_max = query(root-\u0026gt;left_child, left, mid); } else { left_max = query(root-\u0026gt;left_child, left, right); } } if (mid \u0026lt; right) { if (left \u0026lt;= mid) { right_max = query(root-\u0026gt;right_child, mid + 1, right); } else { right_max = query(root-\u0026gt;right_child, left, right); } } return std::max(left_max, right_max); } ","chapter-2#Chapter 2":"Lintcode 206 Interval Sum Lintcode 206 Interval Sum n为数组长度，m为查询次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) 前缀和数组O(n + m) struct STNode { STNode(int start, int end) : start(start), end(end), sum(0), left_child(nullptr), right_child(nullptr) {} int start, end; long long sum; STNode* left_child; STNode* right_child; }; class SegmentTree { public: SegmentTree(std::vector\u0026lt;int\u0026gt;\u0026amp; A) : size_(A.size()), root_(BuildTree(0, size_ - 1, A)) {} long long QuerySum(int start, int end) { return QuerySum(root_, start, end); } private: STNode* BuildTree(int start, int end, std::vector\u0026lt;int\u0026gt;\u0026amp; A) { STNode* node = new STNode(start, end); if (start == end) { node-\u0026gt;sum = A[start]; return node; } int mid = start + (end - start) / 2; node-\u0026gt;left_child = BuildTree(start, mid, A); node-\u0026gt;right_child = BuildTree(mid + 1, end, A); node-\u0026gt;sum = node-\u0026gt;left_child-\u0026gt;sum + node-\u0026gt;right_child-\u0026gt;sum; return node; } // [start, end] 包含于 [node-\u0026gt;start, node-\u0026gt;end] // 在 node 节点下，查询原数组 [start, end] 区间和 long long QuerySum(STNode* node, int start, int end) { if (node-\u0026gt;start == start \u0026amp;\u0026amp; node-\u0026gt;end == end) { return node-\u0026gt;sum; } int mid = node-\u0026gt;start + (node-\u0026gt;end - node-\u0026gt;start) / 2; long long left_sum = 0; long long right_sum = 0; if (start \u0026lt;= mid) { left_sum = QuerySum(node-\u0026gt;left_child, start, std::min(end, mid)); } if (end \u0026gt;= mid + 1) { right_sum = QuerySum(node-\u0026gt;right_child, std::max(mid + 1, start), end); } return left_sum + right_sum; } int size_; // array size STNode* root_; }; /** * Definition of Interval: * class Interval { * public: * int start, end; * Interval(int start, int end) { * this-\u0026gt;start = start; * this-\u0026gt;end = end; * } * } */ class Solution { public: /** * @param a: An integer list * @param queries: An query list * @return: The result list */ std::vector\u0026lt;long long\u0026gt; intervalSum(std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;Interval\u0026gt;\u0026amp; queries) { std::vector\u0026lt;long long\u0026gt; result; SegmentTree* tree = new SegmentTree(A); for (Interval\u0026amp; i : queries) { result.push_back(tree-\u0026gt;QuerySum(i.start, i.end)); } return result; } }; Lintcode 207 Interval Sum II Lintcode 207 Interval Sum II n为数组长度，m为操作次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) struct STNode { STNode(int start, int end) : start(start), end(end), sum(0), left_child(nullptr), right_child(nullptr) {} int start, end; long long sum; STNode* left_child; STNode* right_child; }; class SegmentTree { public: SegmentTree(std::vector\u0026lt;int\u0026gt;\u0026amp; A) : size_(A.size()), root_(BuildTree(0, size_, A)) {} long long QueryTree(int start, int end) { return QueryTree(root_, start, end); } void ModifyTree(int index, int value) { return ModifyTree(root_, index, value); } private: STNode* BuildTree(int start, int end, std::vector\u0026lt;int\u0026gt;\u0026amp; A) { STNode* node = new STNode(start, end); if (start == end) { node-\u0026gt;sum = A[start]; return node; } int mid = start + (end - start) / 2; node-\u0026gt;left_child = BuildTree(start, mid, A); node-\u0026gt;right_child = BuildTree(mid + 1, end, A); node-\u0026gt;sum = node-\u0026gt;left_child-\u0026gt;sum + node-\u0026gt;right_child-\u0026gt;sum; return node; } // [start, end] 包含于 [node-\u0026gt;start, node-\u0026gt;end] long long QueryTree(STNode* node, int start, int end) { // WRONG!!! if (node-\u0026gt;start == node-\u0026gt;end) { if (start == node-\u0026gt;start \u0026amp;\u0026amp; end == node-\u0026gt;end) { return node-\u0026gt;sum; } long long left_sum = 0; long long right_sum = 0; int mid = node-\u0026gt;start + (node-\u0026gt;end - node-\u0026gt;start) / 2; if (start \u0026lt;= mid) { left_sum = QueryTree(node-\u0026gt;left_child, start, std::min(mid, end)); } if (end \u0026gt; mid) { right_sum = QueryTree(node-\u0026gt;right_child, std::max(start, mid + 1), end); } return left_sum + right_sum; } void ModifyTree(STNode* node, int index, int value) { // if (node-\u0026gt;start == node-\u0026gt;end) { if (node-\u0026gt;start == node-\u0026gt;end \u0026amp;\u0026amp; node-\u0026gt;end == index) { node-\u0026gt;sum = value; return; } if (node-\u0026gt;left_child-\u0026gt;end \u0026gt;= index) { ModifyTree(node-\u0026gt;left_child, index, value); } else { ModifyTree(node-\u0026gt;right_child, index, value); } node-\u0026gt;sum = node-\u0026gt;left_child-\u0026gt;sum + node-\u0026gt;right_child-\u0026gt;sum; } int size_; STNode* root_; }; class Solution { public: Solution(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { if (A.size() == 0) { return; } tree = new SegmentTree(A); } long long query(int start, int end) { if (tree == nullptr) { return 0; } return tree-\u0026gt;QueryTree(start, end); } void modify(int index, int value) { if (tree == nullptr) { return; } tree-\u0026gt;ModifyTree(index, value); } SegmentTree* tree; }; Lintcode 248 Count of Smaller Number Lintcode 248 Count of Smaller Number n为数组长度，m为查询次数，k为数组最大值\n暴力求解O(nm) 树状数组/线段树O(mlogk) 二分法O(nlogn + mlogn) 前缀和数组O(k + n + m) struct STNode { STNode(int start, int end) : start(start), end(end), sum(0), right(nullptr), left(nullptr) {} int start, end, sum; STNode* left; STNode* right; }; class STree { public: STree(int size) : size_(size), root_(BuildTree(0, size_ - 1)) {} int QueryTree(int start, int end) { return QueryTree(root_, start, end); } void ModifyTree(int index, int value) { return ModifyTree(root_, index, value); } private: STNode* BuildTree(int start, int end) { STNode* node = new STNode(start, end); if (start == end) { return node; } int mid = start + (end - start) / 2; node-\u0026gt;left = BuildTree(start, mid); node-\u0026gt;right = BuildTree(mid + 1, end); return node; } int QueryTree(STNode* node, int start, int end) { if (node-\u0026gt;start == start \u0026amp;\u0026amp; node-\u0026gt;end == end) { return node-\u0026gt;sum; } int mid = node-\u0026gt;start + (node-\u0026gt;end - node-\u0026gt;start) / 2; int left_sum = 0; int right_sum = 0; if (start \u0026lt;= mid) { left_sum = QueryTree(node-\u0026gt;left, start, std::min(mid, end)); } if (end \u0026gt; mid) { right_sum = QueryTree(node-\u0026gt;right, std::max(start, mid + 1), end); } return left_sum + right_sum; } void ModifyTree(STNode* node, int index, int value) { if (node-\u0026gt;start == node-\u0026gt;end \u0026amp;\u0026amp; node-\u0026gt;start == index) { node-\u0026gt;sum = value; return; } int mid = node-\u0026gt;start + (node-\u0026gt;end - node-\u0026gt;start) / 2; if (index \u0026lt;= mid) { ModifyTree(node-\u0026gt;left, index, value); } else { ModifyTree(node-\u0026gt;right, index, value); } node-\u0026gt;sum = node-\u0026gt;left-\u0026gt;sum + node-\u0026gt;right-\u0026gt;sum; } int size_; STNode* root_; }; class Solution { public: std::vector\u0026lt;int\u0026gt; countOfSmallerNumber(std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;int\u0026gt;\u0026amp; queries) { std::vector\u0026lt;int\u0026gt; B(10001); for (int\u0026amp; a : A) { ++B[a]; } STree* tree = new STree(10001); for (int i = 0; i \u0026lt;= 10000; ++i) { tree-\u0026gt;ModifyTree(i, B[i]); } std::vector\u0026lt;int\u0026gt; result; for (int\u0026amp; q : queries) { if (q == 0) { result.push_back(0); } else { result.push_back(tree-\u0026gt;QueryTree(0, q - 1)); } } return result; } }; Lintcode 249 Count of Smaller Number before itself Lintcode 249 Count of Smaller Number before itself n为数组长度，k为数组最大值\n暴力求解O(n^2) 树状数组/线段树O(nlogk) 在单点修改的情况下，维护前缀和：使用线段树维护B数组\nstruct STNode { STNode(int start, int end) : start(start), end(end), sum(0), left(nullptr), right(nullptr) {} int start, end; int sum; STNode* left; STNode* right; }; class STree { public: STree(int size) : size_(size), root_(BuildTree(0, size_ - 1)) {} int QueryTree(int start, int end) { return QueryTree(root_, start, end); } void ModifyTree(int index, int value) { return ModifyTree(root_, index, value); } private: STNode* BuildTree(int start, int end) { STNode* node = new STNode(start, end); if (start == end) { return node; } int mid = start + (end - start) / 2; node-\u0026gt;left = BuildTree(start, mid); node-\u0026gt;right = BuildTree(mid + 1, end); return node; } int QueryTree(STNode* node, int start, int end) { if (node-\u0026gt;start == start \u0026amp;\u0026amp; node-\u0026gt;end == end) { return node-\u0026gt;sum; } int left_sum = 0; int right_sum = 0; int mid = node-\u0026gt;start + (node-\u0026gt;end - node-\u0026gt;start) / 2; if (start \u0026lt;= mid) { left_sum = QueryTree(node-\u0026gt;left, start, std::min(mid, end)); } if (end \u0026gt; mid) { right_sum = QueryTree(node-\u0026gt;right, std::max(start, mid + 1), end); } return left_sum + right_sum; } void ModifyTree(STNode* node, int index, int value) { if (node-\u0026gt;start == node-\u0026gt;end \u0026amp;\u0026amp; node-\u0026gt;start == index) { node-\u0026gt;sum = value; return; } if (node-\u0026gt;left-\u0026gt;end \u0026gt;= index) { ModifyTree(node-\u0026gt;left, index, value); } else { ModifyTree(node-\u0026gt;right, index, value); } node-\u0026gt;sum = node-\u0026gt;left-\u0026gt;sum + node-\u0026gt;right-\u0026gt;sum; } int size_; STNode* root_; }; class Solution { public: std::vector\u0026lt;int\u0026gt; countOfSmallerNumberII(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { STree* tree = new STree(10001); std::vector\u0026lt;int\u0026gt; B(10001); std::vector\u0026lt;int\u0026gt; result; for (int\u0026amp; i : A) { if (i == 0) { result.push_back(0); } else { result.push_back(tree-\u0026gt;QueryTree(0, i - 1)); } ++B[i]; tree-\u0026gt;ModifyTree(i, B[i]); } return result; } }; Exercise: Lintcode 201 Build Segment Tree Lintcode 201 Build Segment Tree /** * Definition of SegmentTreeNode: * class SegmentTreeNode { * public: * int start, end; * SegmentTreeNode *left, *right; * SegmentTreeNode(int start, int end) { * this-\u0026gt;start = start, this-\u0026gt;end = end; * this-\u0026gt;left = this-\u0026gt;right = NULL; * } * } */ class Solution { public: SegmentTreeNode* build(int start, int end) { } }; Exercise: Lintcode 439 Build Segment Tree II Lintcode 439 Build Segment Tree II Exercise: Lintcode 202 Query Segment Tree Lintcode 202 Query Segment Tree Exercise: Lintcode 247 Query Segment Tree II Lintcode 247 Query Segment Tree II Exercise: Lintcode 203 Modify Segment Tree Lintcode 203 Modify Segment Tree ","chapter-3-树状数组-binary-index-tree#Chapter 3 树状数组 Binary Index Tree":" 用于维护前缀信息的结构，对前缀信息的处理也是非常高效的\n给定一个整数数组nums，然后你需要实现两个函数: Update(i, val)将数组下标为i的元素修改为val SumRange(l, r)返回数组下标在[l, r]区间的元素的和 暴力求解: Update时间复杂度O(1)、SumRange时间复杂度O(n)\n树状数组求解: Update时间复杂度O(logn)、SumRange时间复杂度O(logn)、对于长度为n的数组，构建树状数组时间复杂度O(nlogn)\nBinary Index Tree 是通过前缀和思想，用来完成 单点更新 和 区间查询 的数据结构。 Binary Index Tree advantages compared to Segment Tree: 所用空间更小（空间复杂度都是O(n), 但是Binary Index Tree只开了一个大小为n的数组，Segment Tree有左右指针, 区间端点等等），速度更快。 注意: 树状数组的下标从 1 开始计数。 定义: 数组 C 是一个对原始数组 A 的预处理数组。 C[i]的元素个数（来自于A）：取决于i的二进制末尾有几个连续的0.\ne.g. i有k个0，那么C[i]共有2^k个A中的元素.\n根据lowbit函数，可以知道C[i]代表几个A中的元素相加，以及i的父亲在哪儿(i + lowbit(i), e.g. 6 + lowbit(6) = 8)\nLowbit 的两个含义 e.g. Lowbit(4) = 4:\n从A[4]出发向左共四个数的SUM 从C[4]搭出去梯子的长度（长度为4: A[5], A[6], A[7], A[8]），C[4]的值会影响到C[8] 树状数组的程序实现: Lintcode 840: Range Sum Lintcode 840 Range Sum /** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */ class NumArray { public: NumArray(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { // both of them have to be assigned to 0 arr_.assign(nums.size(), 0); bit_.assign(nums.size() + 1, 0); for (int i = 0; i \u0026lt; nums.size(); ++i) { update(i, nums[i]); } } void update(int index, int value) { int delta = value - arr_[index]; arr_[index] = value; // Lowbit(i) 此时是Lowbit的第二个含义，即搭出去的梯子 for (int i = index + 1; i \u0026lt;= arr_.size(); i = i + Lowbit(i)) { // bit_[i] 即C数组，包含了Lowbit的第二个含义（bit_[i]记录了Lowbit(i)个值的Sum） bit_[i] += delta; } } int sumRange(int left, int right) { return GetPrefixSum(right) - GetPrefixSum(left - 1); } private: int GetPrefixSum(int index) { int sum = 0; // Lowbit(i) 此时是Lowbit的第二个含义，即搭出去的梯子 for (int i = index + 1; i \u0026gt; 0; i = i - Lowbit(i)) { sum += bit_[i]; } return sum; } inline int Lowbit(int x) { return x \u0026amp; (-x); } std::vector\u0026lt;int\u0026gt; arr_, bit_; }; In summary 若求区间(i, j)的区间和rangeSum(i, j) 使用前缀和时，rangeSum(i, j) = sum(j) - sum(i)，时间复杂度为O(1)。 使用线段树时，需要从根向下搜索，找到所有包含且仅包含(i, j)中元素的区间和，所有的深度最大为树的高度，时间复杂度为O(log n)。 使用树状数组，根据公式sum(i) = sum(i - lowbit(i)) + C[i]，使用树状数组求前缀和的时间复杂度为O(log n)。区间和rangeSum(i, j) = sum(j) - sum(i)，求区间和的操作可以转换为求两次前缀和，因此时间复杂度也是O(log n)。 ","chapter-4#Chapter 4":"Lintcode 206 Interval Sum Lintcode 206 Interval Sum n为数组长度，m为查询次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) 前缀和数组O(n + m) class BinaryIndexTree { public: BinaryIndexTree(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { size_ = A.size(); a_ = std::vector\u0026lt;long long\u0026gt;(size_ + 1); // a_.assign(size_ + 1, 0); for (int i = 0; i \u0026lt; size_; ++i) { Add(i, A[i]); } } // A[index] += val void Add(int index, int val) { ++index; while (index \u0026lt;= size_) { a_[index] += val; index += Lowbit(index); } } // A[0] + ... + A[index] long long PrefixSum(int index) { ++index; long long ans = 0; while (index \u0026gt; 0) { ans += a_[index]; index -= Lowbit(index); } return ans; } private: inline int Lowbit(int x) { return x \u0026amp; (-x); } std::vector\u0026lt;long long\u0026gt; a_; int size_; }; class Solution { public: std::vector\u0026lt;long long\u0026gt; intervalSum(std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;Interval\u0026gt;\u0026amp; queries) { std::vector\u0026lt;long long\u0026gt; ans; // BinaryIndexTree tree(A); BinaryIndexTree* tree = new BinaryIndexTree(A); // for (Interval\u0026amp; i : queries) { // if (i.start == 0) { // ans.push_back(tree.PrefixSum(i.end)); // } else { // ans.push_back(tree.PrefixSum(i.end) - // tree.PrefixSum(i.start - 1)); // } // } for (Interval\u0026amp; i : queries) { if (i.start == 0) { ans.push_back(tree-\u0026gt;PrefixSum(i.end)); } else { ans.push_back(tree-\u0026gt;PrefixSum(i.end) - tree-\u0026gt;PrefixSum(i.start - 1)); } } return ans; } }; Lintcode 207 Interval Sum II Lintcode 207 Interval Sum II n为数组长度，m为操作次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) class BinaryIndexTree { public: BinaryIndexTree(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { size_ = A.size(); a_ = std::vector\u0026lt;long long\u0026gt;(size_ + 1); // a_.assign(size_ + 1, 0); for (int i = 0; i \u0026lt; size_; ++i) { Add(i, A[i]); } } // A[index] += val void Add(int index, int val) { ++index; while (index \u0026lt;= size_) { a_[index] += val; index += Lowbit(index); } } // A[0] + ... + A[index] long long PrefixSum(int index) { ++index; long long ans = 0; while (index \u0026gt; 0) { ans += a_[index]; index -= Lowbit(index); } return ans; } private: inline int Lowbit(int x) { return x \u0026amp; (-x); } std::vector\u0026lt;long long\u0026gt; a_; int size_; }; class Solution { public: Solution(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { A_ = A; tree_ = new BinaryIndexTree(A); } long long query(int start, int end) { if (start == 0) { return tree_-\u0026gt;PrefixSum(end); } else { return tree_-\u0026gt;PrefixSum(end) - tree_-\u0026gt;PrefixSum(start - 1); } } void modify(int index, int value) { tree_-\u0026gt;Add(index, value - A_[index]); A_[index] = value; } private: std::vector\u0026lt;int\u0026gt; A_; // 为了计算difference BinaryIndexTree* tree_; }; Lintcode 248 Count of Smaller Number Lintcode 248 Count of Smaller Number n为数组长度，m为查询次数，k为数组最大值\n暴力求解O(nm) 树状数组/线段树O(mlogk) 二分法O(nlogn + mlogn) 前缀和数组O(k + n + m) class BinaryIndexTree { public: BinaryIndexTree(int size) { size_ = size; a_.assign(size_ + 1, 0); } // B[index] += val void Add(int index, int val) { ++index; while (index \u0026lt;= size_) { a_[index] += val; index += Lowbit(index); } } // B[0] + ... + B[index] int PrefixSum(int index) { ++index; int ret = 0; while (index \u0026gt; 0) { ret += a_[index]; index -= Lowbit(index); } return ret; } private: int Lowbit(int x) { return x \u0026amp; (-x); } int size_; std::vector\u0026lt;int\u0026gt; a_; }; class Solution { public: std::vector\u0026lt;int\u0026gt; countOfSmallerNumber(std::vector\u0026lt;int\u0026gt;\u0026amp; A, std::vector\u0026lt;int\u0026gt;\u0026amp; queries) { int max_a = -1; for (int\u0026amp; i : A) { max_a = std::max(max_a, i); } BinaryIndexTree* tree = new BinaryIndexTree(max_a + 1); // B[A[i]]++ for (int\u0026amp; i : A) { tree-\u0026gt;Add(i, 1); } std::vector\u0026lt;int\u0026gt; ans; for (int\u0026amp; i : queries) { if (i \u0026gt; max_a) { ans.push_back(A.size()); } else if (i \u0026lt; 0) { ans.push_back(0); } else { ans.push_back(tree-\u0026gt;PrefixSum(i - 1)); } } return ans; } }; Lintcode 249 Count of Smaller Number before itself Lintcode 249 Count of Smaller Number before itself n为数组长度，k为数组最大值\n暴力求解O(n^2) 树状数组/线段树O(nlogk) class BinaryIndexTree { public: BinaryIndexTree(int size) { size_ = size; a_.assign(size_ + 1, 0); } // B[index] += val void Add(int index, int val) { ++index; while (index \u0026lt;= size_) { a_[index] += val; index += Lowbit(index); } } // B[0] + ... + B[index] int PrefixSum(int index) { ++index; int ret = 0; while (index \u0026gt; 0) { ret += a_[index]; index -= Lowbit(index); } return ret; } private: int Lowbit(int x) { return x \u0026amp; (-x); } int size_; std::vector\u0026lt;int\u0026gt; a_; }; class Solution { public: std::vector\u0026lt;int\u0026gt; countOfSmallerNumberII(std::vector\u0026lt;int\u0026gt;\u0026amp; A) { std::vector\u0026lt;int\u0026gt; ans; int max_a = -1; for (int\u0026amp; i : A) { max_a = std::max(max_a, i); } BinaryIndexTree* tree = new BinaryIndexTree(max_a + 1); for (int\u0026amp; i : A) { if (i == 0) { ans.push_back(0); } else { ans.push_back(tree-\u0026gt;PrefixSum(i - 1)); } tree-\u0026gt;Add(i, 1); // B[i] += 1 } return ans; } }; Exercise: Lintcode 840 可变范围求和 Lintcode 840 可变范围求和 Exercise: Lintcode 817 范围矩阵元素和-可变的 Lintcode 817 范围矩阵元素和-可变的 Exercise: Lintcode 665 平面范围求和 -不可变矩阵 Lintcode 665 平面范围求和 -不可变矩阵 Exercise: Lintcode 207 区间求和 II Lintcode 207 区间求和 II Exercise: Lintcode 206 区间求和 I Lintcode 206 区间求和 I ","content#Content":" Chapter 1 线段树 Segment Tree Node: range-max Build: template (O(n)) Example: build range-max (O(n)) Modify: range-max (O(logn)) Query: range-max (O(logn)) Chapter 2 Lintcode 206 Interval Sum Lintcode 207 Interval Sum II Lintcode 248 Count of Smaller Number Lintcode 249 Count of Smaller Number before itself Exercise: Lintcode 201 Build Segment Tree Exercise: Lintcode 439 Build Segment Tree II Exercise: Lintcode 202 Query Segment Tree Exercise: Lintcode 247 Query Segment Tree II Exercise: Lintcode 203 Modify Segment Tree Chapter 3 树状数组 Binary Index Tree Lowbit 的两个含义 树状数组的程序实现: Lintcode 840: Range Sum In summary Chapter 4 Lintcode 206 Interval Sum Lintcode 207 Interval Sum II Lintcode 248 Count of Smaller Number Lintcode 249 Count of Smaller Number before itself Exercise: Lintcode 840 可变范围求和 Exercise: Lintcode 817 范围矩阵元素和-可变的 Exercise: Lintcode 665 平面范围求和 -不可变矩阵 Exercise: Lintcode 207 区间求和 II Exercise: Lintcode 206 区间求和 I ","materials#Materials":" segment_tree.pdf binary_index_tree.pdf "},"title":"Segment Tree \u0026 Binary Index Tree"},"/blog/thread_vs_process/":{"data":{"":"The difference between thread and process.\nA thread is a lightweight process that shares the same address space as other threads in the same process.\nA process is a heavyweight unit of execution that has its own address space, memory, and resources.\nThreads are typically used to improve the performance of an application by allowing multiple tasks to be executed concurrently.\nProcesses are typically used to improve the security of an application by isolating different tasks from each other.\nFeature Thread Process Address Space Shares the same address space as other threads in the same process Has its own address space Memory Shares the same memory as other threads in the same process Has its own memory Resources Shares the same resources as other threads in the same process Has its own resources Performance Typically better than process Typically worse than threads Security Less secure than processes More secure than threads "},"title":"Thread vs Process"},"/notes/aws_connection/":{"data":{"":"scp -ri /Users/xxxxxxxxxx/.ssh/xxx_xx.pem ./local_foler ec2-user@ec2-22-222-22-222.us-east-2.compute.amazonaws.com:~/\n"},"title":"AWS"},"/notes/colab_tips/":{"data":{"":"colab tips Seems like colab is popular, so I wanted to share maybe some useful tips that helped me streamline my setup/workflow:\na) If you cloned the notebook and are using gdrive to store the data, you can only mount gdrive using the python package, which requires entering a new oauth code for each session; if you create a new notebook, it actually persists the mount between sessions. You can just copy the contents over - https://datascience.stackexchange.com/questions/64486/how-to-automatically-mount-my-google-drive-to-google-colab\nb) You can run this code in a cell to extend sessions (prevent timeouts); it also doesn\u0026rsquo;t majorly use the CPU unnecessarily. Still, as this SO points out, it\u0026rsquo;s not morally right to hog up a GPU/CPU if you\u0026rsquo;re not using it. I use it when I\u0026rsquo;m actively developing over ssh, but not running anything on the notebook.\nimport time while True: time.sleep(10) c) You can ssh into the machine; someone even made a package for that - https://pypi.org/project/colab-ssh/#description. I usually use ipdb to do REPL-driven development and explore the data, so this is really useful for me since I can\u0026rsquo;t run this workload locally. Head\u0026rsquo;s up - it does take a bit of setup, but if you persist the extra python packages and the authorized_hosts file, you can get it up and running for new sessions quickly.\nimport os import sys # set up persistent pip library path nb_path = \u0026#39;/content/drive/My Drive/Colab Notebooks/pip\u0026#39; !mkdir -p \u0026#39;{nb_path}\u0026#39; sys.path.insert(0, nb_path) !pip install --target=\u0026#39;{nb_path}\u0026#39; ipdb !pip install --target=\u0026#39;{nb_path}\u0026#39; colab_ssh --upgrade !ln -sr /content/drive/MyDrive/nlp-qa-finalproj/.ssh ~/ !cat ~/.ssh/authorized_keys Hope this helps, good luck!\n"},"title":"colab_tips"},"/notes/colab_upload/":{"data":{"":"import os from getpass import getpass import urllib\nuser = input(\u0026lsquo;User name: \u0026lsquo;) password = getpass(\u0026lsquo;Password: \u0026lsquo;) password = urllib.parse.quote(password) # your password is converted into url format repo_name = \u0026ldquo;gregdurrett/nlp-qa-finalproj.git\u0026rdquo; cmd_string = \u0026lsquo;git clone https://{0}:{1}@github.com/{2}\u0026rsquo;.format(user, password, repo_name)\n!{cmd_string}\n"},"title":"colab_upload"},"/notes/conda/":{"data":{"":"conda env list conda create -n dl1 python=3.8 \u0026ndash;no-default-packages conda env remove -n ENV_NAME\n"},"title":"conda"},"/notes/cpp/":{"data":{"":"","assert#assert":"","c-const#c++ const":" link // value of x and y can be altered // x = 9; y = \u0026#39;A\u0026#39;; // value of i and j can be altered // i = \u0026amp;m; j = \u0026amp;n; // !!! value of *i and *j cannot be altered // *i = 6; *j = 7; // read-only variable is not assignable const int* i = \u0026amp;x; const char* j = \u0026amp;y; // value of x and y can be altered // x = 9; y = \u0026#39;A\u0026#39;; // !!! value of i and j cannot be altered // i = \u0026amp;m; j = \u0026amp;n; // variable \u0026#39;i\u0026#39; and \u0026#39;j\u0026#39; declared const here // value of *i and *j can be altered // *i = 6; *j = \u0026#39;A\u0026#39;; int* const i = \u0026amp;x; char* const j = \u0026amp;y; // value of x and y can be altered // x = 9; y = \u0026#39;A\u0026#39;; // !!! value of i and j cannot be altered // i = \u0026amp;m; j = \u0026amp;n; // !!! value of *i and *j cannot be altered // *i = 6; *j = 7; const int* const i = \u0026amp;x; const char* const j = \u0026amp;y; The compile-time error that will appear as if const value is passed to any non-const argument of the function\nint foo(int* y) { return *y; } int main() { int z = 8; const int* x = \u0026amp;z; std::cout \u0026lt;\u0026lt; foo(x) \u0026lt;\u0026lt; std::endl; return 0; } // error: no matching function for call to \u0026#39;foo\u0026#39; // candidate function not viable: 1st argument (\u0026#39;const int *\u0026#39;) would lose const qualifier const int foo(int* y) { return *y; } int main() { int z = 8; const int* x = \u0026amp;z; std::cout \u0026lt;\u0026lt; foo(x) \u0026lt;\u0026lt; std::endl; return 0; } // Function foo() with variable // const int void foo(const int y) { // y = 6; const value // can\u0026#39;t be change cout \u0026lt;\u0026lt; y; } // Function foo() with variable int void foo1(int y) { // Non-const value can be change y = 5; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; y; } // Driver Code int main() { int x = 9; const int z = 10; foo(z); foo1(x); return 0; } const return\n// int foo(int y) { // no error // const int foo(int y) { // no error const int foo(const int y) { // error: cannot assign to variable \u0026#39;y\u0026#39; with const-qualified type \u0026#39;const int\u0026#39; --y; return y; } int main() { int x = 9; const int z = 10; std::cout \u0026lt;\u0026lt; foo(x) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; foo(z); return 0; } An object declared as const cannot be modified and hence, can invoke only const member functions as these functions ensure not to modify the object.\nWhen a function is declared as const, it can be called on any type of object, const object as well as non-const objects.\nclass Test { public: // Constructor Test(int v = 0) { value = v; } // this const means cannot modify class members, e.g. value // We get compiler error if we add a line like \u0026#34;value = 100;\u0026#34; // in this function. int getValue() const { return value; } // a nonconst function trying to modify value void setValue(int val) { value = val; } private: int value; }; // Driver Code int main() { // Object of the class T Test t(20); // non-const object invoking const function, no error cout \u0026lt;\u0026lt; t.getValue() \u0026lt;\u0026lt; endl; // const object const Test t_const(10); // const object invoking const function, no error cout \u0026lt;\u0026lt; t_const.getValue() \u0026lt;\u0026lt; endl; // const object invoking non-const function, CTE // t_const.setValue(15); // non-const object invoking non-const function, no error t.setValue(12); cout \u0026lt;\u0026lt; t.getValue() \u0026lt;\u0026lt; endl; return 0; } ","c20-comparison-operator#C++20 comparison operator":"struct Point { int x; int y; Point() : x(0), y(0) {} Point(int a, int b) : x(a), y(b) {} // !!! have to write it this way: inline bool operator== (const Point\u0026amp; other) const { return x == other.x \u0026amp;\u0026amp; y == other.y; } }; ","customized-hash-for-unordered_map-or-unordered_set#customized hash for unordered_map or unordered_set":"struct pair_hash { template \u0026lt;class T1, class T2\u0026gt; std::size_t operator () (const std::pair\u0026lt;T1,T2\u0026gt; \u0026amp;p) const { auto h1 = std::hash\u0026lt;T1\u0026gt;{}(p.first); auto h2 = std::hash\u0026lt;T2\u0026gt;{}(p.second); // Mainly for demonstration purposes, i.e. works but is overly simple // In the real world, use sth. like boost.hash_combine return h1 ^ (h2 \u0026lt;\u0026lt; 1); } }; int main() { std::unordered_map\u0026lt;std::pair\u0026lt;int, int\u0026gt;, int, pair_hash\u0026gt; pos_index_map; return 0; } ","element-wise-comparison-of-two-structs#element wise comparison of two structs":"struct Point { float x; float y; Point(int x = 0, int y = 0) : x(x), y(y) {} }; int main() { Point p1 = Point(1, 2); Point p2 = Point(2, 1); // std::tie can have any many parameters as it wants if (std::tie(p1.x, p2.x) == std::tie(p2.y, p1.y)) { std::cout \u0026lt;\u0026lt; \u0026#34;haha\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;nono\u0026#34; \u0026lt;\u0026lt; std::endl; } } ","function-pointer-in-c#function pointer in c++":"int sum(int a, int b) { return a + b; } int prod(int a, int b) { return a * b; } int shouldNotBeChanged(int (*operation)(int, int)) { srand(time(nullptr)); int a = rand() % 100; int b = rand() % 100; printf(\u0026#34;The result of the operation between %d and %d is %d\\n\u0026#34;, a, b, operation(a, b)); return 0; } int main() { shouldNotBeChanged(\u0026amp;sum); return 0; } ","gtest-with-cmake#gtest with cmake":"","hashmap-implementation#HashMap Implementation":" leetcode 705 design hashset // C++ ","how-to-use-c-build-in-hash-function#how to use c++ build-in hash function":" size_t h1 = std::hash\u0026lt;char\u0026gt;()(\u0026#39;a\u0026#39;); size_t h2 = std::hash\u0026lt;char\u0026gt;()(\u0026#39;b\u0026#39;); std::unordered_map\u0026lt;std::string, int\u0026gt; myhash; std::unordered_map\u0026lt;std::string, int\u0026gt;::hasher fn = myhash.hash_function(); std::cout \u0026lt;\u0026lt; fn(\u0026#34;apple\u0026#34;) \u0026lt;\u0026lt; std::endl; ","largest-divisible-subsethttpswwwjiuzhangcomproblemlargest-divisible-subset#\u003ca href=\"https://www.jiuzhang.com/problem/largest-divisible-subset/\"\u003eLargest Divisible Subset\u003c/a\u003e":"assert #include\u0026lt;cassert\u0026gt; assert((expression) \u0026amp;\u0026amp; \u0026#34;msg\u0026#34;) assert(expression); // cannot be std::assert(expression) try throw catch - error handling try { // do something that might throw an error throw std::invalid_argument(\u0026#34;MyFunc argument too large.\u0026#34;); } catch (const std::exception\u0026amp; e) { // handle the error std::cout \u0026lt;\u0026lt; \u0026#34;3333\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; std::cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; // return -1; } gtest with cmake gtest helloworld step 1: mkdir my_project \u0026amp;\u0026amp; cd my_project step 2: CMakeLists.txt # within CMakeLists.txt cmake_minimum_required(VERSION 3.14) project(my_project) # GoogleTest requires at least C\u0026#43;\u0026#43;14 set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED ON) include(FetchContent) FetchContent_Declare( googletest URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip ) # For Windows: Prevent overriding the parent project\u0026#39;s compiler/linker settings set(gtest_force_shared_crt ON CACHE BOOL \u0026#34;\u0026#34; FORCE) FetchContent_MakeAvailable(googletest) step 3: test fucntions #include \u0026lt;gtest/gtest.h\u0026gt; // Demonstrate some basic assertions. TEST(HelloTest, BasicAssertions) { // Expect two strings not to be equal. EXPECT_STRNE(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); // Expect equality. EXPECT_EQ(7 * 6, 42); } step 4: Append to CMakeLists.txt enable_testing() add_executable( hello_test hello_test.cc ) target_link_libraries( hello_test GTest::gtest_main ) include(GoogleTest) gtest_discover_tests(hello_test) step 5: build and run test my_project$ cmake -S . -B build -- The C compiler identification is GNU 10.2.1 -- The CXX compiler identification is GNU 10.2.1 ... -- Build files have been written to: .../my_project/build my_project$ cmake --build build Scanning dependencies of target gtest ... [100%] Built target gmock_main my_project$ cd build \u0026amp;\u0026amp; ctest Test project .../my_project/build Start 1: HelloTest.BasicAssertions 1/1 Test #1: HelloTest.BasicAssertions ........ Passed 0.00 sec 100% tests passed, 0 tests failed out of 1 Total Test time (real) = 0.01 sec print vector to the console std::copy(v.begin(), v.end(), std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026#34; \u0026#34;)); priority queue 1507 Shortest Subarray with Sum at Least K 和至少为 K 的最短子数组 [[https://www.lintcode.com/problem/1507/][Lintcode 1507 Shortest Subarray with Sum at Least K]]\nBinary search on answer + priority_queue class Solution { public: int shortestSubarray(std::vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { std::vector\u0026lt;int\u0026gt; prefix_sum = GetPrefixSum(A); int left = 1; int right = A.size(); while (left + 1 \u0026lt; right) { int mid = left + (right - left) / 2; if (IsValid(prefix_sum, mid, K)) { right = mid; } else { left = mid; } } if (IsValid(prefix_sum, left, K)) { return left; } if (IsValid(prefix_sum, right, K)) { return right; } return -1; } private: std::vector\u0026lt;int\u0026gt; GetPrefixSum(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;int\u0026gt; answer(nums.size() + 1, 0); for (int i = 0; i \u0026lt; nums.size(); ++i) { answer[i + 1] = answer[i] + nums[i]; } return answer; } bool IsValid(std::vector\u0026lt;int\u0026gt;\u0026amp; prefix_sum, int length, int K) { auto cmp = [](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a, const std::pair\u0026lt;int, int\u0026gt;\u0026amp; b) { return a.second \u0026gt; b.second; }; std::set\u0026lt;std::pair\u0026lt;int, int\u0026gt;, decltype(cmp)\u0026gt; pq(cmp); // c++20 pq; c++11 pq(cmp) for (int end = 0; end \u0026lt; prefix_sum.size(); ++end) { int index = end - length - 1; if (index \u0026gt;= 0) { pq.erase(std::find_if(pq.begin(), pq.end(), [\u0026amp;index](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a) { return a.first == index; })); } if (!pq.empty() \u0026amp;\u0026amp; prefix_sum[end] - pq.rbegin()-\u0026gt;second \u0026gt;= K) { return true; } pq.insert(std::make_pair(end, prefix_sum[end])); } return false; } }; LRU implementation // C++ #include \u0026lt;unordered_map\u0026gt; struct LinkedNode { LinkedNode(int key, int value, LinkedNode* next) : key(key), value(value), next(next) {} int key; int value; LinkedNode* next; }; class LRUCache { public: LRUCache(int capacity) : capacity_(capacity), dummy_(new LinkedNode(0, 0, nullptr)), tail_(dummy_) {} // Google style: Get int Get(int key) { if (key_to_previous_.find(key) == key_to_previous_.end()) { return -1; } LinkedNode* previous = key_to_previous_.at(key); LinkedNode* current = previous-\u0026gt;next; Kick(previous); return current-\u0026gt;value; } // Google style: Set void Set(int key, int value) { if (key_to_previous_.find(key) != key_to_previous_.end()) { Kick(key_to_previous_.at(key)); tail_-\u0026gt;value = value; return; } PushBack(new LinkedNode(key, value, nullptr)); // 如果key不存在，则存入新节点 if (key_to_previous_.size() \u0026gt; capacity_) { // 如果缓存超出上限 PopFront(); } } private: void PushBack(LinkedNode* node) { key_to_previous_[node-\u0026gt;key] = tail_; tail_-\u0026gt;next = node; tail_ = node; } void PopFront() { // 删除头部 LinkedNode* head = dummy_-\u0026gt;next; key_to_previous_.erase(head-\u0026gt;key); dummy_-\u0026gt;next = head-\u0026gt;next; key_to_previous_[head-\u0026gt;next-\u0026gt;key] = dummy_; } // change \u0026#34;previous-\u0026gt;node-\u0026gt;next-\u0026gt;...-\u0026gt;tail_\u0026#34; // to \u0026#34;previous-\u0026gt;next-\u0026gt;...-\u0026gt;tail_-\u0026gt;node\u0026#34; void Kick(LinkedNode* previous) { // 将数据移至尾部 LinkedNode* node = previous-\u0026gt;next; if (node == tail_) { return; } // update the current node from linked list previous-\u0026gt;next = node-\u0026gt;next; // update the previous node in hash map key_to_previous_[node-\u0026gt;next-\u0026gt;key] = previous; node-\u0026gt;next = nullptr; PushBack(node); } int capacity_; LinkedNode* dummy_; LinkedNode* tail_; std::unordered_map\u0026lt;int, LinkedNode*\u0026gt; key_to_previous_; }; LIS Longest Increasing Subsequence 接龙规则：从左到右一个比一个大，该问题简称 LIS 状态表示： A：dp[i] 表示前i个数的 LIS 是多长(前缀型, do not choose this) B：dp[i] 表示以第i个数结尾的 LIS 是多长(坐标型) LIS 的动态规划四要素 state: dp[i]表示以第i个数为龙尾的最长的龙有多长 function: dp[i] = max{dp[j] + 1}, j \u0026lt; i \u0026amp;\u0026amp; nums[j] \u0026lt; nums[i] initialization: dp[0..n-1] = 1 answer: max{dp[0..n-1]} def longestIncreasingSubsequence(self, nums): if nums is None or not nums: return 0 # state: dp[i] 表示以第i个数结尾的LIS的长度 # initialization：dp[0..n-1] = 1 dp = [1] * len(nums) # function: dp[i] = max(dp[i] + 1), j \u0026lt; i \u0026amp;\u0026amp; nums[j] \u0026lt; nums[i] for i in range(len(nums)): for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) # answer, 任意一个位置都可能是LIS的结尾 return max(dp) 改动要点(返回最优方案) prev 数组记录前继最优状态 max() 的写法要改为 if 的写法 找到最长龙的结尾，从结尾倒推出整条龙 def longestIncreasingSubsequence(self, nums): if nums is None or not nums: return 0 # state: dp[i] 表示以第i个数结尾的LIS的长度 # initialization：dp[0..n-1] = 1 dp = [1] * len(nums) # prev[i]代表dp[i]的最优值是从哪个dp[j]算过来的 prev = [-1] * len(nums) # function dp[i] = max{dp[j] + 1}, j \u0026lt; i and nums[j] \u0026lt; nums[i] for i in range(len(nums)): for j in range(i): if nums[j] \u0026lt; nums[i] and dp[i] \u0026lt; dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j # answer: max(dp[0..n-1]) longest, last = 0, -1 for i in range(len(nums)): if dp[i] \u0026gt; longest: longest = dp[i] last = i path = [] while last != -1 path.append(nums[last]) last = prev[last] print(path[::-1]) return longest LIS2 Longest Continuous Increasing Subsequence 2 class Solution: \u0026#34;\u0026#34;\u0026#34; @param A: An integer matrix @return: an integer \u0026#34;\u0026#34;\u0026#34; def longestContinuousIncreasingSubsequence2(self, A): if not A or not A[0]: return 0 n, m = len(A), len(A[0]) points = [] for i in range(n): for j in range(m): points.append((A[i][j], i, j)) points.sort() longest_hash = {} for i in range(len(points)): key = (points[i][1], points[i][2]) longest_hash[key] = 1 for dx, dy in [(1, 0), (0, -1), (-1, 0), (0, 1)]: x, y = points[i][1] + dx, points[i][2] + dy if x \u0026lt; 0 or x \u0026gt;= n or y \u0026lt; 0 or y \u0026gt;= m: continue if (x, y) in longest_hash and A[x][y] \u0026lt; points[i][0]: longest_hash[key] = max(longest_hash[key], longest_hash[(x, y)] + 1) return max(longest_hash.values()) Largest Divisible Subset class Solution: def largestDivisibleSubset(self, nums): if not nums: return [] nums = sorted(nums) n = len(nums) dp, prev = {}, {} for num in nums: dp[num] = 1 prev[num] = -1 last_num = nums[0] for num in nums: for factor in self.get_smaller_factors(num): if factor not in dp: continue if dp[num] \u0026lt; dp[factor] + 1: dp[num] = dp[factor] + 1 prev[num] = factor if dp[num] \u0026gt; dp[last_num]: last_num = num return self.get_path(prev, last_num) def get_smaller_factors(self, num): if num == 1: return [] factor = 1 factors = [] while factor * factor \u0026lt;= num: if num % factor == 0: factors.append(factor) if factor * factor != num and factor != 1: factors.append(num // factor) factor += 1 return factors def get_path(self, prev, last_num): path = [] while last_num != -1: path.append(last_num) last_num = prev[last_num] return path[::-1] ","lis-longest-increasing-subsequencehttpswwwjiuzhangcomproblemlongest-increasing-subsequence#\u003ca href=\"https://www.jiuzhang.com/problem/longest-increasing-subsequence/\"\u003eLIS Longest Increasing Subsequence\u003c/a\u003e":"","lis2-longest-continuous-increasing-subsequence-2httpswwwjiuzhangcomproblemlongest-continuous-increasing-subsequence-ii#\u003ca href=\"https://www.jiuzhang.com/problem/longest-continuous-increasing-subsequence-ii/\"\u003eLIS2 Longest Continuous Increasing Subsequence 2\u003c/a\u003e":"","lru-implementationhttpswwwlintcodecomproblem134#\u003ca href=\"https://www.lintcode.com/problem/134/\"\u003eLRU implementation\u003c/a\u003e":"","print-vector-to-the-console#print vector to the console":"","priority-queue#priority queue":"","random-seed#random seed":"3407","return-min-or-max-element-from-hashmap#return min or max element from hashmap":"auto cmp = [](const auto\u0026amp; a, const auto\u0026amp; b) {return a.second \u0026lt; b.second;}; min_value = min_element(my_map.begin(), my_map.end(), cmp)-\u0026gt;second; ","sort-lambda#sort lambda":" auto sortRuleLambda = [](const Skyscraper\u0026amp; s1, const Skyscraper\u0026amp; s2) -\u0026gt; bool { return s1.height() \u0026lt; s2.height(); }; std::sort(skyscrapers.begin(), skyscrapers.end(), sortRuleLambda); ","to-initialize-two-dimentional-array#To initialize two dimentional array":" we cannot iterate \u0026lsquo;priority_queue\u0026rsquo;, but we can make a copy of it and then use \u0026lsquo;pop\u0026rsquo; and \u0026rsquo;top()\u0026rsquo; to iterate #include\u0026lt;iostream\u0026gt; int main() { int** secondStore; secondStore = new int*[10]; for (int i = 0; i \u0026lt; 10; ++i) { secondStore[i] = new int[32]; } std::cout \u0026lt;\u0026lt; secondStore[0][0] \u0026lt;\u0026lt; std::endl; return 0; } ## heap: set vs priority_queue ```c++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; int main() { auto cmp = [](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a, const std::pair\u0026lt;int, int\u0026gt;\u0026amp; b) {return a.first \u0026gt; b.first;}; std::set\u0026lt;std::pair\u0026lt;int, int\u0026gt;, decltype(cmp)\u0026gt; my_heap_with_set(cmp); // get min heap // std::priority_queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::deque\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;, decltype(cmp)\u0026gt; my_heap_with_priority_queue(cmp); // get max heap std::priority_queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::deque\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; my_heap_with_priority_queue; // get max heap my_heap_with_set.insert(std::make_pair(3, 1)); my_heap_with_set.insert(std::make_pair(2, 1)); my_heap_with_set.insert(std::make_pair(4, 1)); my_heap_with_set.insert(std::make_pair(0, 1)); my_heap_with_priority_queue.push({3, 1}); my_heap_with_priority_queue.push({2, 1}); my_heap_with_priority_queue.push({4, 1}); my_heap_with_priority_queue.push({0, 1}); auto it = my_heap_with_set.begin(); std::cout \u0026lt;\u0026lt; \u0026#34;my_set: \u0026#34; \u0026lt;\u0026lt; std::endl;; for (; it != my_heap_with_set.end(); ++it) { std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;my_priority_queue: \u0026#34; \u0026lt;\u0026lt; std::endl; for (; !my_heap_with_priority_queue.empty(); my_heap_with_priority_queue.pop()) { std::cout \u0026lt;\u0026lt; my_heap_with_priority_queue.top().first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; my_heap_with_priority_queue.top().second \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;test map iteration: \u0026#34; \u0026lt;\u0026lt; std::endl; auto cmp2 = [](const int\u0026amp; a, const int\u0026amp; b) {return a \u0026gt; b;}; std::map\u0026lt;int, int, decltype(cmp2)\u0026gt; my_map(cmp2); my_map[0] = 12; my_map[1] = 15; my_map[1111] = 111; for (auto i : my_map) { // works std::cout \u0026lt;\u0026lt; i.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; std::endl; // for (auto it = my_map.begin(); it != my_map.end(); ++it) { // works // std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;test max_element for map: \u0026#34; \u0026lt;\u0026lt; std::endl; auto cmp_max_element = [](const auto\u0026amp; a, const auto\u0026amp; b) {return a.second \u0026gt; b.second;}; // be aware that we should use \u0026#39;-\u0026gt;second\u0026#39; at the end, becuase max_element return iterator int temp = max_element(my_map.begin(), my_map.end(), cmp_max_element)-\u0026gt;second; std::cout \u0026lt;\u0026lt; temp \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; return 0; } ","try-throw-catch---error-handling#try throw catch - error handling":""},"title":"cpp"},"/notes/cuda/":{"data":{"":"","cuda-syntax#CUDA syntax":" cuda syntax Source code is in .cu files, which contain mixture of host (CPU) and device (GPU) code. Declaring functions __global__ declares kernel, which is called on host and executed on device __device__ declares device function, which is called and executed on device __host__ declares host function, which is called and executed on host __noinline__ to avoid inlining __forceinline__\tto force inlining Declaring variables __device__ declares device variable in global memory, accessible from all threads, with lifetime of application __constant__\tdeclares device variable in constant memory, accessible from all threads, with lifetime of application __shared__ declares device varibale in block\u0026#39;s shared memory, accessible from all threads within a block, with lifetime of block __restrict__\tstandard C definition that pointers are not aliased Types Most routines return an error code of type cudaError_t.\nVector types char1, uchar1, short1, ushort1, int1, uint1, long1, ulong1, float1 char2, uchar2, short2, ushort2, int2, uint2, long2, ulong2, float2 char3, uchar3, short3, ushort3, int3, uint3, long3, ulong3, float3 char4, uchar4, short4, ushort4, int4, uint4, long4, ulong4, float4 longlong1, ulonglong1, double1 longlong2, ulonglong2, double2 dim3 Components are accessible as variable.x, variable.y, variable.z, variable.w. Constructor is make_\u0026lt;type\u0026gt;( x, ... ), for example: float2 xx = make_float2( 1., 2. ); dim3 can take 1, 2, or 3 argumetns: dim3 blocks1D( 5 ); dim3 blocks2D( 5, 5 ); dim3 blocks3D( 5, 5, 5 ); Pre-defined variables dim3 gridDim dimensions of grid dim3 blockDim dimensions of block uint3 blockIdx block index within grid uint3 threadIdx\tthread index within block int warpSize number of threads in warp Kernel invocation __global__ void kernel( ... ) { ... } dim3 blocks( nx, ny, nz ); // cuda 1.x has 1D and 2D grids, cuda 2.x adds 3D grids dim3 threadsPerBlock( mx, my, mz ); // cuda 1.x has 1D, 2D, and 3D blocks kernel\u0026lt;\u0026lt;\u0026lt; blocks, threadsPerBlock \u0026gt;\u0026gt;\u0026gt;( ... ); Thread management __threadfence_block(); wait until memory accesses are visible to block __threadfence(); wait until memory accesses are visible to block and device __threadfence_system();\twait until memory accesses are visible to block and device and host (2.x) __syncthreads(); wait until all threads reach sync Memory management __device__ float* pointer; cudaMalloc( (void**) \u0026amp;pointer, size ); cudaFree( pointer ); __constant__ float dev_data[n]; float host_data[n]; cudaMemcpyToSymbol ( dev_data, host_data, sizeof(host_data) ); // dev_data = host_data cudaMemcpyFromSymbol( host_data, dev_data, sizeof(host_data) ); // host_data = dev_data // direction is one of cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost cudaMemcpy ( dst_pointer, src_pointer, size, direction ); cudaMemcpyAsync( dst_pointer, src_pointer, size, direction, stream ); // using column-wise notation // (the CUDA docs describe it for images; a “row” there equals a matrix column) // _bytes indicates arguments that must be specified in bytes cudaMemcpy2D ( A_dst, lda_bytes, B_src, ldb_bytes, m_bytes, n, direction ); cudaMemcpy2DAsync( A_dst, lda_bytes, B_src, ldb_bytes, m_bytes, n, direction, stream ); // cublas makes copies easier for matrices, e.g., less use of sizeof // copy x =\u0026gt; y cublasSetVector ( n, elemSize, x_src_host, incx, y_dst_dev, incy ); cublasGetVector ( n, elemSize, x_src_dev, incx, y_dst_host, incy ); cublasSetVectorAsync( n, elemSize, x_src_host, incx, y_dst_dev, incy, stream ); cublasGetVectorAsync( n, elemSize, x_src_dev, incx, y_dst_host, incy, stream ); // copy A =\u0026gt; B cublasSetMatrix ( rows, cols, elemSize, A_src_host, lda, B_dst_dev, ldb ); cublasGetMatrix ( rows, cols, elemSize, A_src_dev, lda, B_dst_host, ldb ); cublasSetMatrixAsync( rows, cols, elemSize, A_src_host, lda, B_dst_dev, ldb, stream ); cublasGetMatrixAsync( rows, cols, elemSize, A_src_dev, lda, B_dst_host, ldb, stream ); Also, malloc and free work inside a kernel (2.x), but memory allocated in a kernel must be deallocated in a kernel (not the host). It can be freed in a different kernel, though. Atomic functions old = atomicAdd ( \u0026amp;addr, value ); // old = *addr; *addr += value old = atomicSub ( \u0026amp;addr, value ); // old = *addr; *addr –= value old = atomicExch( \u0026amp;addr, value ); // old = *addr; *addr = value old = atomicMin ( \u0026amp;addr, value ); // old = *addr; *addr = min( old, value ) old = atomicMax ( \u0026amp;addr, value ); // old = *addr; *addr = max( old, value ) // increment up to value, then reset to 0 // decrement down to 0, then reset to value old = atomicInc ( \u0026amp;addr, value ); // old = *addr; *addr = ((old \u0026gt;= value) ? 0 : old+1 ) old = atomicDec ( \u0026amp;addr, value ); // old = *addr; *addr = ((old == 0) or (old \u0026gt; val) ? val : old–1 ) old = atomicAnd ( \u0026amp;addr, value ); // old = *addr; *addr \u0026amp;= value old = atomicOr ( \u0026amp;addr, value ); // old = *addr; *addr |= value old = atomicXor ( \u0026amp;addr, value ); // old = *addr; *addr ^= value // compare-and-store old = atomicCAS ( \u0026amp;addr, compare, value ); // old = *addr; *addr = ((old == compare) ? value : old) Warp vote int __all ( predicate ); int __any ( predicate ); int __ballot( predicate ); // nth thread sets nth bit to predicate Timer wall clock cycle counter\nclock_t clock(); Texture can also return float2 or float4, depending on texRef.\n// integer index float tex1Dfetch( texRef, ix ); // float index float tex1D( texRef, x ); float tex2D( texRef, x, y ); float tex3D( texRef, x, y, z ); float tex1DLayered( texRef, x ); float tex2DLayered( texRef, x, y ); Low-level Driver API #include \u0026lt;cuda.h\u0026gt; CUdevice dev; CUdevprop properties; char name[n]; int major, minor; size_t bytes; cuInit( 0 ); // takes flags for future use cuDeviceGetCount ( \u0026amp;cnt ); cuDeviceGet ( \u0026amp;dev, index ); cuDeviceGetName ( name, sizeof(name), dev ); cuDeviceComputeCapability( \u0026amp;major, \u0026amp;minor, dev ); cuDeviceTotalMem ( \u0026amp;bytes, dev ); cuDeviceGetProperties ( \u0026amp;properties, dev ); // max threads, etc. cuBLAS Matrices are column-major. Indices are 1-based; this affects result of iamax and iamin.\n#include \u0026lt;cublas_v2.h\u0026gt; cublasHandle_t handle; cudaStream_t stream; cublasCreate( \u0026amp;handle ); cublasDestroy( handle ); cublasGetVersion( handle, \u0026amp;version ); cublasSetStream( handle, stream ); cublasGetStream( handle, \u0026amp;stream ); cublasSetPointerMode( handle, mode ); cublasGetPointerMode( handle, \u0026amp;mode ); Constants argument\tconstants\tdescription (Fortran letter) trans\tCUBLAS_OP_N non-transposed (\u0026#39;N\u0026#39;) CUBLAS_OP_T transposed (\u0026#39;T\u0026#39;) CUBLAS_OP_C conjugate transposed (\u0026#39;C\u0026#39;) uplo\tCUBLAS_FILL_MODE_LOWER lower part filled (\u0026#39;L\u0026#39;) CUBLAS_FILL_MODE_UPPER upper part filled (\u0026#39;U\u0026#39;) side\tCUBLAS_SIDE_LEFT matrix on left (\u0026#39;L\u0026#39;) CUBLAS_SIDE_RIGHT matrix on right (\u0026#39;R\u0026#39;) mode\tCUBLAS_POINTER_MODE_HOST alpha and beta scalars passed on host CUBLAS_POINTER_MODE_DEVICE\talpha and beta scalars passed on device BLAS functions have cublas prefix and first letter of usual BLAS function name is capitalized. Arguments are the same as standard BLAS, with these exceptions:\nAll functions add handle as first argument. All functions return cublasStatus_t error code. Constants alpha and beta are passed by pointer. All other scalars (n, incx, etc.) are bassed by value. Functions that return a value, such as ddot, add result as last argument, and save value to result. Constants are given in table above, instead of using characters.\nExamples:\ncublasDdot ( handle, n, x, incx, y, incy, \u0026amp;result ); // result = ddot( n, x, incx, y, incy ); cublasDaxpy( handle, n, \u0026amp;alpha, x, incx, y, incy ); // daxpy( n, alpha, x, incx, y, incy ); Compiler nvcc, often found in /usr/local/cuda/bin\nDefines __CUDACC__ Flags common with cc Short flag\tLong flag\tOutput or Description -c\t--compile\t.o object file -E\t--preprocess\ton standard output -M\t--generate-dependencies\ton standard output -o file\t--output-file file -I directory\t--include-path directory\theader search path -L directory\t--library-path directory\tlibrary search path -l lib\t--library lib\tlink with library -lib\tgenerate library -shared\tgenerate shared library -pg\t--profile\tfor gprof -g level\t--debug level -G\t--device-debug -O level\t--optimize level Undocumented (but in sample makefiles) -m32\tcompile 32-bit i386 host CPU code -m64\tcompile 64-bit x86_64 host CPU code Flags specific to nvcc -v\tlist compilation commands as they are executed -dryrun\tlist compilation commands, without executing -keep\tsaves intermediate files (e.g., pre-processed) for debugging -clean\tremoves output files (with same exact compiler options) -arch=\u0026lt;compute_xy\u0026gt;\tgenerate PTX for capability x.y -code=\u0026lt;sm_xy\u0026gt;\tgenerate binary for capability x.y, by default same as -arch -gencode arch=...,code=...\tsame as -arch and -code, but may be repeated Argumenents for -arch and -code It makes most sense (to me) to give -arch a virtual architecture and -code a real architecture, though both flags accept both virtual and real architectures (at times).\nVirtual architecture\tReal architecture\tFeatures Tesla\tcompute_10\tsm_10\tBasic features compute_11\tsm_11\t\u0026#43; atomic memory ops on global memory compute_12\tsm_12\t\u0026#43; atomic memory ops on shared memory \u0026#43; vote instructions compute_13\tsm_13\t\u0026#43; double precision Fermi\tcompute_20\tsm_20\t\u0026#43; Fermi ","some-hardware-constraints#Some hardware constraints":" 1.x\t2.x max x- or y-dimension of block\t512\t1024 max z-dimension of block\t64\t64 max threads per block\t512\t1024 warp size\t32\t32 max blocks per MP\t8\t8 max warps per MP\t32\t48 max threads per MP\t1024\t1536 max 32-bit registers per MP\t16k\t32k max shared memory per MP\t16 KB\t48 KB shared memory banks\t16\t32 local memory per thread\t16 KB\t512 KB const memory\t64 KB\t64 KB const cache\t8 KB\t8 KB texture cache\t8 KB\t8 KB ","which-machine-learning-algorithms-can-be-optimized-with-cuda#Which machine learning algorithms can be optimized with CUDA?":"CUDA (Compute Unified Device Architecture) is a parallel computing platform and application programming interface (API) created by NVIDIA for utilizing their GPUs (Graphics Processing Units) to accelerate various computational tasks, including machine learning. Many machine learning algorithms can be optimized with CUDA to take advantage of GPU parallelism, which can significantly speed up training and inference. Here are some common machine learning algorithms that can benefit from CUDA optimization:\nDeep Learning Algorithms:\nConvolutional Neural Networks (CNNs): Used in image and video analysis, CNNs can be accelerated with CUDA for image recognition, object detection, and more. Recurrent Neural Networks (RNNs): RNNs, especially in natural language processing tasks, can benefit from GPU acceleration. Support Vector Machines (SVM): SVMs are used for classification and regression tasks. Training large SVMs can be time-consuming, and CUDA can speed up the process.\nk-Nearest Neighbors (k-NN): CUDA can accelerate the distance calculations required in k-NN algorithms.\nRandom Forests: Implementations of random forests can be parallelized on GPUs for faster training.\nGradient Boosting Algorithms: Some gradient boosting libraries, like XGBoost and LightGBM, have GPU support to speed up boosting algorithms\u0026rsquo; training.\nMatrix Factorization: Algorithms like Singular Value Decomposition (SVD) and Alternating Least Squares (ALS) used in recommendation systems can benefit from GPU acceleration.\nClustering Algorithms: Algorithms like K-means clustering and DBSCAN can be optimized with CUDA to speed up clustering tasks on large datasets.\nPrincipal Component Analysis (PCA): PCA, a dimensionality reduction technique, can be accelerated with CUDA when working with high-dimensional data.\nNon-negative Matrix Factorization (NMF): NMF is used in various applications like topic modeling and image processing and can be accelerated using CUDA.\nEnsemble Methods: Bagging and boosting techniques that involve multiple base models can be optimized with CUDA.\nAnomaly Detection Algorithms: Algorithms for detecting anomalies in data, such as Isolation Forests, can benefit from GPU acceleration.\nNeural Collaborative Filtering: Used in recommendation systems, this approach can be accelerated with CUDA to improve recommendation speed.\nIt\u0026rsquo;s essential to note that not all machine learning algorithms can be effectively optimized with CUDA. The feasibility of GPU acceleration depends on several factors, including the specific algorithm, the dataset size, and the availability of GPU support in the machine learning libraries or frameworks you are using. Additionally, optimizing machine learning algorithms for CUDA may require expertise in GPU programming and the use of libraries like CUDA, cuDNN, and cuBLAS to take full advantage of the GPU\u0026rsquo;s capabilities.\n"},"title":"cuda"},"/notes/django/":{"data":{"application-definition#Application definition":"//0 virtualenv dj\ncd dj\npip install django\ndjango-admin startproject reports_proj\npython manage.py migrate\npython manage.py createsuperuser\npython manage.py startapp sales\npython manage.py startapp reports\npython manage.py startapp profiles\npython manage.py startapp products\npython manage.py startapp customers\npython manage.py runserver http://127.0.0.1:8000/ //10 pip install pillow django-crispy-forms matplotlib seaborn pandas xhtml2pdf pip freeze pip freeze \u0026gt; requirements.txt\n//15\nsettings.py\nApplication definitionINSTALLED_APPS = [ \u0026hellip;\n# our apps 'customers', 'products', 'profiles', 'reports', 'sales', # 3rd party 'crispy_forms' ]\n","define-crispy-template#define crispy template":"CRISPY_TEMPLATE_PACK = \u0026lsquo;bootstrap4\u0026rsquo;\n\u0026lsquo;DIRS\u0026rsquo;: [BASE_DIR / \u0026rsquo;templates\u0026rsquo;]\nmkdir templates touch base.html touch navbar.html\nSTATICFILES_DIRS = [ BASE_DIR / \u0026lsquo;static\u0026rsquo; ] MEDIA_URL = \u0026lsquo;/media/\u0026rsquo; MEDIA_ROOT = BASE_DIR / \u0026lsquo;media\u0026rsquo;\nmkdir static touch style.css\nmkdir media\nurls.py from django.contrib import admin from django.urls import path, include from django.conf import settings from django.conf.urls.static import static\nurlpatterns = [ path(\u0026lsquo;admin/\u0026rsquo;, admin.site.urls), ]\nurlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT) urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\nbase.html\ncustomers/models.py class Customer(models.models): name = models.CharField(max_length=120) logo = models.ImageField(upload_to=\u0026lsquo;customers\u0026rsquo;, default=\u0026lsquo;no_picture.png\u0026rsquo;)\nmv no_picture.png media\ncustomers/admin.py from .models import Customer\n","register-your-models-here#Register your models here.":"admin.site.register(Customer)\nterminal python manage.py makemigrations python manage.py migrate python manage.py runserver\n"},"title":"django"},"/notes/ds/":{"data":{"":"","auc#AUC":"","bias-vs-variance#Bias vs Variance":"","decision-trree#Decision Trree":"","dimensionality-reduction-algorithms#Dimensionality reduction algorithms":"PCA ","ensemble-learning#Ensemble Learning":"Combined multiple weak models/learners into one predictive model to reduce bias, variance and/or improve accuracy.\nTypes of Ensemble Learning: N number of weak learners Bagging: Trains N different weak models(usually of same types - homogenous) with N non-overlapping subset of the input dataset in parallel. In the test phase, each model is evaluated. The label with the greatest number of predictions is selected as the prediction. Bagging methods reduces variance of the prediction. Simple voting Boosting: Trains N different weak models(usually of same types - homogenous) with the complete dataset in a sequential order. The datapoints wrongly classified with previous weak model is provided more weights to that they an be classified by the next weak learner properly. In the test phase, each model is evaluated and based on the test error of each weak model, the prediction is weighted for voting. Boosting methods decreases the bias of the prediction. Weighted voting Stacking: Trains N different weak models(usually of different types - heterogenous) with one of the two subsets of the dataset in parallel. Once the weak learners are trained, they are used to trained a meta learner to combine their predictions and carry out final prediction using the other subset. In the test phase, each model predicts its label, these set of labels are fed to the meta learner which generates the final prediction. Focus on improving accuracy. Learned voting(meta-learning) ","gradient-boosting-algorithm-and-adaboosting-algorithm#Gradient boosting algorithm and AdaBoosting algorithm":"","handle-imbalanced-data#Handle imbalanced data":"","k-means#K-means":"","knn#KNN":"","l1-vs-l2-regularization#L1 vs L2 regularization":"","likelihood-vs-probability#Likelihood vs Probability":"","linear-regression#Linear Regression":"","logistic-regression#Logistic Regression":"","naive-bayes-algorithm#Naive Bayes Algorithm":"","precision--recall--f1#precision \u0026amp; recall \u0026amp; F1":"","random-forest-algorithm#Random forest algorithm":"Bias vs Variance Low Bias(very sensitive to the training data), (then it performs poorly when we got new data)High Variance \u0026ndash; Overfitting\nHigher Bias(less sensitive to the training data), (then it performs better when we got new data)Low Variance \u0026ndash; Underfitting\nError = bias^2 + variance + inreducible error\nThe best model is where the error is reduced\nCompromise between bias and variance\nSolution: Use Cross Validation\nHandle imbalanced data collect more data to even the imbalances in the dataset resample the dataset to correct for imbalances try a different algorithm altogether on your dataset precision \u0026amp; recall \u0026amp; F1 Precision is a good measure to determine, when the costs of False Positive is high. We know that Recall shall be the model metric we use to select our best model when there is a high cost associated with False Negative. F1 Score might be a better measure to use if we need to seek a balance between Precision and Recall AND there is an uneven class distribution (large number of Actual Negatives). F1: weighted average of the precision and recall of a model. 1 is the best, 0 is the worst. You would use it in classification tests where true negatives don\u0026rsquo;t matter much. AUC 0.5 \u0026lt; ROC \u0026lt; 0.7: Poor discrimination 0.7 ≤ ROC \u0026lt; 0.8: Acceptable discrimination 0.8 ≤ ROC \u0026lt; 0.9: Excellent discrimination ROC ≥ 0.9: Outstanding discrimination\nRegularization Regularization is an approach to address over-fitting in ML. Overfitted model fails to generalize estimations on test data When the underlying model to be learned is low bias/high variance, or when we have small amount of data, the estimated model is prone to over-fitting. Types of Regularization 1. Modify the loss function L2 Regularization: Prevents the weights from getting too large(defined by L2 norm). Larger the weights, more complex the model is, more chances of overfitting. L1 Regularization: Prevents the weights from getting too large(defined by L1 norm). Larger the weights, more complex the model is, more chances of overfitting. L1 Regularization introduces sparsity in the weights. It forces more weights to be zero, than reducing the average magnitude of all weights. Entropy: Used for the models that output probability. Forces the probability distribution towards uniform distribution. 2. Modify data sampling Data augmentation: Create more data from available data by randomly cropping, dialting, rotating, adding small amount of noise, etc. K-fold Cross-validation: Divide the data in to k groups. Train on (k - 1) groups and test on 1 group. Try all k possible combinations. 3. Change training approach Injecting noise: Add random noise to the weights when they are being learned. It pushes the model to be relatively insensitive to small variations in the weights, hence regularization. Dropout: Generally used for neural networks. Connections between consecutive layers are randomly dropped based on a dropout-ratio and the remaining network is trained in the current iteration. In the next iteration, another set of random connections are dropped. L1 vs L2 regularization L2 regularization tends to spread error among all the terms L1 is more binary/sparse, with many variables either being assigned a 1 or 0 in weighting. L1 corresponds to setting a Laplacean prior on the terms L2 corresponds to a Gaussian prior. Type I vs Type II error Type I error is a false positive: claiming something has happened when it hasn\u0026rsquo;t e.g. Telling a man he is pregnant. Type II eeror is a false negative: claiming nothing is happening when in fact something is. e.g. Telling a pregnant woman she isn\u0026rsquo;t carrying a baby. Likelihood vs Probability Linear Regression Logistic Regression Decision Trree SVM Soft Margin The name Support Vector Classifier comes from the fact that the observations on the edge and within the Soft Margin are called Support Vectors. Naive Bayes Algorithm Why \u0026ldquo;Naive\u0026rdquo; Because it makes an assumption: the conditional probabilities is calculated as the pure product of the individual probabilities of components. This implies the absolute independence of features \u0026ndash; a condition probably never met in real life. KNN sort the nearest neighbors of the given point by the distances in increasing order K small K: low bias, high variance, overfitting large K: high bias, low variance, underfitting best K: can be found with cross validation and learning curve Classification \u0026amp; Regression Classification - vote by top k candidates Regression - average of the k nearest neighbors\u0026rsquo; labels as the prediction K-means Random forest algorithm ","regularization#Regularization":"","svm#SVM":"","type-i-vs-type-ii-error#Type I vs Type II error":""},"title":"ds"},"/notes/git/":{"data":{"":"git push --set-upstream origin branchb git branch -m \u0026lt;new name\u0026gt; ","create-a-new-repository-on-the-command-line#create a new repository on the command line":"echo \u0026#34;# yixianwang.github.io\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin git@github.com:yixianwang/yixianwang.github.io.git git push -u origin main ","push-an-existing-repository-from-the-command-line#push an existing repository from the command line":"git remote add origin git@github.com:yixianwang/yixianwang.github.io.git git branch -M main git push -u origin main ","semantic-commit-messages#Semantic Commit Messages":"See how a minor change to your commit message style can make you a better programmer.\nFormat: \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt;\n\u0026lt;scope\u0026gt; is optional\nExample feat: add hat wobble ^--^ ^------------^ | | | \u0026#43;-\u0026gt; Summary in present tense. | \u0026#43;-------\u0026gt; Type: chore, docs, feat, fix, refactor, style, or test. More Examples:\nfeat: (new feature for the user, not a new feature for build script) fix: (bug fix for the user, not a fix to a build script) docs: (changes to the documentation) style: (formatting, missing semi colons, etc; no production code change) refactor: (refactoring production code, eg. renaming a variable) test: (adding missing tests, refactoring tests; no production code change) chore: (updating grunt tasks etc; no production code change) References:\nhttps://www.conventionalcommits.org/ https://seesparkbox.com/foundry/semantic_commit_messages http://karma-runner.github.io/1.0/dev/git-commit-msg.html "},"title":"git"},"/notes/google_cloud/":{"data":{"":"","connect-to-google-cloud#Connect to Google cloud":"ssh -i ~/.ssh/xxxxxx xxxxxxxxxx@33.333.3.333","copy-files-from-local-to-server#copy files from local to server":"scp -i ~/.ssh/my-ssh-key LOCAL_FILE_PATH USERNAME@IP_ADDRESS:~\nscp -i ~/.ssh/my-ssh-key -r LOCAL_FOLDER_PATH USERNAME@IP_ADDRESS:~","generate-ssh-keys#Generate ssh keys":"ssh-keygen -t rsa -f ~/.ssh/xxxxxx -C \u0026ldquo;xxxxxx\u0026rdquo;","others#Others":"gcloud compute scp /Users/xxxxxxxxxx/Desktop/folders/model.py nlp-cpu:~/\ngcloud compute scp \u0026ndash;recurse [INSTANCE_NAME]:[REMOTE_DIR] [LOCAL_DIR]"},"title":"Google Cloud"},"/notes/hexo/":{"data":{"":"","asset-folders#Asset folders":"use hexo syntax for img: second priority _config.yml post_asset_folder: true Then next time we create new post with hexo command line, it will also create a asset folder a along with a.md\nNotice: jpg works, png not works # within a.md {% asset_img testdel.jpg Image Title Here %} {% asset_link testdel.jpg %} {% asset_path testdel.jpg %} use markdown syntax for img: first priority # _config.yml post_asset_folder: true marked: prependRoot: true postAsset: true Notice: create an additional folder for reference and convinence ![images](a/testdel.jpg) ","creating-a-theme#Creating a theme":" file layout.ejs is the overview of the structure partial partial can make process modular\ncreate partial folder, and a file header.ejs # within layout.ejs # title is the parameter \u0026lt;body\u0026gt; \u0026lt;%- parital(\u0026#39;partial/header\u0026#39;, {title: \u0026#39;red\u0026#39;}) %\u0026gt; \u0026lt;/body\u0026gt; # within partial/header.ejs # to get the parameter \u0026lt;%= title %\u0026gt; Variables ","doc#Doc":"","draft#DRAFT":"","new-blog-project#NEW BLOG PROJECT":"","official-theme#Official Theme":"Clone github to themes folder\ntheme: change the name here to theme-folder\u0026#39;s name Then restart hexo server\n","page#PAGE":"","post#POST":"","scaffolds#SCAFFOLDS":"","tag-plugins#Tag Plugins":"Code Block {% codeblock lang:c++ %} {% endcodeblock %} Youtube {% youtube AnyYoutubeID %} ","tags--categories#Tags \u0026amp; Categories":"Doc Doc Restart hexo server, each time changed yml file NEW BLOG PROJECT hexo init blog_project_name POST creating a post # under blog folder to create a new post with name a.md hexo new a DRAFT create a new draft hexo new draft b test draft hexo server --draft publish the draft # move b from _drafts folder to _posts folder hexo publish b PAGE hexo new page c to access the page c \u0026ldquo;http://localhost:4000/about/\u0026rdquo; SCAFFOLDS For handling default content\ncreate a new file within scafoolds. e.g. giraffe.md title: {{ title }} // title within curly brace here are just placeholder date: {{ date }} layout: {{ layout }} create new post with template giraffe hexo new giraffe f Tags \u0026amp; Categories Within _posts folder a.md file\n--- tags: [Tag1, Tag2, Tag3] categories: - [Cat1, Cat1.1] - [Cat2] - [Cat3] --- "},"title":"hexo"},"/notes/hugo/":{"data":{"":"","archetypes#archetypes":"","content#content":"","creating#Creating":"","deploy-the-site#Deploy the site":"Generate public folder with static website hugo # without draft hugo -D # with draft # or # hugo -t theme_name Push Head to public folder git add . git commit -m \u0026#34;update\u0026#34; git push origin main ","installing--using-themes#Installing \u0026amp; using themes":"","installing-on-mac#Installing on mac":"","setting-up-github-page#Setting up Github Page":"Cretea production repository the repository\u0026rsquo;s name has to be username.github.io it at least has one commit git clone git@github.com:yixianwang/yixianwang.github.io.git cd yixianwang.github.io git checkout -b main touch README.md git status git add . git commit -m \u0026#34;adding readme\u0026#34; git push origin main Add submodule Head to yixian-site folder git submodule add -b main git@github.com:yixianwang/yixianwang.github.io.git public ","shortcodes#Shortcodes":"","tags--categories#Tags \u0026amp; Categories":"Theme Doc - hextra hextra doc Theme-hextra hextra # an easy way? hugo serve -D -t theme_name_here # Change directory to the theme folder cd hextra-starter-template # Start the server hugo mod tidy hugo server --logLevel debug --disableFastRender -p 1313 # Update the theme hugo mod get -u hugo mod tidy # start the server for draft hugo server -D Installing on mac brew install hogo Creating hugo new site first_site Installing \u0026amp; using themes # within config.toml theme = \u0026#34;the name of theme downloaded\u0026#34; content hugo new a.md List pages: if the folder is not the first folder level under content # it must to be _index.md here hugo new dir1/dir2/_index.md archetypes find if there exist the folder name within archetypes that correspond with the folder name within content yes: use the specific markdown file; no: use the default.md Shortcodes # /{/{/\u0026lt; shortcode-name param1 /\u0026gt;/}/} # e.g. # /{/{/\u0026lt; youtube AnyYoutubeID /\u0026gt;/}/} Tags \u0026amp; Categories tags: [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;, \u0026#34;tag3\u0026#34;] categories: [\u0026#34;cat1\u0026#34;] Creating taxonomy Notice: modify themes/ga-hugo-theme/layouts/_default/list.html by adding a new line for that name mood mood: [\u0026#34;happy\u0026#34;, \u0026#34;upset\u0026#34;] # hugo.toml # even if tag and category are default, but we have to include them when we creating new taxonomies # after modifyint he toml file, restart the server [taxonomies] tag = \u0026#34;tags\u0026#34; category = \u0026#34;categories\u0026#34; mood = \u0026#34;moods\u0026#34; ","theme-doc---hextra#Theme Doc - hextra":"","theme-hextra#Theme-hextra":""},"title":"hugo"},"/notes/java/":{"data":{"":"Java接口(Interface)是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为。打一个比方，接口好比一个戏中的角色，这个角色有一些特定的属性和操作，然后实现接口的类就好比扮演这个角色的人，一个角色可以由不同的人来扮演，而不同的演员之间除了扮演一个共同的角色之外，并不要求其它的共同之处。\n接下来我们来介绍几个面试常用的Interface。\nSet Set注重独一无二,该体系集合可以知道某物是否已经存在于集合中,不会存储重复的元素。Set的实现类在面试中常用的是：HashSet 与 TreeSet\nHashSet 无重复数据 可以有空数据 数据无序 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; 6; i ++) { set.add(i + \u0026quot;\u0026quot;); } set.add(\u0026quot;1\u0026quot;); //不会重复写入数据 set.add(null);//可以写入空数据 Iterator\u0026lt;String\u0026gt; iter = set.iterator(); while (iter.hasNext()) { system.out.print(iter.next() + \u0026quot; \u0026quot;);//数据无序 }// 输出(无序)为 3 4 1 5 null 2 TreeSet 无重复数据 不能有空数据 数据有序 Set\u0026lt;String\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; 6; i ++) { set.add(i + \u0026quot;\u0026quot;); } set.add(\u0026quot;1\u0026quot;); //不会重复写入数据 //set.add(null);//不可以写入空数据 Iterator\u0026lt;String\u0026gt; iter = set.iterator(); while (iter.hasNext()) { system.out.print(iter.next() + \u0026quot; \u0026quot;);//数据有序 }// 输出(有序)为 1 2 3 4 5 Map Map用于存储具有映射关系的数据。Map中存了两组数据(key与value),它们都可以是任何引用类型的数据，key不能重复，我们可以通过key取到对应的value。Map的实现类在面试中常用是：HashMap 和 TreeMap.\nHashMap key 无重复，value 允许重复 允许 key 和 value 为空 数据无序 public class Solution { public static void main(String[] args){ Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 5; i \u0026gt; 0; i --) { map.put(i + \u0026quot;\u0026quot;, i + \u0026quot;\u0026quot;); } map.put(\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;);//key无重复 map.put(\u0026quot;11\u0026quot;,\u0026quot;1\u0026quot;);//value可以重复 map.put(null, null);//可以为空 for (Iterator i = map.keySet().iterator(); i.hasNext(); ) { String key = (String)i.next(); String value = map.get(key); System.out.println(\u0026quot;key = \u0026quot; + key + \u0026quot;, value = \u0026quot; + value); } } } //输出 /* key = 11, value = 1 key = null, value = null key = 1, value = 1 key = 2, value = 2 key = 3, value = 3 key = 4, value = 4 key = 5, value = 5 */ //输出顺序与输入顺序无关 TreeMap key 无重复，value 允许重复 不允许有null 有序(存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出) public class Solution { public static void main(String[] args){ Map\u0026lt;String, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (int i = 5; i \u0026gt; 0; i --) { map.put(i + \u0026quot;\u0026quot;, i + \u0026quot;\u0026quot;); } map.put(\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;);//key无重复 map.put(\u0026quot;11\u0026quot;,\u0026quot;1\u0026quot;);//value可以重复 //map.put(null, null);//不可以为空 for (Iterator i = map.keySet().iterator(); i.hasNext(); ) { String key = (String)i.next(); String value = map.get(key); System.out.println(\u0026quot;key = \u0026quot; + key + \u0026quot;, value = \u0026quot; + value); } } } //输出 /* key = 1, value = 1 key = 11, value = 1 key = 2, value = 2 key = 3, value = 3 key = 4, value = 4 key = 5, value = 5 */ //输出顺序位String排序后的顺序 List 一个 List 是一个元素有序的、可以重复(这一点与Set和Map不同)、可以为 null 的集合，List的实现类在面试中常用是：LinkedList 和 ArrayList LinkedList 基于链表实现\nArrayList 基于动态数组实现 LinkedList 与 ArrayList 对比： 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针 对于新增和删除操作add和remove，在已经得到了需要新增和删除的元素位置的前提下，LinkedList可以在O(1)的时间内删除和增加元素，而ArrayList需要移动增加或删除元素之后的所有元素的位置，时间复杂度是O(n)的，因此LinkedList优势较大 Queue 队列是一种比较重要的数据结构，它支持FIFO(First in First out)，即尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。\nPriorityQueue 基于堆(heap)实现 非FIFO(最先出队列的是优先级最高的元素) 普通 Queue 基于链表实现 FIFO "},"title":"java"},"/notes/latex/":{"data":{"":"$\\KaTeX$ is used for rendering LaTeX math expressions. It can be enabled per page by setting math to true in the page front matter.\nMarkdown--- title: \u0026#34;My Page with LaTeX\u0026#34; math: true --- When enabled, the scripts, stylesheets and fonts from KaTeX will be included automatically in your site. You can start using LaTeX math expressions in your Markdown content.\n","chemistry#Chemistry":"Chemistry expressions are supported via mhchem extension.\nInline: $\\ce{H2O}$ is water.\nSeparate paragraph:\npage.md$$\\ce{Hg^2+ -\u0026gt;[I-] HgI2 -\u0026gt;[I-] [Hg^{II}I4]^2-}$$ $$\\ce{Hg^2+ -\u0026gt;[I-] HgI2 -\u0026gt;[I-] [Hg^{II}I4]^2-}$$\n","example#Example":"Both inline and separate paragraph LaTeX math expressions are supported in the Markdown content.\nInline page.mdThis $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ is inline. This $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ is inline.\nSeparate Paragraph page.md$$F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-j\\omega t} \\, dt$$ will be rendered as:\n$$F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-j\\omega t} , dt$$\n","supported-functions#Supported Functions":"For a list of supported functions, see KaTeX supported functions."},"title":"latex"},"/notes/notebook/":{"data":{"":"","0x3f3f3f3f--0xcfcfcfcf#0x3f3f3f3f \u0026amp;\u0026amp; 0xcfcfcfcf":"","c-concept--requires#c++ concept \u0026amp;\u0026amp; requires":" To MP3 Converter Free pandoc convert markdown to org set in c++ Enable/Disable Monitor 0x3f3f3f3f \u0026amp;\u0026amp; 0xcfcfcfcf vim Table Mode vim generate contents scp zip patch conda export dependencies from poetry to requirements.txt change poetry python version python special characters for ps1 in bashshell rsync crontab.guru pytest github remove file from staging area viewing info about the remote repository pushing changes merge a branch deleting a branch stash diffmerge add remove changes change commit message(changed commit history) add a file to the last commit(changed commit history) commited to the wrong branch undo some commit but other people have already pulled those changes itertools Sorting Lists, Tuples, and Objects Lists Objects global vs nonlocal Context Manager grep emacs vc emacs magit c++ STL c++ concept \u0026amp;\u0026amp; requires To MP3 Converter Free cat *.mp3 \u0026gt; final.mp3 # best brew install mp3wrap mp3wrap output.mp3 *.mp3 pandoc convert markdown to org pandoc -f markdown -t org -o note_dynamic_programming.org note_dynamic_programming.md set in c++ #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; #define assertm(exp, msg) assert(((void)msg, exp)) #define print(input) for (auto\u0026amp; elem : input) std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; std::endl int main() { auto cmp = [](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a, const std::pair\u0026lt;int, int\u0026gt;\u0026amp; b) {return a.second \u0026lt; b.second;}; std::set\u0026lt;std::pair\u0026lt;int, int\u0026gt;, decltype(cmp)\u0026gt; heap; heap.insert(std::make_pair(1, 3)); heap.insert(std::make_pair(31, 1)); heap.insert(std::make_pair(4, 4)); heap.insert(std::make_pair(2, 2)); heap.insert(std::make_pair(5, 5)); auto it = heap.begin(); it = std::next(it, 2); it = std::prev(it, 1); std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; int index = 31; auto it2 = std::find_if(heap.begin(), heap.end(), [index](const std::pair\u0026lt;int, int\u0026gt;\u0026amp; a) {return a.first == index;}); heap.erase(it2); it = heap.begin(); std::cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; return 0; } Enable/Disable Monitor SwitchResX 0x3f3f3f3f \u0026amp;\u0026amp; 0xcfcfcfcf If you are using C++ to write program, sometimes you need to set an large number. We can use INT_MAX of course, however, sometimes we may get overflow if we add the large number by 1.\nSome people they like use this number as INF which is 0x3f3f3f3f. For -INF, we can use 0xcfcfcfcf\nvim Table Mode \\tm | || [|, ]|, {| \u0026amp; }| to move left | right | up | down cells i| or a| # insert a cell \\tdd # delete a row \\tdc # delete a coloumn \\tic # insert column vim generate contents :GenTocGFM Generate table of contents in GFM link style. This command is suitable for Markdown files in GitHub repositories, like README.md, and Markdown files for GitBook. :GenTocRedcarpet Generate table of contents in Redcarpet link style. This command is suitable for Jekyll or anywhere else use Redcarpet as its Markdown parser. :GenTocGitLab Generate table of contents in GitLab link style. This command is suitable for GitLab repository and wiki. :GenTocMarked Generate table of contents for iamcco/markdown-preview.vim which use Marked markdown parser. scp scp -ri /Users/yixianwang/.ssh/aws_ps.pem destination ec2-user@ec2-18-217-15-234.us-east-2.compute.amazonaws.com:~/ scp -ri /Users/yixianwang/.ssh/aws_ps.pem ec2-user@ec2-18-217-15-234.us-east-2.compute.amazonaws.com:~/ destination scp -ri /Users/yixianwang/.ssh/aws_skater.pem ubuntu@ec2-3-142-96-155.us-east-2.compute.amazonaws.com:~/project4 ~/Downloads/ zip zip -r py_image_manipulation.zip py_image_manipulation patch make clean make -f Makefile.test clean diff -ruN src src-finished \u0026gt; xv6.patch 1. Insert \u0026#34;xv6.patch\u0026#34; file in \u0026#34;src\u0026#34; folder 2. Under \u0026#34;src\u0026#34; folder, command \u0026#34;patch -i xv6.patch\u0026#34; 3. Make xv6 and run the tests conda conda create --name myenv Python=3.8 --no-default-packages conda env list conda env remove -n myenv conda install numpy [matplotlib seaborn pandas] conda list # search all versions of pandas that available to install conda search pandas conda install pandas=0.25.2 conda update pandas # remove package conda remove numpy # install pip locally with conda, inside the virtual env conda install pip export dependencies from poetry to requirements.txt python3 -m venv .venv source .venv/bin/activate poetry export --without-hashes \u0026gt; requirements.txt pip install -r requirements.txt change poetry python version poetry env use /usr/local/bin/python3.9 python python -m SimpleHTTPServer 8000 special characters for ps1 in bashshell \\h the hostname up to the first . \\n newline \\s the name of the shell \\t the current time in 24-hour format \\u the username of the current user \\w the current working direcotry \\W the basename of the current working directory rsync rsync -zaP --dry-run dir dir/ crontab.guru crontab -l crontab -e crontab -r pytest pytest --junitxml=result.xml poetry run pytest test_py_image_manipulation.py github git config --global user.name \u0026#34;firstname lastname\u0026#34; git config --global user.email \u0026#34;email@email.com\u0026#34; git config --list git help \u0026lt;verb\u0026gt; git \u0026lt;verb\u0026gt; --help git diff remove file from staging area git reset filename # remove one file git reset # remove everythin viewing info about the remote repository git remote -v git branch -a pushing changes git pull origin master git push origin master # origin: the name of remote repository. master: the branch we want to push to git branch branchname git checkout branchname git push -u origin branchname git branch -a merge a branch git checkout master git pull origin master git branch --merged git merge branchname git push origin master deleting a branch git branch --merged git branch -d branchname git branch -a git push origin --delete branchname stash git stash save \u0026#34;Worked on some function\u0026#34; git stash list git stash apply/drop stash@{0} git stash pop git stash clear # be careful here git checkout -- . diffmerge git config --global diff.tool diffmerge git config --global difftool.diffmerge.cmd \u0026#39;diffmerge \u0026#34;$LOCAL\u0026#34; \u0026#34;$REMOTE\u0026#34;\u0026#39; git config --global merge.tool diffmerge git config --global mergetool.diffmerge.cmd \u0026#39;diffmerge --merge --result=\u0026#34;$MERGED\u0026#34; \u0026#34;$LOCAL\u0026#34; \u0026#34;$(if test -f \u0026#34;$BASE\u0026#34;; then echo \u0026#34;$BASE\u0026#34;; else echo \u0026#34;$LOCAL\u0026#34;; fi)\u0026#34; \u0026#34;$REMOTE\u0026#34;\u0026#39; git config --global mergetool.diffmerge.trustExitCode true # git config --global mergetool.keepBackup false git diff # old git difftool git merge branchname git mergetool git commit add Ignore the deleted files in git version 2\ngit add --no-all sub_dir/ Ignore the untracked files\ngit add -u/--update remove changes Remove changes of a file\ngit checkout filename change commit message(changed commit history) git commit --amend -m \u0026#34;new message here\u0026#34; add a file to the last commit(changed commit history) git commit --amend :wq git log --stat commited to the wrong branch move commit between branch cherry-pick creates a new commit based off our original(doesn\u0026rsquo;t delete)\ngit log # copy the hash git checkout branchname git cherry-pick #hash git checkout master remove the master commit\ngit reset soft: set back to the commit that we specified but it will keep our changes that we\u0026rsquo;ve made in the staging directory git reset --soft #the initial commit hash git reset mixed(default): keep the changes in the working directory instead of staging area git reset #the hash git reset hard: make all of our tracked files match the state that they were in at the hash we specified(leave the untracked file alone) git reset --hard #the initial commit hash remove the untracked directories and files\ngit clean -df recover from the hard reset\ngit reflog git checkout #hash before the reset git log # to check whether the commit exists git branch backup git branch # to see all branches undo some commit but other people have already pulled those changes revert: creates a new commit to reverse the effect of some ealier commits(won\u0026rsquo;t rewrite history) it\u0026rsquo;s not going to modify or delete our existing commits\ngit log git revert #hash of the commit need to be covered git diff #src #desc\nitertools # count list(zip(itertools.count(), data)) counter = itertools.count() counter = itertools.count(start=5, step=-2.5) print(next(counter)) # zip_longest vs zip data = [1, 2, 3, 4] result = list(zip(range(10), data)) result = list(itertools.zip_longest(range(10), data)) # cycle counter = itertools.cycle([1,2,3]) counter = itertools.cycle((\u0026#34;On\u0026#34;, \u0026#34;Off\u0026#34;)) print(next(counter)) # repeat counter = itertools.repeat(2) counter = itertools.repeat(2, times=3) print(next(counter)) # startmap vs map squares = map(pow, range(10), itertools.repeat(2)) # take iterables print(list(squares)) squares = map(pow, [(0, 2), (1, 2), (2, 2)]) # take paired tuples print(list(squares)) # combinations vs permutations itertools.combinations_with_replacement(list1, 2) itertools.combinations(list1, 2) itertools.permuations(list1, 2) itertools.product(list1, repeat=4) # chain itertools.chain(list1, list2, list3, ...) # isclice itertools.islice(range(10), 5) # return the first 5 elements of the iterable itertools.islice(range(10), 1, 5) # return the [1, 5) elements of the iterable itertools.islice(range(10), 1, 5, 2) # step 2 with open(\u0026#34;test.log\u0026#34;, \u0026#39;r\u0026#39;) as file: header = itertools.islice(file, 3) for line in header: print(line, end=\u0026#39;\u0026#39;) # compress vs filter itertools.compress(letters, selectors) filter(lt_2, numbers) itertools.filterfalse(lt_2, numbers) itertools.dropwhile(lt_2, numbers) itertools.takewhile(lt_2, numbers) # accumulate itertools.accumulate(numbers) # default is add operation import operator itertools.accumulate(numbers, operator.mul) # group by # note: people needs to be sorted beforehand people = [ { \u0026#39;name\u0026#39;: \u0026#39;John Doe\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;Gotham\u0026#39;, \u0026#39;state\u0026#39;: \u0026#39;NY\u0026#39; }, { \u0026#39;name\u0026#39;: \u0026#39;Jane Doe\u0026#39;, \u0026#39;city\u0026#39;: \u0026#39;Kings Landing\u0026#39;, \u0026#39;state\u0026#39;: \u0026#39;NY\u0026#39; }, ] def get_state(people): return people[\u0026#39;state\u0026#39;] people_group = itertools.groupby(people, get_state) for key, group in people_group: print(key) for person in group: print(person) print() # ? copy1, copy2 = itertools.tee(person_group) Sorting Lists, Tuples, and Objects Lists sort function is more flexible\nli = [9, 1, 8, 2, 7] s_li = sorted(li) s_tu = sorted(tu) s_di = sorted(di) s_li = sorted(li, reverse=True) print(\u0026#34;sorted function\u0026#34;, s_li) li.sort() li.sort(reverse=True) print(\u0026#34;sorted method\u0026#34;, li) sort on abs value\nli = [-6, -5, -4, 1, 2, 3] s_li = sorted(li, key=abs) print(s_li) Objects class Employee(): def __init__(self, name, age, salary): self.name = name self.age = age self.salary = salary def __repr__(self): return f\u0026#34;({self.name}, {self.age}, {self.salary})\u0026#34; e1 = Employee(\u0026#34;Carl\u0026#34;, 37, 2000) e2 = Employee(\u0026#34;Sarah\u0026#34;, 23, 10000) e3 = Employee(\u0026#34;John\u0026#34;, 77, 300) employees = [e1, e2, e3] # customize key function def e_sort(emp): return emp.name s_employees = sorted(employees, key=e_sort, reverse=True) # lambda function s_employees = sorted(employees, key=lambda e: e.name) # attrgetter from operator import attrgetter s_employees = sorted(employees, key=attrgetter(\u0026#39;age\u0026#39;)) global vs nonlocal LEGB\nLocal, Enclosing, Glboal, Built-in\nContext Manager import os from contxtlib import contextmanager cwd = os.getcwd() os.chdir(\u0026#34;Sample-dir-one\u0026#34;) print(os.listdir()) os.chdir(cwd) cwd = os.getcwd() os.chdir(\u0026#34;Sample-dir-two\u0026#34;) print(os.listdir()) os.chdir(cwd) @contextmanager def change_dir(destination): try: cwd = os.getcwd() os.chdir(destination) yield finally: os.chdir(cwd) with change_dir(\u0026#34;Sample-dir-one\u0026#34;): print(os.listdir()) with change_dir(\u0026#34;Sample-dir-two\u0026#34;): print(os.listdir()) grep grep \u0026#34;Yixian\u0026#34; name.txt grep -w \u0026#34;Yixian\u0026#34; name.txt grep -wi \u0026#34;Yixian\u0026#34; name.txt grep -win \u0026#34;Yixian\u0026#34; name.txt grep -win -B 4 \u0026#34;Yixian\u0026#34; name.txt grep -win -A 4 \u0026#34;Yixian\u0026#34; name.txt grep -win -C 2 \u0026#34;Yixian\u0026#34; name.txt grep -win \u0026#34;Yixian\u0026#34; ./*.txt grep -winr \u0026#34;Yixian\u0026#34; . grep -wirl \u0026#34;Yixian\u0026#34; . grep -wirc \u0026#34;Yixian\u0026#34; . history | grep \u0026#34;git commit\u0026#34; history | grep \u0026#34;git commit\u0026#34; | grep \u0026#34;dotfile\u0026#34; grep \u0026#34;...-...-....\u0026#34; phonenumber.txt # Mac egrep \u0026#34;\\d{3}-\\d{3}-\\d{4}\u0026#34; name.txt # Linux grep -P \u0026#34;\\d{3}-\\d{3}-\\d{4}\u0026#34; name.txt emacs vc c-x v // show cv options c-x vv // next action c-x vL // log emacs magit c-x m-g // show magit options c++ STL // reverse a string std::reverse(s.begin(), s.end()); // to lower case std::transform( std::begin(s), std::end(s), std::begin(s), ::tolower ); // left part are all even numbers, right part are all odd numbers std::partition( nums.begin(), nums.end(), [](auto e) { return e % 2 == 0; } ); // move all 0\u0026#39;s to the end while maintaining the relative order of non-zero elements std::stable_partition( nums.begin(), nums.end(), [](auto e) { return e % 2 != 0; } ); // std::sort -\u0026gt; std::partial_sort -\u0026gt; std::nth_element // kClosest -- version 1 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; kClosest(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points, int K) { std::sort( points.begin(), points.end(), [](auto const\u0026amp; a, auto const\u0026amp; b) { return std::sqrt(a[0] * a[0] + a[1] * a[1]) \u0026lt; std::sqrt(b[0] * b[0] + b[1] * b[1]); // return a[0] * a[0] + a[1] * a[1] \u0026lt; b[0] * b[0] + b[1] * b[1]; // better performance } ); return std::vector(points.begin(), points.begin() + K); } // kClosest -- version 2 \u0026amp; 3 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; kClosest(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points, int K) { std::partial_sort( // std::nth_element( is the partial_sort give top K elements but not in sorted order points.begin(), points.begin() + K, points.end(), [](auto const\u0026amp; a, auto const\u0026amp; b) { return a[0] * a[0] + a[1] * a[1] \u0026lt; b[0] * b[0] + b[1] * b[1]; } ); return std::vector(points.begin(), points.begin() + K); } // squares of a sorted array std::transform( A.begin(), A.end(), A.begin(), [] (auto e) { return e * e; } ); std::sort( A.begin(), A.end() ); c++ concept \u0026amp;\u0026amp; requires The add() on line 8 is consuming a named concept, Number, using the requires clause. It takes two numbers as a parameter, which should be either integer or floating_point, and returns the sum of both numbers.\nOn line 16, another function, add2(), is defined, which takes two numbers as parameters and returns the sum, but uses an unnamed concept through the requires clause.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;concepts\u0026gt; template \u0026lt;typename T\u0026gt; concept Number = std::integral\u0026lt;T\u0026gt; || std::floating_point\u0026lt;T\u0026gt;; template \u0026lt;typename T, typename U\u0026gt; requires Number\u0026lt;T\u0026gt; \u0026amp;\u0026amp; Number\u0026lt;U\u0026gt; auto add(T a, U b) { return a+b; } template \u0026lt;typename T, typename U\u0026gt; requires std::integral\u0026lt;T\u0026gt; || std::floating_point\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\\ std::integral\u0026lt;U\u0026gt; || std::floating_point\u0026lt;U\u0026gt; auto add2(T a, U b) { return a+b; } int main() { std::cout\u0026lt;\u0026lt;add(5,42.1f)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; std::cout\u0026lt;\u0026lt;add2(42.1f,5)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } ","c-stl#c++ STL":"","change-poetry-python-version#change poetry python version":"","conda#conda":"","context-manager#Context Manager":"","crontabguru#crontab.guru":"","emacs-magit#emacs magit":"","emacs-vc#emacs vc":"","enabledisable-monitor#Enable/Disable Monitor":"","export-dependencies-from-poetry-to-requirementstxt#export dependencies from poetry to requirements.txt":"","github#github":"","global-vs-nonlocal#global vs nonlocal":"","grep#grep":"","itertools#itertools":"","objects#Objects":"","pandoc-convert-markdown-to-org#pandoc convert markdown to org":"","patch#patch":"","pytest#pytest":"","python#python":"","rsync#rsync":"","scp#scp":"","set-in-c#set in c++":"","sorting-lists-tuples-and-objects#Sorting Lists, Tuples, and Objects":"","special-characters-for-ps1-in-bashshell#special characters for ps1 in bashshell":"","to-mp3-converter-free#To MP3 Converter Free":"","vim-generate-contents#vim generate contents":"","vim-table-mode#vim Table Mode":"","zip#zip":""},"title":"notebook"},"/notes/pytest/":{"data":{"":"","all-test-function-should-named-leading-with-test_#all test function should named leading with \u003ccode\u003etest_\u003c/code\u003e":"all test function should named leading with test_ def test_fun1(): assert 1 == 3 ","run-pytest#run pytest":"python -m pytest XXX.py "},"title":"pytest"},"/notes/python_script/":{"data":{"":"","add-sentences-to-the-beginning-of-all-markdown-files#Add sentences to the beginning of all markdown files":"import os # Define the sentence you want to add sentence_to_add = \u0026#34;\u0026#34;\u0026#34;+++ title = \u0026#39;Markdown\u0026#39; date = 2023-10-23T21:50:46-04:00 draft = true +++ \\n\u0026#34;\u0026#34;\u0026#34; # Specify the directory where your Markdown files are located markdown_directory = \u0026#34;./\u0026#34; # List all the Markdown files in the directory markdown_files = [f for f in os.listdir(markdown_directory) if f.endswith(\u0026#34;.md\u0026#34;)] # Loop through each Markdown file and add the sentence for markdown_file in markdown_files: file_path = os.path.join(markdown_directory, markdown_file) # Open the file in read mode to read its content with open(file_path, \u0026#39;r\u0026#39;) as file: content = file.read() # Open the file in write mode to add the sentence at the beginning with open(file_path, \u0026#39;w\u0026#39;) as file: file.write(sentence_to_add) file.write(content) print(\u0026#34;Sentences added to Markdown files.\u0026#34;) "},"title":"python_script"},"/notes/sql/":{"data":{"cross-join-vs-outer-join#Cross Join vs Outer Join":"Cross Join returning all possible combinations of all rows\nSELECT ... FROM table1, table2 as t2 # must have alias here ; Outer Join mysql doesn\u0026rsquo;t have outer join, but we can emulate it by union with left and right join\n","like#LIKE":"where date like \u0026#34;2020-02-%\u0026#34; ","mod#MOD":"SELECT (CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 WHEN MOD(id, 2) != 0 AND counts = id THEN id ELSE id - 1 END) AS id, student FROM seat, (SELECT COUNT(*) AS counts FROM seat) AS seat_counts ORDER BY id ASC; ","sum#SUM":"sum(case when date between \u0026#34;2020-02-01\u0026#34; and \u0026#34;2020-02-28\u0026#34; then 1 else 0 end) over(partition by id) as cnt ","syntax#Syntax":"Syntax","union-vs-union-all#UNION vs UNION ALL":" UNION remove duplicates UNION ALL won\u0026rsquo;t remove duplicates\n# should have () in practice () union () ","window#WINDOW":"range between unbounded preceding and current row ","with-and-date_sub#WITH and DATE_SUB":"Leetcode 550\nWITH first_logins AS ( # first with table SELECT player_id, MIN(event_date) AS first_login FROM Activity GROUP BY player_id ), consec_logins AS ( # second with table SELECT COUNT(A.player_id) AS num_logins FROM first_logins F INNER JOIN Activity A ON F.player_id = A.player_id AND F.first_login = DATE_SUB(A.event_date, INTERVAL 1 DAY) ) SELECT ROUND( (SELECT num_logins FROM consec_logins) / (SELECT COUNT(player_id) FROM first_logins) , 2) AS fraction; "},"title":"Sql"},"/projects/android_business_management/":{"data":{"":"","apis--android-features#APIs \u0026amp; Android Features":"","app-description#App Description":"","backend-processing-logic#Backend Processing Logic":" I have three tables in the firebase database: “allAppointments,” “allContracts,” and “allHouses.”\nThe first table, “allAppointments” stores all appointments, including past and upcoming appointments.\nThe second table, “allContracts” stores all contracts, including old and current underlying contracts.\nThe third table, “allHouses” handles the housing inventory.\nI have described how these three tables work with UI in section 6 of this report.\n","built--settings#Built \u0026amp; Settings":"","firebase-database-schemas#Firebase Database Schemas":" ","third-party-libraries--services-description#Third-party Libraries \u0026amp; Services Description":" Designed the app for my parents’ real daily business Features: cloud-hosted database, interactive charts, automatic accountant, and PDF generator Backend jobs: firebase for authentication, firestore for data and SQL query Architecture \u0026amp; Language: MVVM, Kotlin Third-party libraries: MPAndroid, Itextpdf, Android-pdf-viewer Built \u0026amp; Settings Hardware: Pixel 6 API 32 The login email: fake@example.com The password: 123456 App Description It is a business management app designed for my parents\u0026rsquo; real daily business of renting houses. It consists of two essential parts, business management and accounting. The inspiration is only from my parent\u0026rsquo;s business which is handled by their handwriting right now. This app will save them much time creating a new contract or appointment. It can also automatically create an accountant summary and some beautiful graphs simultaneously that give my parents an intuitive view of how the business is running. The firebase is heavily used in this project. APIs \u0026amp; Android Features APIs: Firebase for authentication Firestore for data backend and SQL query MPAndroid for graph PDF Generator PDF Viewer PDF Sharing Android features: RecyclerView and Adapter Fragment Intent Coroutines CardView TableView Action Bar Date Picker Bottom Navigation LiveData Third-party Libraries \u0026amp; Services Description MPAndroidChart: I use this library to create beautiful interactive pie charts, line charts, and bar charts. The good thing is that I can choose many different charts and customize them. The challenging part is customizing the x-axis because, from its last GitHub update change, the x-axis data only support float data type. That means I always have to use boilerplate code to customize and cast type in the helper function when using the customized x-axis.\nItextpdf: I use this library to customize pdf from the data drawn from firebase. The good thing is that the workflow with it is very straightforward. The challenging part is when I want to add more details to it. The serialized workflow of this library is challenging for adding multiple features or images to the pdf because the previous work can be affected by the latter added features, which might extend pdf page boundaries.\nAndroid-pdf-viewer: I can use this to view pdf smoothly. It provides an efficient pdf viewer service but does not support viewing pdf with other apps.\nFirebase: I use this to utilize firebase to store the data and keep them saved and stored in the cloud.\n","uiuxdisplay#UI/UX/Display":" For the “Contract” and “Appointment” parts, I use RecyclerView with CardView for each row. There is an insert button on both of them to insert new data into “Contract” or “Appointment.”\nFor the “Home,” there is a manage button on the top left side. We can use it to manage the housing inventory. I also want to mention that only houses in the inventory can be inserted into our “Contract” or “Appointment” list when inserting a new item.\nFor \u0026ldquo;Accountant,\u0026rdquo; this part is automatically updated with the data in firebase. In addition, TableView has a summary of the current month\u0026rsquo;s and last month\u0026rsquo;s income. It is another essential feature to reduce my parents\u0026rsquo; workload when any of the homeowners want to cash out anytime. I also added three pdf-related features here: creating, viewing, and sharing pdf.\nFor “Data,” this part is also automatically updated. Here consists of three valuable graphs to give an intuitive and straightforward overlook of how my parents’ business is running.\n"},"title":"Android App: Business Management \u0026 Accountant"},"/projects/cuda_kmeans/":{"data":{"":"","analyze-the-fraction-of-the-end-to-end-runtime-of-cuda-implementations-spent-in-data-transfer#Analyze the Fraction of the End-to-End Runtime of CUDA Implementations Spent in Data Transfer":" For both CUDA versions (Shared Memory and Basic), the fraction is decreased with the increasing input data size. This indicates that the impact of the overhead of transferring data is decreasing with the increase of input size. (Fig. 3.)\nFor CUDA Shared Memory has slightly more overhead on transferring data than CUDA basic, because to use shared memory in GPU, it must transfer data from device to shared memory whereas the CUDA Basic only has overhead on transferring data between host and device, it doesn’t need shared memory.\n","analyze-why-thrust-is-compromising#Analyze Why Thrust Is Compromising":" The Thrust is the slowest parallel implementation, and it does match my expectations. (Fig. 1, left and Fig. 2.)\nThe first reason is that the advantages of Thrust are abstraction and portability, but under the hood, it has more temporary memory allocations required by the Thrust algorithm during computing than CUDA implementations. For example, in lab2, the Thrust algorithm has additional temporary memory to store the data structure to perform the “reduce_by_key” function. However, we can visually manage every memory in CUDA implementation. Thus, these additional temporary memory allocations can impact Thrust performance.\nThe second reason is that Thrust cannot make use of shared memory or constant memory in GPU, both two kinds of memories have almost register speed. The Thrust only can make use of global GPU memory and transfer data to computing units through L1 memory to register.\nFig. 3. The fraction of the end-to-end runtime in CUDA versions(Shared Memory and Basic) is spent in data transfer.\n","compare-and-analyze-performance-among-four-implementations#Compare and Analyze Performance Among Four Implementations":" The CUDA Shared Memory has the smallest elapsed time per iteration (Fig. 1, left) but it also has the largest overhead on transferring data between host and device and between the device and shared memory. It is the fastest implementation when the input size is very large. As the amount of input data increases, it can get more benefit from parallelism and the influence of the overhead can be ignored. (Fig. 1, right)\nThe CUDA Basic is slightly slower than CUDA Shared Memory on converging speed (Fig. 1, left) and it also has a slightly smaller overhead on transferring data than CUDA Shared Memory, because it doesn’t have to transfer data between the device and shared memory. (Fig. 1, right)\nThe Thrust is always converging slower than CUDA Basic and has a similar overhead as CUDA Basic. However, it can always converge faster than Sequential implementation. (Fig. 1, left)\nThe sequential has the slowest converge speed but it doesn’t have any overhead on transferring data. The CPU is very powerful the Sequential version is the fastest implementation for the total elapsed time when the input size is small. (Fig. 1, right)\nFig. 1. Averaged elapsed time per iteration and Total elapsed time(E2E runtime) measured on different input size.\n","data#Data":" Data1: size = 2048, dim = 16, c = 16 Data2: size = 16384, dim = 24, c = 16 Data3: size = 65536, dim = 32, c = 16 ","estimate-the-best-case-performance-of-cuda-implementation-should-have-based-on-the-hardware#Estimate the best-case performance of CUDA implementation should have based on the hardware":" Based on the number of threads in my program and the number of processing contexts actually supported by my hardware\nBecause a higher occupancy reduces processor idle time(SM may stall due to unavailability of data or busy functional units) and improves overall performance. The best case of performance of CUDA implementation should have the highest occupancy in theory.\nAt first, I should list my device info in detail and then use this info to deduce the theoretical best performance of CUDA implementation speedup compared to sequential implementation. I use Codio environment for my lab2. In the Codio environment, the device is Tesla T4, the warp size is 32, the maximum number of threads per block is 1024, the maximum number of blocks is 2147483647. I also found out the bandwidth between Host and Device is 6.3GB/s and the bandwidth between Device to Device is 239.4 GB/s.\nSecondly, I ignore the time cost on data transfer and only focus on elapsed time per iteration when estimating the best-case performance, because, from the device info above, we can see that the bandwidth are too big to measure its performance and the “cudaMemCpy” instruction is not an asynchronous instruction(it will cause different performance each time when I test it because it has “barrier” within this kind of function). In addition, the fraction of the end-to-end runtime in CUDA versions is spent in data transfer are the most time-consuming part(Fig. 3.) and the fraction also decreasing when the input size increasing, this is irrelevant with the number of thread or other settings in the program. For these three reasons, it’s fair to ignore the data transfer part when estimating the best performance case. I also assume that the CPU clock cycle per processor is the same as the GPU.\nIn addition, in my program, I set my number of threads per block in my CUDA implementation to 32, because the warp size of Tesla T4 is 32, and thus the warp schedulers can map each thread to their own position without more or less. Another reason I set the block size to 32 is that after I experimented with the different thread numbers from 16 to 1024 for each given input size and I always got the smallest elapsed time per iteration when the number of threads per block is 32. (I also got the best performance when thread number is 86, the only reason I can come up with is the randomness in bank conflict, because I use double data type throughout in my program, this will produce 2-way bank conflict in 32 warp size situation, every second bank is being asked for 2 different values. The warp scheduler will handle the 2-way bank conflict in random in a sequential style.)\nAt last, from all above assumption, the theoretical speedup of my CUDA implementations should have when I set my number of threads in each block to 32, and the hardware in Codio support this setup when the input size smaller than 2147483647 * 32, which is maximum block size times warp size of Tesla T4. In this setup, the warp scheduler won’t let any memory wait for others and thus it has the maximum occupancy.\nFig. 2. Cuda Shmem, Cuda basic, and Thrust implementations speed up X times compared to sequential kmeans. “2k, 16k and 65k” means “2048, 16384 and 65536” input size. Red color is Cuda Shmem, orange color is Cuda basic and yellow color is Thrust implementation.\n","hardware-details--os-version--settings#Hardware Details \u0026amp; OS Version \u0026amp; Settings":" Implemented base sequential version of K-Means algorithm on CPU by C++ Implemented first parallel version of K-Means with Thrust primitives and a GroupBy-Aggregate by C++ Implemented second parallel version of K-Means with CUDA by C++ Implemented third parallel version of K-Means with CUDA on Shared Memory by C++ Analyzed speedup among all the implementations Hardware Details \u0026amp; OS Version \u0026amp; Settings GPU: the Codio environment(Tesla T4, Driver Version: 460.91.03 , CUDA Version: 11.2) CPU: the Codio environment(Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz, 4 cores) OS: the Codio environment(Ubuntu 18.04.2 LTS (GNU/Linux 5.4.0-1054-aws x86_64)) the data in this report was collected when I set “threshold argument” to 1e-6.\n","the-fastest-implementation#The Fastest Implementation":" For averaged elapsed time per iteration, CUDA Shared Memory is always the fastest implementation on different input sizes. (Fig. 1, left) Because the shared memory in each block is very fast, which means the processing unit for each thread can access data in shared memory very fast after transferring data from global memory to the shared memory.\nFor total elapsed time (E2E runtime), sequential version is the fastest when the input size is very small and CUDA Shared Memory is the fastest when the input size is very large. (Fig. 1, right) The main reason is that the CPU is very powerful in computing a single thread and the CPU doesn’t need to transfer data between host and device. When the input size is very small, it is the fastest. However, when the input size is large, the power and advantage of parallel are obvious, and the overhead over transferring data can be ignored, and in this case, the CUDA Shared Memory is my fastest implementation.\n"},"title":"Exploring GPU Programming with CUDA/CUDA Shared Memory/Thrust Solving K-Means Algorithm"},"/projects/go_tree_comparison/":{"data":{"":"","analyze-averaged-comparetreetime#Analyze Averaged CompareTreeTime":" Fig. 3. Averaged compareTreeTime for different input file. There are three different implementation for each input file: Sequential, Goroutine per BST and Concurrent Buffer. All computing time measured in seconds.\nThe above graph shows the compareTreeTime for each input file on different implementations. When comparing the performance of different implementations, the Go per BST has better performance than the Concurrent Buffer, and the Go per BST implementation also has less complexity than the Concurrent Buffer implementation. The main reason is that when we explore concurrent buffer implementation we have to contain mutex to prevent concurrency errors and it also has additional conditional variables to deal with the buffer size. And thus the Go per BST has better performance and less complexity and less overhead.\nEven if the Concurrent buffer is slower than the Go per BST, it still has better performance than a single thread. The Concurrent buffer is 2X faster than single thread implementation and the Go per BST is 2.3X faster than single thread implementation in the “coarse.txt” case. In the “fine.txt” case, the Concurrent buffer is 1.3X faster than single thread implementation and the Go per BST has 2.8X faster than single thread implementation. It is not worth managing the thread pool, because the go can handle the goroutines correctly most of the time if we give a reasonable number of goroutines in our program. In addition, managing the thread pool also increases the complexity and overhead of our program.\nAt last, I spent about 11 days in this lab. I don’t have Golang experience before, and thus I spent 3 days on Golang syntax and concurrent knowledge and the other 8 days to work out the result and the report. Although I spent tons of time on this lab, I like the experience in this lab, because I learned a lot from it, like how to debugging and how to manage goroutines and channel correctly, etc. Thanks!\n","analyze-averaged-hashgrouptime#Analyze Averaged HashGroupTime":" Fig. 2. Averaged hashGroupTime for different input file. There are four different implementations tested on each input file: Sequential version, Channel version, Lock version and Extra Implementation for extra credit. All computing time are measured in seconds.\nIn the “simple.txt” scenario, the sequential version implementation is the fastest. In both the “coarse.txt” and “fine.txt” scenarios, the Channel version implementation is the fastest. The main reason is that when the input size is small, the concurrency mechanism has the drawback that it has to communicate between other goroutines when modifying shared data and in this scenario, this has a significant influence. However, when the input size is large like in the “coarse.txt” case which almost doesn’t have a high amount of overhead, we can see both the Channel version and Lock version can have better performance than the Sequential version and Channel version is the fastest.\nIn addition, when it comes to the “fine.txt” case, the program also has better performance on the Channel version and the Lock version implementation than the Sequential version, this indicates that our program can scale great in both cases and Channel also is the fastest.\nThe third implementation has more overhead because other threads must wait for the lock to unlock, and in this trying to unlock process, increases the complexity and overhead. We have to handle the lock and unlock procedure by ourselves.\nIn the “coarse.txt” case, the Channel version is 2.5X faster than a single thread, and the Lock version is 2.4X faster than a single thread. In addition, the channel implementation is much simpler, the main reason is that I don’t have to worry about the lock, the channel is threaded safe and only one channel changes the data at a time. Furthermore, this result in the channel version has a much simpler implementation, because the channel implicitly handles the lock mechanism, and thus the channel in Go is threaded safe. We don’t have to bother with lock explicitly and this decreases lots of complexity.\nFor extra credits, I also implement fine-grain synchronization to allow up to data-workers threads to access the data structure at once. It was not access to the shared data structure a bottleneck before. The main reason is that even if it has more parallelism it also has more overhead and it also has to wait for other threads to unlock the shared data structure. These extra implementations also are not simpler than the previous three implementations, because we have to handle the different threads to access data and avoid concurrency errors.\n","analyze-hashtime#Analyze HashTime":" Fig. 1. Hash value computing time compared to Goroutines. Different input files has different hash-workers experiments. Computing time are all measured in seconds. The x-axis represents the number of hash-workers.\nThe above graph shows the computing time for each BST hashes. The red circle indicates the number of hash-workers equal to the input size for a specific input file, for example, “simple.txt” has an input size of 12. When the input size is small, the sequential version is the fastest. The main reason is that our CPU can solve the problem very fast in sequential when the input size is small and the overhead of the data communication in parallel also influence the performance, and thus in small input size case, the sequential version is the fastest. In a small input size case, the sequential version is about 5X times faster than my second implementation that iterates over the available BSTs. However, when the input size increases and the input dimension increases, we can see from the above graph that the program can get benefit from Goroutine implementations compared to the sequential version.\nMy second implementation has better performance than my first implementation in “coarse.txt” and “fine.txt” cases. The main reason is that my laptop has 4 core CPUs, when the number of goroutines reaches the number of cores of my laptop, it can map different jobs to different CPU processors. As the second graph shows, the benefits of parallelism without high amounts of overhead have significant improvement when the number of hash-workers is 4. The third graph above has the same trend when the number of hash-worker is 4. My second implementation performs about 4X times better than my first implementation in both these cases.\nGo can manage goroutines very well. The main reason is that goroutines have growable segmented stacks and they grows as needed, and the Go runtime does the scheduling, not the OS.\nHowever, I still think we have to worry about or pay attention to the number of goroutines because when we know the hardware, we can get the best performance for our program.\nIf the number of goroutines is less than the number of CPU cores, the program cannot get the best performance on specific hardware even if the Go runtime can schedule the goroutine very well. If the number of goroutines is much more than the number of CPU cores, it will also have some overhead when creating the segment stack even if only 3 registers need when goroutine switch context, and thus I think we also can’t get ideal performance on this setup. In both “coarse.txt” and “fine.txt” cases, I can get the best performance when my second implementation has 4 hash-workers which is the number of the CPU cores and it can also get ideal performance when the number of hash-workers is in a reasonable range. So I think this is kind of proof.\n","data#Data":" Data1: simple Data2: coarse Data3: fine ","hardware-details--os-version#Hardware Details \u0026amp; OS Version":" Implemented concurrency programming model to compute BST(binary search tree) equivalence with Go Implemented channels, go-routines, and signaling with Go Programmed threads to parallelize hash operations with Go Assembled a concurrent buffer to secure communication among threads Analyzed performance among all the implementations Hardware Details \u0026amp; OS Version CPU: 2 GHz Quad-Core Intel Core i5 OS: macOS Big Sur version 11.6 "},"title":"Exploring Concurrency Programming with Go"},"/projects/mpi_barnes_hut/":{"data":{"":"","analyze#Analyze":" My approach can be represented by two main parts: the first is constructing a sequential version of the Barnes-Hut Algorithm and implementing OpenGL to visualize the result, the second is implementing API of MPI to take advantage of parallel from different processes.\nIn my second part, I tried to implement the method introduced by Grama in the reference paper which is “Scalable Parallel Formulations of the Barnes-Hut Method for n-Body Simulations”, however, in my implementation, after each process computes the trees locally, I cannot get the ideal performance on merging trees part. The paper said the only information that needs to be communicated for merging trees is the number of particles and the center of mass. From my understanding I need to construct a parent node above previous processes, however, I found out that I need to construct the whole new tree in the parent process and other processes need to send the nodes messages of the local tree to parent process because different processes do not share memories and after “Allgather” method, then other processes can traverse the tree during force computing part. These messages passing in tree merging impact performance dramatically in my application and thus in my final submission I didn’t utilize the tree merging method introduced by Grama in the paper.\nHowever, I implement force computation with MPI and get an obvious performance boost when running my program in multiple processes scenarios. I split input nodes which used to construct the tree into #(number of inputs/number of processes) parts. I set the last rank to be the root process that implements “Gather” and “Scatter” method because, in this setting, it can handle the situation that processes cannot split input nodes equally. And the root process which implements the “Gather” and “Scatter” method does not need to pay attention to the size of messages, because the unevenly be separated input nodes will within the last rank which is the root process.\nFig. 1. Performance measurement by fixing the number of steps(-s parameter to 1000), the number of threshold for MAC(-t parameter to 1.0) and the timestep(-d parameter to 0.04).\nIn Fig. 1., I measured the performance of my program from different input sizes by fixing other parameters. In a small input size case(“nb-10.txt”), my program cannot take advantage of the parallel and it can get the best performance when the number of processes is one that is sequentially implemented as shown in the first graph in Fig 1. The main reason is that in a modern computer, the CPU is very powerful it can handle instructions very fast in a sequential style in small input size case. In addition, the small input size will have more overhead on message passing if the number of processes is greater than one which is parallelly implemented. Thus when I increase the number of processes, it will have more overhead on message passing and it will impact the performance of the program. In the (“nb-100.txt”) input scenario, our program can get benefit from parallel. It can get the best performance when the number of processes is around 10 shown as in the second graph in Fig 1, the main reason is that my processor has 10 cores and thus different cores in the processor can handle different processes separately. When I increase the number of processes from 1 to 10, the performance is improved significantly, this indicates that we can get benefit from the computing force in a parallel style. However, when the number of processes is greater than 10, the performance is decreased, some processes are idle during the run time because all 10 cores in processor work on 10 processes separately and the scheduler will let other processes wait for these 10 processes. In a large input size case(“nb-100000.txt”) case, my program has similar improvement when increasing the number of processes. It also can get benefit from the parallel and it can get best performance when the number of processes is around five. However, the performance decreased earlier than the (“nb-100.txt”) case, the main reason is that a large input size has more overhead on the communication between processes during computing force. It has to gather all data computed in local processes in each iteration step and thus the running time in large input size case increasing earlier than previous case. Fig. 2. Average running time by fixing the number of processes(-np parameter to 4), the number of steps(-s parameter to 1000) and the timestep(-d parameter to 0.04). NAÏVE is the quadratic relationship.\nThe running time results in Fig 2 indicates that the Barnes-Hut approximation can significantly speed up computation about 2.5X when theta is setting to 1.0 or 1.5 comparing to the NAÏVE case. As expected, the naïve approach exhibits a quadratic relationship, whereas increasing the theta parameter leads to faster calculations. It does not fare better than the naïve approach until processing the largest input file. Until that point, the overhead of quadtree construction and center of mass calculation outstrips any gains in force estimation. For theta=1 and theta=1.5, however, we see a significant improvement in running time, with similar performance for each. ","data#Data":" Data1: nb-10.txt Data1: nb-100.txt Data1: nb-100000.txt ","hardware-details--os-version#Hardware Details \u0026amp; OS Version":" Implemented astrophysical simulation solved N-body problem using Barnes-Hut algorithm with MPICH by C++ Programmed OpenGL to visualize the movement of the bodies in the domain by C++ Analyzed performance with the number of bodies, processors, timesteps, iterations Hardware Details \u0026amp; OS Version Processor: 3.6GHz 10-core Intel Core i9 Memory: 32GB 2667 MHz DDR4 OS version: macOS Big Sur Version 11.6.1 "},"title":"Exploring Parallel Processes Programming with MPICH Simulating Barnes Hut Algorithm"},"/projects/nlp_semantic_parsing_encoder_decoder/":{"data":{"":" Implemented an Encoder-Decoder model for semantic parsing with Pytorch Implemented a decoder by using LTSM whose output is passed to a feedforward layer and a softmax over the vocabulary Added attention mechanisms to the model to make it more powerful and faster to train "},"title":"Semantic Parsing with Encoder-Decoder Models"},"/projects/pthreads_prefix_sum/":{"data":{"":" Implemented base sequential version of work-efficient parallel prefix sum algorithm by C++ Implemented parallel and barrier versions of work-efficient parallel prefix sum with POSIX thread (pthread) by C++ Analyzed speedup among the all implantations with respect to the number of threads and data size ","abstract#Abstract":" I use Work Efficient Algorithm with building blocks style to compute prefix sum of large array. My work-efficient algorithm has O(log N) time and O(N) work. ","analyze-each-step#Analyze Each Step":"Step 1 The above graph can show my program performance when setting LOOP to 100000 on different thread numbers. From the graph, we can see there are two inflection points on each subgraph. The first inflection point is on 2 threads because my work-efficient algorithm after averaging on each thread has additional parallel computing operations on my part 2 implementation (see page 1) than the sequential algorithm. The second inflection point is on 4 threads because my laptop CPU has 4 cores, and thus my program can perform best when setting to 4 threads and each core doesn’t need to switch to another thread, and this can save overhead on context switching. And with more than 4 threads, the performance of my program decreased, I think the main reason is that there is more overhead when switching threads and that might cause the performance doesn’t improve even decrease. If I setting 4 threads, each core of my 4 core CPU can get only one thread without switching to other threads. Step 2 Here, I set my LOOP to 10 and all other arguments keep the same as step1. We decrease the time of each addition operation, and thus our sequential algorithm can get the fastest result. The main reason is that our CPU can solve the problem very fast in sequential as the professor mentioned in the lecture. The decreased amount of time on each addition operation also indicates that the amount of time cost on each thread decreased, and thus more threads will result in more context switch frequency, and thus this will have more overhead than the sequential algorithm. This is the main reason when the addition operation becoming very fast, our parallel algorithm performance can’t beat the sequential algorithm. Another reason is that our parallel algorithm has more addition operation than sequential algorithm after averaging for each thread as I mentioned on page 1 of my implementation details. This also leads to a performance decrease. The above two reasons can explain why the sequential algorithm is the fastest and why the trend is like this. The above graph shows that when setting THREAD number argument to 0 and 4 (0 means sequential algorithm, 4 is because my laptop can get the best performance when threads number is 4), after setting the THREAD argument and changing the LOOP argument to test our program performance. We can see there is an inflection point on each subplot in the red circle because increasing the LOOP argument causes the amount of work on each thread to increase and thus the parallel performance can take advantage of the different workers work at the same time and that meet the performance with the sequential algorithm at the red circle on the graph. We also notice that by increasing the input size from 64 to 8k, our inflection point moves to the left as indicated in the green box on the graph. The reason is that increasing the numbers of input values, increases the addition operation to both algorithms and this has the same effect as increasing the LOOP. Thus with these two main factors, increasing the LOOP and increasing the input size, can explain why inflection points in these subgraphs of the second graph can meet earlier and earlier, and cause the trend like above. Step 3 Here, I used my own re-entrant barrier to plot the same graph as before in Step 2. My barrier is implemented with conditional variable and mutex lock. Each thread will wait and try to unlock the barrier in the queue, and once all threads get the signal, the program will go further to the next step.\nSpinlock is different from the mutex lock. As the professor said, spinlock causes the thread to keep rolling the lock to try to find out whether the stuff is unlocked or opened all the time. This will constantly cost CPU resources, and if the thread is locked for a long time, spinlock will keep trying to get the control and cause a lot more CPU resources waste.\nIn the scenarios of the small amount of work in each thread, the spinlock can be better, because spinlock will not waste much CPU time on waiting for the other threads to unlock. It might also boost some performance by trying to get control from those short lifetime threads. And thus in the contrast, in the scenario of a large amount of work in each thread, which means the mutex is better, because in this long waiting time scenarios if some thread wants to unlock and it will wait in a queue instead of waste CPU resources, and won’t constantly cost CPU time.\nIn addition, a multi-core scenario also can get benefit from the spinlock. When the critical section is small and multi-core environment can reduce the context switch time and that can take advantage of the spinlock.\nThe main drawback of the spinlock is that it will cost a lot amount of CPU time when the critical section was held for a long time in some thread, and the spinlock will keep trying to unlock the thread, which will waste the CPU resources.\nThe main drawback of the mutex is that if our program only has a small workload to deal with for each thread, then mutex is very inefficient. Because each thread will go sleep allow another thread to run, however, if the thread has a short lifespan, then the context switching will let the mutex become very inefficient.\nFrom the above two graphs compared to Step 2, we can see that my own barrier can’t get better performance than the Pthread barrier. From the first graph, we can see the inflection point meets later than the traditional Pthread barrier in Step 2. And from the second graph, we can compare to the average cost time of the program, the green box, indicating that our barrier is getting slower than the Pthread barrier but not that much, it only got 1000 ms average worse. But basically, the results are in line with my expectation, because the logic behind the Phtread is similar to mine. The main reason that my barrier is slightly inefficient is that I let my barrier spin a little bit to try to unlock the thread, which would cost some CPU time, and that will cause worse performance.\nI suggest using my own spinlock barrier to some tasks or some scenarios that have some small subtasks that only have a short lifespan, and the rest of the tasks has a large workload. In this scenario, my barrier will work better. Otherwise, if the tasks are all with a large workload, then I suggest using the Pthread barrier instead because it doesn’t waste any time on trying to unlock, it will go to sleep and wait in a queue and let other threads use the resources.\n","data#Data":" Data1: 1k Data2: 8k Data3: 16k Data4: seq_64_test ","implementation-details-for-work-efficiency-algorithm#Implementation Details for Work-Efficiency Algorithm":" I separate input data into same size blocks. (num_blocks = ceil(log2(N)))\nI compute local prefix sums for these blocks in parallel. It has O(num_blocks) = O(log N) time, and O(num_blocks) * ceil(N / num_blocks) ~ O(N) work.\nI store the last element of each blocks into an 2D array, and then I compute prefix sum of this 2D array in parallel, because this 2D array has very small size than input size, so I choose Hillis’s prefix sum algorithm to compute this 2D array in parallel. The main reason is in this step I do care about the time efficiency not the work efficiency in parallel, and this 2D array has very small size which is equal to the number of blocks, so here we should use work-inefficient algorithm which is Hillis’s prefix sum algorithm. It has O(log(N / num_blocks)) = O(log N) time, and O(N/num_blocks * log(N/num_blocks)) = O(n) work.\nAt last, add 2D array to each blocks in proper places in parallel. It also has O(num_blocks) = O(log N) time here, and also has O(num_blocks) * ceil(N / num_blocks) ~ O(N) work.\nAnalysis:\nTime: O(log N) Work: O(N) "},"title":"Exploring Multithreaded Programming with Pthreads Solving Parallel Prefix Scan Algorithm"},"/projects/supertuxkart/":{"data":{"":" Designed deep networks for a racing simulator, SuperTuxKart with Pytorch Trained linear model and multi-layer perceptron model to classify images from SuperTuxKart Trained a convolutional network to classify images from SuperTuxKart Built classification network fully convolutional and solved a semantic labeling task (labeling every pixel in the image) Implemented an object detector Trained a CNN to do vision-based self-driving in SuperTuxKart Programmed a SuperTuxKart ice-hockey player (AI that plays ice-hockey) "},"title":"Self-driving SuperTuxKart with Pytorch"}}