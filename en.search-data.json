{"/about/":{"data":{"":"This is the about page."},"title":"About"},"/blog/d_monotonic_stack/":{"data":{"1#1":"Coverd all topics of Monotonic Stack\n单调栈：求一个位置往左看或者往右看，第一个小于等于它的数的时候，用单调栈\n1 Leetcode 1475 最终优惠价","2#2":"Lintcode 285 高楼大厦","3#3":"Lintcode 362 滑动窗口的最大值 Leetcode 239 Sliding Window Maximum","answer#Answer":"class Solution { public: std::vector\u003cint\u003e finalPrices(std::vector\u003cint\u003e\u0026 prices) { std::deque\u003cint\u003e stack; std::vector\u003cint\u003e results(prices.begin(), prices.end()); for (int i = 0; i \u003c prices.size(); ++i) { while (!stack.empty() \u0026\u0026 prices[stack.back()] \u003e= prices[i]) { results[stack.back()] = prices[stack.back()] - prices[i]; stack.pop_back(); } stack.push_back(i); } return results; } }; class Solution: def finalPrices(self, prices: List[int]) -\u003e List[int]: stack = [] results = list(prices) for i in range(len(prices)): while stack and prices[stack[-1]] \u003e= prices[i]: results[stack[-1]] = prices[stack[-1]] - prices[i] stack.pop(-1) stack.append(i) return results","answer-brute-force#Answer: Brute Force":"class Solution { public: /** * @param arr: the height of all buildings * @return: how many buildings can he see at the location of each building */ std::vector\u003cint\u003e tallBuilding(std::vector\u003cint\u003e\u0026 arr) { // 一定能看到当前位置的楼 std::vector\u003cint\u003e results(arr.size(), 1); for (int i = 0; i \u003c arr.size(); ++i) { // 向右看能看到多少楼 CountBuildings(arr, results, i, i + 1, arr.size(), 1); // 向左看能看到多少楼 CountBuildings(arr, results, i, i - 1, -1, -1); } return results; } private: void CountBuildings(std::vector\u003cint\u003e\u0026 arr, std::vector\u003cint\u003e\u0026 results, int index, int start, int end, int delta) { int highest = 0xcfcfcfcf; int can_be_seen = 0; for (int i = start; i != end; i += delta) { if (highest \u003c arr[i]) { highest = arr[i]; ++can_be_seen; } } results[index] += can_be_seen; } }; def tall_building(self, arr: List[int]) -\u003e List[int]: # 一定能看到当前位置的楼 results = [1] * len(arr) for i in range(len(arr)): # 向右看能看到多少楼 self.count_buildings(arr, results, i, range(i + 1, len(arr))) # 向左看能看到多少楼 self.count_buildings(arr, results, i, range(i - 1, -1, -1)) return results def count_buildings(self, arr, results, index, index_list): highest, can_be_seen = float(\"-inf\"), 0 for i in index_list: if highest \u003c arr[i]: highest = arr[i] can_be_seen += 1 results[index] += can_be_seen","answer-monotonic-stack#Answer: Monotonic Stack":"class Solution { public: /** * @param arr: the height of all buildings * @return: how many buildings can he see at the location of each building */ std::vector\u003cint\u003e tallBuilding(std::vector\u003cint\u003e\u0026 arr) { // 一定能看到当前位置的楼 std::vector\u003cint\u003e results(arr.size(), 1); // 向右看能看到多少楼 CountBuildings(arr, results, 0, arr.size(), 1); // 向左看能看到多少楼 CountBuildings(arr, results, arr.size() - 1, -1, -1); return results; } private: void CountBuildings(std::vector\u003cint\u003e\u0026 arr, std::vector\u003cint\u003e\u0026 results, int start, int end, int delta) { std::deque\u003cint\u003e stack; for (int i = start; i != end; i += delta) { results[i] += stack.size(); // 在这里记录答案，与模版不同 while (!stack.empty() \u0026\u0026 arr[stack.back()] \u003c= arr[i]) { stack.pop_back(); } stack.push_back(i); } } }; def tall_building(self, arr: List[int]) -\u003e List[int]: # 一定能看到当前位置的楼 results = [1] * len(arr) # 向右看能看到多少楼 self.count_buildings(arr, results, range(len(arr))) # 向左看能看到多少楼 self.count_buildings(arr, results, range(len(arr) - 1, -1, -1)) return results def count_buildings(self, arr, results, index_list): stack = [] for i in index_list: results[i] += len(stack) # 在这里记录答案，与模版不同 while stack and arr[stack[-1]] \u003c= arr[i]: stack.pop(-1) stack.append(i)","answer-枚举所有窗口-time-limit-exceeded#Answer: 枚举所有窗口: Time Limit Exceeded":"class Solution { public: std::vector\u003cint\u003e maxSlidingWindow(std::vector\u003cint\u003e\u0026 nums, int k) { std::vector\u003cint\u003e results; if (nums.size() == 0) { return results; } int n = nums.size(); for (int i = 0; i \u003c n - k + 1; ++i) { int max_value = 0xcfcfcfcf; for (int j = i; j \u003c i + k; ++j) { max_value = std::max(max_value, nums[j]); } results.push_back(max_value); } return results; } }; class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: if not nums: return [] results = [] n = len(nums) for i in range(0, n - k + 1): max_value = -float(\"inf\") for j in range(i, i + k): max_value = max(max_value, nums[j]) results.append(max_value) return results","follow-up-思路#Follow Up 思路":"待补充。。。","template#Template":"for i from [0, (n - 1)] while 栈不空 and 单调性不存在 记录此时的答案 # 一般情况下是放在弹出栈之前的(弹前，弹中，弹后) stack.pop() stack.push(i) # 是下标，不是值","time-complexity#Time Complexity":"与同向双指针类似，在双指针中，每个元素最多被每个指针扫过一次，所以每个元素最多被扫过两次，总共2n次 ==\u003e O(N) # 同向双指针模版 end = 0 for start in range(len): # 不满足则循环到满足搭配为止 while end \u003c len and (start 到 end 之间不满足条件): end += 1 if start 到 end 之间满足条件: 处理 start 到 end 这段区间(处理start, end这次搭配) 单调栈中，每一个下标最多入栈或出栈一次（即只入，或入+出），总共2n次 ==\u003e O(N)","复杂度分析#复杂度分析":"由于每个下标都最多入栈、出栈各一次 总时间复杂度为O(n + n) = O(n) 空间复杂度为O(n) 单调栈的特点：时空复杂度O(n)、编程复杂度低，思维复杂度高","复杂度分析brute-force#复杂度分析：Brute Force":"遍历每个下标 i: O(N) 每个下标 i 向左右查找整个数组: O(N) 总时间复杂度: O(N^2) 空间复杂度: O(N)","复杂度分析枚举所有窗口#复杂度分析：枚举所有窗口":"窗口的长度给定，只需要枚举起点:O(n) 打擂台计算窗口内的最大值:O(k) 总时间复杂度:O(n * k) 需要存放答案，空间复杂度:O(n)","总结#总结":"单调栈在入栈之前，要判断单调性存不存在：如果不存在，我们要不断地弹出，直到单调性重新存在。","注意#注意":"单调栈的单调性，从一开始到最后，都应该保持一致。 单个元素，单调性存在。 如果发现我的算法需要将一个元素，反复入栈，反复出栈，就不是单调栈算法，不符合单调栈最基本的特点。","解法一brute-force#解法一：Brute Force":"枚举下标，分别向左向右，计算能看到多少个楼 需要记录当前看到的最高楼 highest 通过打擂台算法不断更新 highest, 每次更新就说明又看到了一个楼 记录更新的次数即可","解法一枚举所有窗口#解法一：枚举所有窗口":"本题仍然属于子数组问题 最直接的办法依然是枚举子数组 由于子数组长度已给出，所以不需要枚举终点 每个子数组打擂台算出最大值","解法二monotonic-stack#解法二：Monotonic Stack":"对于疑似单调栈的问题，一定要通过样例模拟 从头到尾，从尾到头进行两次单调栈 分别站在某个位置上向左，向右能看见多少楼房 入栈前的栈的大小就是能看见的房子数量","解释#解释":"只要单调栈中的元素开始出栈，证明它们应该开始被计算结果。\u003c==\u003e 如果它们要被计算结果，我们要把他们出栈。"},"title":"Draft: Monotonic Stack"},"/blog/d_note_system/":{"data":{"":"Covered topics of system design","4s-analysis#4S analysis":"Scenario 场景 说人话：需要设计哪些功能，设计得多牛 Ask/ Features/ QPS/ DAU/ Interfaces 具体场景有哪些 实际需求有什么 详细流程怎么样 Service 服务 说人话：将大系统拆分为小服务 Split/ Application/ Module 单体架构 X or 微服务 V Storage 存储 说人话：数据如何存储与访问 Schema/ Data/ SQL/ NoSQL/ File System 数据如何存储与访问 1.select 为每个Service 选择存储结构 2.Schema 细化表结构 Note: 分布式事务distributed transaction Scale 升级 说人话：解决缺陷，处理可能遇到的问题 Sharding/ Optimize/ Special Case 如何优化系统 加分项 Flash Sale \u0026 Booking System Design\n场景1：0点开始，限量100台，一人限购一台 场景2: 微信抢红包"},"title":"Draft: System Design"},"/blog/d_thread_communication/":{"data":{"":"Pthread for inter-threads communication.\nPthreads There are a few ways to communicate between threads in pthread.\nOne way is to use shared memory. Shared memory is a region of memory that is accessible to all threads in a process. To use shared memory, you first need to allocate a region of memory. You can do this using the malloc() function. Once you have allocated a region of memory, you can then share it with other threads by using the shmget() function.\nAnother way to communicate between threads in pthread is to use semaphores. Semaphores are a type of synchronization primitive that allows you to control access to a shared resource. To use semaphores, you first need to create a semaphore. You can do this using the sem_init() function. Once you have created a semaphore, you can then use it to control access to a shared resource. For example, you can use a semaphore to ensure that only one thread can access a shared variable at a time.\nFinally, you can also use pipes to communicate between threads in pthread. Pipes are a type of inter-process communication (IPC) mechanism that allows you to send data between processes. To use pipes, you first need to create a pipe. You can do this using the pipe() function. Once you have created a pipe, you can then use it to send data between threads. For example, you can use a pipe to send a message from one thread to another."},"title":"Draft: Inter-threads Communication"},"/blog/d_union_find/":{"data":{"":"Coverd all topics of Union Find\nIt’s a data structure that supports fast merging and searching of sets\nO(1) merge the two sets where x and y are located: Merge(x, y) – connect the roots O(1) find the set to which x belongs: Find(x) – find the root O(1) check wheter x and y are in the same set: IsConnected(x, y) – check if they have the same root Graph: may have cycle Tree: no cycle Necessary and sufficient conditions for a graph to be a tree: There are n vertices on the graph and only n-1 edges. n points are connected (belong to the same connected block)","bfs#BFS":"class Solution { public: bool validTree(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 edges) { // checking for condition 1 if (edges.size() + 1 != n) return false; // build graph unordered_map\u003cint, vector\u003cint\u003e\u003e graph; for (int i = 0; i \u003c edges.size(); ++i) { graph[edges[i][0]].push_back(edges[i][1]); graph[edges[i][1]].push_back(edges[i][0]); } // BFS: checking for condition 2 deque\u003cint\u003e q; unordered_set\u003cint\u003e visited; q.push_back(0); visited.insert(0); while (!q.empty()) { int size = q.size(); for (int i = 0; i \u003c size; ++i) { int curr = q.front(); q.pop_front(); for (int j = 0; j \u003c graph[curr].size(); ++j) { if (visited.find(graph[curr][j]) != visited.end()) continue; q.push_back(graph[curr][j]); visited.insert(graph[curr][j]); } } } return visited.size() == n; } };","follow-upunion-find-come-up-with-a-better-approach-for-addedgex-y-and-isvalidtree#Follow-up(Union Find): come up with a better approach for AddEdge(x, y) and IsValidTree()":"解决连通性问题的利器 – Union Find\nLintcode 444. Graph Valid Tree II\nclass Solution { public: void addEdge(int a, int b) { } bool isValidTree() { } };","leetcode-261-graph-valid-tree#Leetcode 261. Graph Valid Tree":"Leetcode 261. Graph Valid Tree"},"title":"Union Find"},"/blog/deadlock/":{"data":{"1-self-deadlock--recursive-deadlock#1. Self deadlock \u0026amp;\u0026amp; Recursive Deadlock":"The most common error causing deadlock is\nSelf deadlock: a thread tries to acquire a lock it is already holding. Recursive deadlock: is very easy to program by mistake. For example, if a code monitor has every module function grabbing the mutex lock for the duration of the call, then any call between the functions within the module protected by the mutex lock immediately deadlocks. If a function calls some code outside the module which, through some circuitous path, calls back into any method protected by the same mutex lock, then it will deadlock too.","2-permanent-blocking-of-threads#2. Permanent blocking of threads":"An example of another kind of deadlock is when two threads, thread 1 and thread 2, each acquires a mutex lock, A and B, respectively. Suppose that thread 1 tries to acquire mutex lock B and thread 2 tries to acquire mutex lock A. Thread 1 cannot proceed and it is blocked waiting for mutex lock B. Thread 2 cannot proceed and it is blocked waiting for mutex lock A. Nothing can change, so this is a permanent blocking of the threads, and a deadlock.","3-deadlocks-related-to-scheduling#3. Deadlocks Related to Scheduling":"Because there is no guaranteed order in which locks are acquired, a problem in threaded programs is that a particular thread never acquires a lock, even though it seems that it should.\nThis usually happens when the thread that holds the lock releases it, lets a small amount of time pass, and then reacquires it. Because the lock was released, it might seem that the other thread should acquire the lock. But, because nothing blocks the thread holding the lock, it continues to run from the time it releases the lock until it reacquires the lock, and so no other thread is run.\nYou can usually solve this type of problem by calling thr_yield(3T) just before the call to reacquire the lock. This allows other threads to run and to acquire the lock.\nBecause the time-slice requirements of applications are so variable, the threads library does not impose any. Use calls to thr_yield() to make threads share time as you require.","avoid-deadlock-in-concurrent-programming#Avoid Deadlock in Concurrent Programming":"Deadlock is a permanent blocking of a set of threads that are competing for a set of resources. Just because some thread can make progress does not mean that there is not a deadlock somewhere else.","locking-guidelines#Locking Guidelines":"Here are some simple guidelines for locking.\nTry not to hold locks across long operations like I/O where performance can be adversely affected. Don’t hold locks when calling a function that is outside the module and that might reenter the module. In general, start with a coarse-grained approach, identify bottlenecks, and add finer-grained locking where necessary to alleviate the bottlenecks. Most locks are held for short amounts of time and contention is rare, so fix only those locks that have measured contention. When using multiple locks, avoid deadlocks by making sure that all threads acquire the locks in the same order.","situations-of-deadlock#Situations of deadlock":"Deadlock defination and how to prevent deadlock.\nSituations of deadlock In concurrent computing, deadlock is any situation in which no member of some group of entities can proceed because each waits for another member, including itself, to take action, such as sending a message or, more commonly, releasing a lock. Deadlocks are a common problem in multiprocessing systems, parallel computing, and distributed systems, because in these contexts systems often use software or hardware locks to arbitrate shared resources and implement process synchronization.\nIn an operating system, a deadlock occurs when a process or thread enters a waiting state because a requested system resource is held by another waiting process, which in turn is waiting for another resource held by another waiting process. If a process remains indefinitely unable to change its state because resources requested by it are being used by another process that itself is waiting, then the system is said to be in a deadlock.\nIn a communications system, deadlocks occur mainly due to loss or corruption of signals rather than contention for resources.","solution#Solution":"The solution for this kind of deadlock is to avoid calling functions outside the module when you don’t know whether they will call back into the module without reestablishing invariants and dropping all module locks before making the call. Of course, after the call completes and the locks are reacquired, the state must be verified to be sure the intended operation is still valid.\nSummary: avoid calling functions outside the module and if called, it has to be verified the intended operation is still valid.","solution1-lock-hierarchy#Solution1: lock hierarchy":"This kind of deadlock is avoided by establishing an order in which locks are acquired (a lock hierarchy). When all threads always acquire locks in the specified order, this deadlock is avoided.\nSummary: not optimal. The discarded lock might have many assumptions and need to reevaluate later.","solution2-mutex_trylock#Solution2: mutex_trylock()":"Adhering to a strict order of lock acquisition is not always optimal. When thread 2 has many assumptions about the state of the module while holding mutex lock B, giving up mutex lock B to acquire mutex lock A and then reacquiring mutex lock B in order would cause it to discard its assumptions and reevaluate the state of the module.\nThe blocking synchronization primitives usually have variants that attempt to get a lock and fail if they cannot, such as mutex_trylock().\nSummary: optimal. This allows threads to violate the lock hierarchy when there is no contention. When there is contention, the held locks must usually be discarded and the locks reacquired in order."},"title":"Deadlock"},"/blog/dijkstra/":{"data":{"":"","heap-optimized-dijkstrafor-sparse-graph#Heap-optimized Dijkstra(for sparse graph)":"class Solution { public: int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e ×, int n, int k) { vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e g(n); // 邻接表 for (auto \u0026t : times) { g[t[0] - 1].emplace_back(t[1] - 1, t[2]); } vector\u003cint\u003e dis(n, INT_MAX); dis[k - 1] = 0; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, greater\u003c\u003e\u003e pq; pq.emplace(0, k - 1); while (!pq.empty()) { auto [dx, x] = pq.top(); pq.pop(); if (dx \u003e dis[x]) { // x 之前出堆过 continue; } for (auto \u0026[y, d] : g[x]) { int new_dis = dx + d; if (new_dis \u003c dis[y]) { dis[y] = new_dis; // 更新 x 的邻居的最短路 pq.emplace(new_dis, y); } } } int mx = ranges::max(dis); return mx \u003c INT_MAX ? mx : -1; } };","leetcode-743-network-delay-time#Leetcode 743 Network Delay Time":"Leetcode 743","naive-dijkstrafor-dense-graph#Naive Dijkstra(for dense graph)":"class Solution { public: int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e ×, int n, int k) { vector\u003cvector\u003cint\u003e\u003e g(n, vector\u003cint\u003e(n, INT_MAX / 2)); // 邻接矩阵 for (auto \u0026t : times) { g[t[0] - 1][t[1] - 1] = t[2]; } vector\u003cint\u003e dis(n, INT_MAX / 2), done(n); dis[k - 1] = 0; while (true) { int x = -1; for (int i = 0; i \u003c n; i++) { if (!done[i] \u0026\u0026 (x \u003c 0 || dis[i] \u003c dis[x])) { x = i; // 可以提前结束吗 } } if (x \u003c 0) { // all done return ranges::max(dis); } if (dis[x] == INT_MAX / 2) { // 有节点无法到达 return -1; } done[x] = true; // 最短路长度已确定（无法变得更小） for (int y = 0; y \u003c n; y++) { // 更新 x 的邻居的最短路 dis[y] = min(dis[y], dis[x] + g[x][y]); } } } };"},"title":"Dijkstra"},"/blog/dp-memo-to-iteration/":{"data":{"":"","198---house-robber#198 - House Robber":"class Solution: def rob(self, nums: List[int]) -\u003e int: n = len(nums) f0 = f1 = 0 for i, x in enumerate(nums): f0, f1 = f1, max(f0 + x, f1) return f1 # cahce = [-1] * n # def dfs(i): # if i \u003c 0: # return 0 # if cache[i] != -1: # return cache[i] # cache[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]) # return cache[i] class Solution { public: int rob(vector\u003cint\u003e\u0026 nums) { // int n = nums.size(); // int f0 = 0, f1 = 0; // for (int i = 0; i \u003c n; ++i) { // int x = nums[i]; // int new_f1 = max(f0 + x, f1); // f0 = f1; // f1 = new_f1; // } // return f1; // Below is the optional recursive + memoized (DFS + cache) version int n = nums.size(); vector\u003cint\u003e cache(n, -1); return dfs(n - 1, nums, cache); } int dfs(int i, vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 cache) { if (i \u003c 0) return 0; if (cache[i] != -1) return cache[i]; cache[i] = max(dfs(i - 1, nums, cache), (i \u003e= 1 ? dfs(i - 2, nums, cache) : 0) + nums[i]); return cache[i]; } // // corner cases // if (nums.size() == 0) return 0; // if (nums.size() == 1) return nums[0]; // // dp // // f[i] represents: max money by robbing previous i houses // vector f(3, 0); // f[0] = nums[0]; // f[1] = max(nums[0], nums[1]); // for (int i = 2; i \u003c nums.size(); ++i) { // f[i % 3] = max(nums[i] + f[(i - 2) % 3], f[(i - 1) % 3]); // } // return f[(nums.size() - 1) % 3]; };"},"title":"DP Memo to Iteration"},"/blog/dynamic_programming/":{"data":{"":"Covered all topics of Dynamic Programming\nChapter 1: DP 入门 DP题目特点 最值型动态规划 \u0026\u0026 DP组成部分一：确定状态 递归写法的不可行性 递归写法 递归写法的问题 DP组成部分二：转移方程（到此对了一半，比确定状态简单一些） DP组成部分三：初始条件和边界情况 DP组成部分四：计算顺序 Time Complexity Coding 669 计数型动态规划 DP组成部分一：确定状态 DP组成部分二：转移方程 DP组成部分三：初始条件和边界情况 DP组成部分四：计算顺序 Coding 存在型动态规划 DP组成部分一：确定状态 DP组成部分二：转移方程 DP组成部分三：初始条件和边界情况 DP组成部分四：计算顺序 Coding In summary Exercise1: 金字塔 Exercise2: 乘积最大子序列 Chapter 2: 动态规划初探 + 坐标型动态规划 + 位操作型动态规划 初探 坐标型动态规划 题目分析 初始条件和边界情况 Coding 初探 序列型动态规划 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding In summary: seq-type 初探 划分型动态规划 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding 坐标型动态规划：最小路径和 坐标型动态规划：最小路径和–路径打印 坐标型动态规划：最小路径和–空间优化 坐标型动态规划：炸弹袭击 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 四个方向 Coding 坐标型动态规划 总结 位操作型动态规划：Counting Bits 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding Exercise: 最长上升子序列 Chapter 3: 打劫房屋: 坐标型，前缀型 坐标型 动态规划 代码思路 前缀型 Chapter 4: 最大矩形 \u0026\u0026 最大直方图：坐标型 最大矩形 直方图最大矩形覆盖 Chapter 5: 最短假期：坐标型 Exercise: 相关题目 Chapter 6: 最小调整代价：背包型 状态 转移方程 思路 1.临界值： 2.状态转移方程： Coding Chapter 7: 香槟塔：坐标型 Step 1 : 如何定义状态？ Step 2 : 临界值是什么？ Step 3 : 状态转移方程怎么写？ Step 4 : DP结果是什么？ 空间优化： Soluton 1: row % 2 Soluton 2: 一维数组 Chapter 8: 飞行棋I Step 1 : 如何定义状态？ Step 2 : 临界值是什么？ Step 3 : 状态转移方程怎么写？ Step 4 : DP结果是什么？ DP Solution Chapter 9: 序列型动态规划 序列型动态规划–简介 序列型动态规划–数字翻转 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding Mine Correct Solution Official Solution 序列型动态规划的时间优化–房屋染色II Mine Correct Answer O(nk^2) 时间优化 Mine correct time optimized solution Official time optimized solution 序列型动态规划–买卖股票1 动态规划解法 Mine correct solution Official solution: Better 序列型动态规划–买卖股票2 题目分析 Official solution 序列型动态规划–买卖股票3: 序列型 题目分析 动态规划组成部分一：确定状态 记录阶段 动态规划组成部分一：确定状态 continued 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution 序列型动态规划–买卖股票4 题目分析 记录阶段 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution Official Solution : rolling array optimization 序列型动态规划–小结 初探 最长上升子序列(LIS) 最长序列型动态规划 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 思考：如何做到时间复杂度O(nlogn) Official Solution: O(n^2) phone interview Exercise 602 俄罗斯套娃信封 Mine first solution: Time Limit Exceeded: dp Mine second solution: Time Limit Exceeded: dfs Correct forum official solution 课后习题 Chapter 10: 骰子求和：背包型 背包型 Chapter 11: 最长有效括号：后缀型(与前缀型只区别与计算顺序) Chapter 12: 最大子数组差 Mine solution Official Solution: with some Greedy idea 相关题目 Chapter 13: 工作安排：坐标型 Chapter 14: 染色问题：坐标型 Chapter 15: 最小的窗口子序列：匹配型 The first solution with O(n^2 * (n + m)) approximate to O(n^3) The second solution with O(n * (n + m)) approximate to O(n^2), we should let time less than 10^8, if n is 20000, then it becomes 4 * 10^8 \u003e 10^8, which is not good The thrid solution: Dynamic Programming: Time O(n * m) Space O(n * m) Relative Problems Chapter 16: 划分型、博弈型 和 背包型 动态规划 划分型动态规划 Example: Lintcode 513 Perfect Square：划分型 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding Solution Follow up Example: Lintcode 108 Palindrome Partitioning II 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 回文串判断 回文串种类 生成回文串 在字符串中找到所有回文串 记录回文串 回到原题 Example: Lintcode 437 Copy Books 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Coding: The First Solution with DP Coding: The Second Solution with Binary Search Summary 博弈型动态规划 Example: Lintcode 394 Coins in a Line 动态规划组成部分一：确定状态 博弈型动态规划：必胜 vs 必败 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution The Second Solution with Time O(1) Space O(1) 背包型动态规划 直觉 Example: Lintcode 92 Backpack 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 DP Official Solution Backpack Official Solution Summary Example: Lintcode 563 Backpack V 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution 进一步空间优化 My Correct Solution Exercise: Lintcode 564 BackPack IV (组合总和 IV) 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Offical Solution Summary Exercise: Single Choice Chapter 17: 背包型 和 区间型 动态规划 01 backpack 打印路径 complete backpack multiple backpack 区间型动态规划 Example: Lintcode 667 Longest Palindrome Subsequence 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Official Solution 记忆化搜索方法 与递推方法比较 Coding with Template (important) Example: Lintcode 396 Coins in A Line III （区间型动态规划—博弈问题） 博弈 动态规划组成部分一：确定状态 博弈子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 430 Scramble String 动态规划组成部分一：确定状态 子问题 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 记忆化搜索 Example: Lintcode 168 吹气球 (消去型 –\u003e 区间型) 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Summary Chapter 18: 石头碰撞：背包型 Chapter 19: 合并金币：区间型 Chapter 20: 外卖满减：01背包 Exercise Lintcode 92 backpack Exercise Lintcode 125 backpack II Exercise Lintcode 563 backpack V Chapter 21: 考试策略：0/0.5/1背包 Exercise Lintcode 1538 卡牌游戏 II Exercise Lintcode 700 杆子分割 Chapter 22: 双序列动态规划 Example: Lintcode 77 最长公共子序列 题目分析 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 打印最长公共子序列 Example: Lintcode 29 交叉字符串 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 滚动数组优化 Example: Lintcode 119 编辑距离 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 滚动数组优化 编辑距离的实际用途 Example: Lintcode 154 Regular Expression Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 192 Wildcard Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 668 Ones and Zeroes：双背包 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 118 Distinct Subsequences Chapter 23: 毕业旅行 Solution 1: 排列型DFS 分析 AC Optimize: Pruning Solution 2: 状态压缩型动态规划??? Chapter 24: 双色塔 Chapter 25: 编辑距离 Example: Lintcode 119 编辑距离 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 滚动数组优化 编辑距离的实际用途 Example: Lintcode 154 Regular Expression Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 192 Wildcard Matching 动态规划组成部分一：确定状态 子问题 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 668 Ones and Zeroes：双背包 动态规划组成部分一：确定状态 动态规划组成部分二：转移方程 动态规划组成部分三：初始条件和边界情况 动态规划组成部分四：计算顺序 Example: Lintcode 118 Distinct Subsequences Chapter 23: 毕业旅行 Solution 1: 排列型DFS 分析 AC Optimize: Pruning Solution 2: 状态压缩型动态规划??? Chapter 24: 双色塔 Chapter 25: 编辑距离 (Really Important) The most relevant problem Relevant Problems Chapter 26: 动态规划难题专场 Lintcode 752 Rogue Knight Sven Others Note 动态规划的题型 简历: 最好一页 How to use heap in c++ Others Note 动态规划的题型 简历: 最好一页 How to use heap in c++","01-backpack#01 backpack":"Lintcode 125 Backpack II class Solution { public: int backPackII(int m, std::vector\u003cint\u003e\u0026 A, std::vector\u003cint\u003e\u0026 V) { int n = A.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n + 1, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= m; ++j) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (j - A[i - 1] \u003e= 0) { dp[i][j] = std::max(dp[i - 1][j - A[i - 1]] + V[i - 1], dp[i - 1][j]); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[n][m]; } };","1临界值#1.临界值：":"dp[0][j] = abs(j - A[0])","2状态转移方程#2.状态转移方程：":"dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - A[i])) 最后在所有最后一位的可能解dp[n-1][i]中的最小值，就是我们所求的最小代价。 假设数组长度为n 空间复杂度O(10000*n) 时间复杂度O(n^2)","ac#AC":"class Solution { public: int minCost(int nn, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { // costs: [[i, j, d]] i----j cost is d n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u003cint\u003e(n, 0x3f3f3f3f)); for (i = 0; i \u003c costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; // 第0个城市搞过了 dfs(1, 0, 0); // 第1个城市; 前一个城市是0; 当前花费时间是0 return result; } private: // level is the level-th city // previous city p // current cost c void dfs(int level, int p, int c) { if (level == n) { if (c \u003c result) { result = c; } return; } int i; // next city i, from p // p--\u003ei must have a road for (i = 0; i \u003c n; ++i) { if (!done[i] \u0026\u0026 g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u003cstd::vector\u003cint\u003e\u003e g; // g[i][j] is the cost to go from city i to j (\u003c---\u003e 双向) std::vector\u003cbool\u003e done; int result; };","ac-1#AC":"class Solution { public: int minCost(int nn, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { // costs: [[i, j, d]] i----j cost is d n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u003cint\u003e(n, 0x3f3f3f3f)); for (i = 0; i \u003c costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; // 第0个城市搞过了 dfs(1, 0, 0); // 第1个城市; 前一个城市是0; 当前花费时间是0 return result; } private: // level is the level-th city // previous city p // current cost c void dfs(int level, int p, int c) { if (level == n) { if (c \u003c result) { result = c; } return; } int i; // next city i, from p // p--\u003ei must have a road for (i = 0; i \u003c n; ++i) { if (!done[i] \u0026\u0026 g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u003cstd::vector\u003cint\u003e\u003e g; // g[i][j] is the cost to go from city i to j (\u003c---\u003e 双向) std::vector\u003cbool\u003e done; int result; };","backpack-official-solution#Backpack Official Solution":"class Solution { public: int backPack(int m, std::vector\u003cint\u003e\u0026 A) { int n = A.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n + 1, std::vector\u003cint\u003e(m + 1)); for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= m; ++j) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (j - A[i - 1] \u003e= 0) { dp[i][j] = std::max(dp[i - 1][j - A[i - 1]] + A[i - 1], dp[i - 1][j]); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[n][m]; } };","chapter-1-dp-入门#Chapter 1: DP 入门":"","chapter-10-骰子求和背包型#Chapter 10: 骰子求和：背包型":"Lintcode 20 骰子求和 本质上这道题是求方案数\n核心的是看状态是什么：\n状态：用来表示一个子问题的一些参数凑在一起 这道题的状态：","chapter-11-最长有效括号后缀型与前缀型只区别与计算顺序#Chapter 11: 最长有效括号：后缀型(与前缀型只区别与计算顺序)":"Lintcode 193 最长有效括号\n字符串的题目特别多的题目都是前缀型 或 后缀型\n设状态dp[i]为从i到len - 1中，以i开头的最长合法子串长度 初始化：dp[len - 1] = 0 如果s[i] = ')'，则跳过，因为不可能有由'('开头的串 如果s[i] = '(', 则需要找到右括号和它匹配。可以跳过以i + 1开头的合法子串，看j = i + dp[i + 1] + 1的位置是否为右括号。 如果位置i没越界且为右括号，那么有dp[i] = dp[i + 1] + 2，此外在这个基础上还要将j + 1开头的子串加进来（只要不越界）。 class Solution { public: int longestValidParentheses(std::string\u0026 s) { int n = s.size(); if (n \u003c 2) { return 0; } int result = 0; // int dp[n] should have an additional step to initialize all elements to zero std::vector\u003cint\u003e dp(n, 0); for (int i = n - 2; i \u003e= 0; --i) { if (s[i] == '(') { int j = i + dp[i + 1] + 1; // 如果没越界且为右括号 if (j \u003c n \u0026\u0026 s[j] == ')') { dp[i] = dp[i + 1] + 2; // 还要将j + 1开头的子串加进来 if (j + 1 \u003c n) { dp[i] += dp[j + 1]; } } result = std::max(result, dp[i]); } } return result; } };","chapter-12-最大子数组差#Chapter 12: 最大子数组差":"Lintcode 45 最大子数组差\n关键字不重叠，应该想到隔板法\n因为区间不重合，那么他们肯定会被一个隔板隔开，我们枚举隔板，再去算左右两边的 最大区间和 和 最小区间和","chapter-13-工作安排坐标型#Chapter 13: 工作安排：坐标型":"Lintcode 1147 工作安排 Compared to the question of house robbers, not only do we have to decide whether to pick the task(whether to rob the current house) but also we have to determine what task we will choose(simple or complex)\n状态：令dp[i]表示前i周可完成的最大价值 状态转移：dp[i] = max(dp[i - 1] + low[i], dp[i - 2] + high[i]) 临界值：第一周只能选择简单任务 class Solution { public: int workPlan(std::vector\u003cint\u003e\u0026 low, std::vector\u003cint\u003e\u0026 high) { int n = low.size(); int dp[n]; if (n == 0) { return 0; } dp[0] = low[0]; for (int i = 1; i \u003c n; ++i) { if (i \u003c 2) { dp[i] = std::max(dp[i - 1] + low[i], high[i]); continue; } dp[i] = std::max(dp[i - 1] + low[i], dp[i - 2] + high[i]); } return dp[n - 1]; } }; 思考：如果有负数怎么办？","chapter-14-染色问题坐标型#Chapter 14: 染色问题：坐标型":"Lintcode 1444 染色问题\nState: let dp[i] represents the total number of plans when circle is divided into i sectors\nInitialization:\nwhen i == 1, we can use at least 1 color, A(m, 1) : dp[1] = m when i % 2 == 0, we can use at least 2 color, A(m, 2) : dp[2] = m * (m - 1) when i % 2 == 1 \u0026\u0026 i \u003e= 3, we can use at least 3 color, A(m, 3) : dp[3] = m * (m - 1) * (m - 2) Function:\nthe n sectors problem can be derived from n - 1 sectors sub-problem and n - 2 sectors sub-problem Regarding to n - 1 sectors sub-problem, it has dp[n - 1] color plans. Due to the colors of adjacent sectors cannot be the same, when we insert a new sector between two sectors, the number of plans is m - 2, and then the total number of color plans is dp[n - 1] * (m - 2) function 1: dp[i] += dp[i - 1] * (m - 2) Regarding to n - 2 sectors sub-problem, it has dp[n - 2] color plans We just choose one sector and then split it into two sectors with the same colors, and then insert a new sector between these two same color sectors. Then we have dp[n - 2] * (m - 1) the number of color plans function 2: dp[i] += dp[i - 2] * (m - 1) Answer:\nWhen calculating the result, we should add module operation within calculation to avoid overflowing dp[n] is the final answer Time Complexity: O(n) Space Complexity: O(n)\nclass Solution { public: int getCount(int n, int m) { long long MOD = 1000000007; // long long dp[n + 3]; // ERROR: each value has to be initialized to zero // dp[i] represent number of color plans when we have i sectors and m colors std::vector\u003clong long\u003e dp(n + 3, 0); // one sector has m color plans dp[1] = m % MOD; // two sectors have m * (m - 1) color plans dp[2] = (long long)m * (m - 1) % MOD; // three sectors have m * (m - 1) * (m - 2) color plans dp[3] = (long long)m * (m - 1) * (m - 2) % MOD; for (int i = 4; i \u003c= n; ++i) { dp[i] += dp[i - 1] * (m - 2) % MOD; dp[i] += dp[i - 2] * (m - 1) % MOD; dp[i] %= MOD; // dp[i] = (dp[i - 1] * (m - 2) + dp[i - 2] * (m - 1)) % MOD; // alternative } return (int)dp[n]; } }; Note: long long dp[n + 5]; // each value has to be initialized to zero we can also optimize space with rolling array","chapter-15-最小的窗口子序列匹配型#Chapter 15: 最小的窗口子序列：匹配型":"Lintcode 857 MinWindow This problem is very similar to The Problem of LCS and The Problem of Edit Distance, given two strings which means 匹配型动态规划\n匹配型动态规划开(n + 1)(m + 1)的数组， 类似于背包型动态规划 这个题的题目名看起来和很多题目有相似之处，如“滑动窗口的最小值”等，那里我们使用单调队列进行求解，不要弄混","chapter-16-划分型博弈型-和-背包型-动态规划#Chapter 16: 划分型、博弈型 和 背包型 动态规划":"","chapter-17-背包型-和-区间型-动态规划#Chapter 17: 背包型 和 区间型 动态规划":"","chapter-18-石头碰撞背包型#Chapter 18: 石头碰撞：背包型":"Lintcode 724 最小划分\n分析也许和coding不一致，只能做参考\n使用i循环从1到石头总和 / 2大小的背包 dp[j]代表将容量为j的01背包装满是否可行，如果可行，|sum - j - j|即为目前的碰撞结果 每装满一个大小为x的01背包，都要维护|sum - 2x|的最小值 class Solution { public: int findMin(std::vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n == 0) return 0; if (n == 1) return nums[0]; int sum = 0; for (int i = 0; i \u003c n ; ++i) sum += nums[i]; std::vector\u003cint\u003e dp(sum / 2 + 1); dp[0] = 0; for (int i = 0; i \u003c n; ++i) for (int j = sum / 2; j \u003e= nums[i]; --j) dp[j] = dp[j - nums[i]] + nums[i] \u003e dp[j] ? dp[j - nums[i]] + nums[i] : dp[j]; return std::abs(sum - 2 * dp[sum / 2]); } };","chapter-19-合并金币区间型#Chapter 19: 合并金币：区间型":"Lintcode 476 石子合并\n这道题是一道区间dp的入门题，通过理解状态转移的过程，决定循环的要素。在这题里，我们需要先枚举区间长度，再枚举起点。这就是区间dp的精髓。让我们一起来亲手做一下这道题目吧~\n我们令dp[i][j]为从 第i堆金币到第j堆金币所需的最小代价\n区间[i, j]可以从以任意的i \u003c= k \u003c j为分割点所得的两个子区间得来\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j])\nsum[i][j]表示区间[i, j]的数字和，可以使用前缀和来维护\n区间DP通用思路： 目标是求解在一个区间上的最优解，那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可 本题思路： 枚举区间长度 len 为每次分割成的小区间长度（由短到长不断合并），内层枚举该长度下的可能起点，并按照 len 计算终点。然后在这个起点终点之间枚举分割点 k ，求解这段以 i 为起点。长度为 len 的小区间在某个 k 的最优解。 class Solution { public: int stoneGame(std::vector\u003cint\u003e\u0026 A) { int n = A.size(); if (n == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n, std::vector\u003cint\u003e(n, 0)); std::vector\u003cint\u003e sum(n + 1, 0); // prefix sum for (int i = 1; i \u003c n + 1; ++i) { sum[i] = sum[i - 1] + A[i - 1]; } for (int len = 2; len \u003c= n; ++len) { for (int i = 0; i \u003c= n - len; ++i) { int j = i + len - 1; dp[i][j] = 0x3f3f3f3f; int least_sum = sum[j + 1] - sum[i]; for (int k = i; k \u003c j; ++k) { // 当前区间由子区间得到 dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k + 1][j] + least_sum); } } } return dp[0][n - 1]; } }; Lintcode 593 Stone Game II Lintcode 168 Burst Ballon","chapter-2-动态规划初探--坐标型动态规划--位操作型动态规划#Chapter 2: 动态规划初探 + 坐标型动态规划 + 位操作型动态规划":"","chapter-20-外卖满减01背包#Chapter 20: 外卖满减：01背包":"输入\u0026输出 输入：5 20 [18, 19, 17, 6, 7] 输出：23 class Solution { public: std::vector minimumPrice(int n, int X, std::vector\u003cint\u003e price) { int total_price = 0; for (int i = 0; i \u003c n; ++i) { total_price += price[i]; } // 转化为容量为 total_price 的 01背包 // dp[i] 为 true 表示可以选择总价恰好为 i 的物品 std::vector\u003cbool\u003e dp(total_price + 1, false); for (int i = 0; i \u003c n; ++i) { for (int j = total_price; j \u003e= price[i]; --j) { dp[j] |= dp[j - price[i]]; } } // 找到 \u003e= X 的最小价格 for (int i = X; i \u003c= total_price; ++i) { if (dp[i]) { return i; } } return -1; } };","chapter-21-考试策略0051背包#Chapter 21: 考试策略：0/0.5/1背包":"Lintcode 273 考试策略\n做一部分：(满足p[i - 1] \u003c= j): part = dp[i - 1][j - p_time[i - 1]] + p_score[i - 1]\n全做完：(满足f[i - 1] \u003c= j): full = dp[i - 1][j - f_time[i - 1]] + f_score[i - 1]\ndp[i][j]= max(part, full, dp[i - 1][j])\nclass Solution { public: int exam(std::vector\u003cint\u003e\u0026 p, std::vector\u003cint\u003e\u0026 part, std::vector\u003cint\u003e\u0026 f, std::vector\u003cint\u003e\u0026 full) { int n = p.size(); int m = 120; std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n + 1, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { dp[i][j] = dp[i - 1][j]; if (j - p[i - 1] \u003e= 0) { dp[i][j] = std::max(dp[i][j], dp[i - 1][j - p[i - 1]] + part[i - 1]); } if (j - f[i - 1] \u003e= 0) { dp[i][j] = std::max(dp[i][j], dp[i - 1][j - f[i - 1]] + full[i - 1]); } } } return dp[n][m]; } }; // 滚动数组优化 class Solution { public: int exam(std::vector\u003cint\u003e\u0026 p, std::vector\u003cint\u003e\u0026 part, std::vector\u003cint\u003e\u0026 f, std::vector\u003cint\u003e\u0026 full) { int n = p.size(); int m = 120; std::vector\u003cstd::vector\u003cint\u003e\u003e dp(2, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { dp[i % 2][j] = dp[(i - 1) % 2][j]; if (j - p[i - 1] \u003e= 0) { dp[i % 2][j] = std::max(dp[i % 2][j], dp[(i - 1) % 2][j - p[i - 1]] + part[i - 1]); } if (j - f[i - 1] \u003e= 0) { dp[i % 2][j] = std::max(dp[i % 2][j], dp[(i - 1) % 2][j - f[i - 1]] + full[i - 1]); } } } return dp[n % 2][m]; } };","chapter-22-双序列动态规划#Chapter 22: 双序列动态规划":"顾名思义，有两个序列/字符串，需要进行一些操作 每个序列本身是一维的 可以转化为二维动态规划","chapter-23-毕业旅行#Chapter 23: 毕业旅行":"Lintcode 816 TSP\nTSP问题（旅行商问题）是 NP 问题非常典型的代表\nTraveling salesman problem","chapter-23-毕业旅行-1#Chapter 23: 毕业旅行":"Lintcode 816 TSP\nTSP问题（旅行商问题）是 NP 问题非常典型的代表\nTraveling salesman problem","chapter-24-双色塔#Chapter 24: 双色塔":"Lintcode 269 双色塔 class Solution { public: int twoColorsTower(int red, int green) { } };","chapter-24-双色塔-1#Chapter 24: 双色塔":"Lintcode 269 双色塔\n求方案总数和可行性的问题 很有 可能是动态规划，求最大最小值其次\n求方案总数的问题 99% 都是动态规划\nclass Solution { public: int twoColorsTower(int red, int green) { } };","chapter-25-编辑距离#Chapter 25: 编辑距离":"","chapter-25-编辑距离-1#Chapter 25: 编辑距离":"Click on this link","chapter-26-动态规划难题专场#Chapter 26: 动态规划难题专场":"","chapter-3-打劫房屋-坐标型前缀型#Chapter 3: 打劫房屋: 坐标型，前缀型":"Leetcode 198 打劫房屋","chapter-4-最大矩形--最大直方图坐标型#Chapter 4: 最大矩形 \u0026amp;\u0026amp; 最大直方图：坐标型":"单调栈：求一个位置往左看或者往右看，第一个小于等于它的数的时候，用单调栈","chapter-5-最短假期坐标型#Chapter 5: 最短假期：坐标型":"Lintcode 267 最短假期\n转移方程：\n如果今天工作（运动），那么只能由昨天运动（工作）或休息转移而来 如果今天休息，那么可以由昨天三种状态（工作，运动，休息）转移 状态：dp[i][j]第i天干了j这个事情(j: 工作，健身，休息) 的最小休息天数\ndp[i][0], dp[i][1], dp[i][2]分别表示去公司工作、去健身房锻炼、去休息 状态转移方程： dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + 1 设假期天数为n 时间复杂度：从左至右扫描数组，每次由三个DP方程进行转移。时间复杂度为O(n) 空间复杂度：DP数组规模为3*n。空间复杂度O(n) class Solution { public: int minimumRestDays(std::vector\u003cint\u003e\u0026 company, std::vector\u003cint\u003e\u0026 gym) { int n = company.size(); // dp[i][0]表示第i天工作的最小休息天数，dp[i][1]表示锻炼，dp[i][2]表示休息 std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n, std::vector\u003cint\u003e(3)); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c 3; ++j) { dp[i][j] = 0x3f3f3f3f; } } // 临界值第一天 dp[0][0] = dp[0][1] = 0; if (company[0] == 0) { dp[0][0] = 1; } if (gym[0] == 0) { dp[0][1] = 1; } dp[0][2] = 1; for (int i = 1; i \u003c n; ++i) { if (company[i] == 1) { dp[i][0] = std::min(dp[i - 1][1], dp[i - 1][2]); } if (gym[i] == 1) { dp[i][1] = std::min(dp[i - 1][0], dp[i - 1][2]); } dp[i][2] = std::min(dp[i - 1][0], std::min(dp[i - 1][1], dp[i - 1][2])) + 1; } return std::min(dp[n - 1][0], std::min(dp[n - 1][1], dp[n - 1][2])); } };","chapter-6-最小调整代价背包型#Chapter 6: 最小调整代价：背包型":"Lintcode 91 最小调整代价 Solution","chapter-7-香槟塔坐标型#Chapter 7: 香槟塔：坐标型":"Lintcode 1018 香槟塔 状态：dp[i][j]流入多少水，至于剩下多少水是根据流入的量算出来的","chapter-8-飞行棋i#Chapter 8: 飞行棋I":"Lintcode 1565 飞行棋I\n只能向右走，有方向性所以可以用动态规划\nOther notes: 拓扑排序的一个功能就是检测图里是否有循环依赖 拓扑排序与动态规划的关系： 一个题目能够被动态规划，那么把状态看作点，把状态的依赖关系看作边的话，那所构成的图当中一定可以被拓扑排序 有循环依赖就不能产生拓扑排序，有循环依赖就不能使用动态规划","chapter-9-序列型动态规划#Chapter 9: 序列型动态规划":"","coding#Coding":"class Solution { public: int uniquePaths(int m, int n) { std::vector\u003cstd::vector\u003cint\u003e\u003e f(m, std::vector\u003cint\u003e(n)); int i, j; for (i = 0; i \u003c m; ++i) { // row: top to bottom for (j = 0; j \u003c n; ++j) { // column: left to right if (i == 0 || j == 0) { f[i][j] = 1; } else { f[i][j] = f[i - 1][j] + f[i][j - 1]; } } } return f[m - 1][n - 1]; } };","coding-1#Coding":"class Solution { public: bool canJump(std::vector\u003cint\u003e\u0026 A) { int n = A.size(); std::vector\u003cbool\u003e f(n); f[0] = true; // initialization for (int j = 1; j \u003c n; ++j) { f[j] = false; // previous stone i // last jump is from i to j for (int i = 0; i \u003c j; ++i) { if (f[i] \u0026\u0026 i + A[i] \u003e= j) { f[j] = true; break; } } } return f[n - 1]; } };","coding-2#Coding":"class Solution { public: int uniquePathsWithObstacles(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 A) { if (A.size() == 0 || A[0].size() == 0) { return 0; } int m = A.size(); int n = A[0].size(); std::vector\u003cstd::vector\u003cint\u003e\u003e f(m, std::vector\u003cint\u003e(n)); int i, j; for (i = 0; i \u003c m; ++i) { for (j = 0; j \u003c n; ++j) { if (A[i][j] == 1) { //obstacle f[i][j] = 0; continue; } if (i == 0 \u0026\u0026 j == 0) { f[i][j] = 1; continue; } f[i][j] = 0; // if it is not on 0-th row if (i \u003e 0) { f[i][j] += f[i - 1][j]; } // if it is not on 0-th column if (j \u003e 0) { f[i][j] += f[i][j - 1]; } } } return f[m - 1][n - 1]; } };","coding-3#Coding":"// Version 1 class Solution { public: int minCost(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { int n = costs.size(); if (n == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e f(n + 1, std::vector\u003cint\u003e(3)); // seq-type f[0][0] = f[0][1] = f[0][2] = 0; // initialization // first i houses 前i栋 for (int i = 1; i \u003c= n; ++i) { // house i - 1's color is j for (int j = 0; j \u003c 3; ++j) { f[i][j] = 0x3f3f3f3f; // house i - 2's color is k for (int k = 0; k \u003c 3; ++k) { if (j == k) { continue; } f[i][j] = std::min(f[i][j], f[i - 1][k] + costs[i - 1][j]); } } } return std::min(f[n][0], std::min(f[n][1], f[n][2])); } }; // Version 2 class Solution { public: int minCost(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { int n = costs.size(); if (n == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e f(n + 1, std::vector\u003cint\u003e(3)); // seq-type f[0][0] = f[0][1] = f[0][2] = 0; // initialization // first i houses for (int i = 1; i \u003c= n; ++i) { f[i][0] = std::min(f[i - 1][1] + costs[i - 1][0], f[i - 1][2] + costs[i - 1][0]); f[i][1] = std::min(f[i - 1][0] + costs[i - 1][1], f[i - 1][2] + costs[i - 1][1]); f[i][2] = std::min(f[i - 1][0] + costs[i - 1][2], f[i - 1][1] + costs[i - 1][2]); } return std::min(f[n][0], std::min(f[n][1], f[n][2])); } };","coding-4#Coding":"class Solution { public: int numDecodings(std::string\u0026 s) { int n = s.size(); if (n == 0) { return 0; } std::vector\u003cint\u003e f(n + 1, 0); int i; f[0] = 1; // initialization; 当物理意义不明确的时候，推断当前的初始化是否能得到正确的结果 // first i digits: s[0], ..., s[i - 1] for (i = 1; i \u003c= n; ++i) { f[i] = 0; // last one digit --\u003e letter // s[i - 1] == [1, 9] if (s[i - 1] != '0') { f[i] += f[i - 1]; } // last two digits --\u003e letter // s[i - 2]s[i - 1] == [10, 26] if (i \u003e= 2 \u0026\u0026 (s[i - 2] == '1' || (s[i - 2] == '2' \u0026\u0026 s[i - 1] \u003c= '6'))) { f[i] += f[i - 2]; } } return f[n]; } };","coding-5#Coding":"class Solution { public: int maxKilledEnemies(std::vector\u003cstd::vector\u003cchar\u003e\u003e\u0026 grid) { if (grid.size() == 0 || grid[0].size() == 0) { return 0; } int n = grid.size(); int m = grid[0].size(); std::vector\u003cstd::vector\u003cint\u003e\u003e up(n, std::vector\u003cint\u003e(m)); std::vector\u003cstd::vector\u003cint\u003e\u003e down(n, std::vector\u003cint\u003e(m)); std::vector\u003cstd::vector\u003cint\u003e\u003e left(n, std::vector\u003cint\u003e(m)); std::vector\u003cstd::vector\u003cint\u003e\u003e right(n, std::vector\u003cint\u003e(m)); // up // count E like prefix_sum // encounter W start from 0 for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { up[i][j] = 0; if (grid[i][j] != 'W') { if (grid[i][j] == 'E') { ++up[i][j]; } if (i \u003e 0) { up[i][j] += up[i - 1][j]; } } } } // down for (int i = n - 1; i \u003e= 0; --i) { for (int j = 0; j \u003c m; ++j) { down[i][j] = 0; if (grid[i][j] != 'W') { if (grid[i][j] == 'E') { ++down[i][j]; } if (i \u003c n - 1) { down[i][j] += down[i + 1][j]; } } } } // left for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { left[i][j] = 0; if (grid[i][j] != 'W') { if (grid[i][j] == 'E') { ++left[i][j]; } if (j \u003e 0) { left[i][j] += left[i][j - 1]; } } } } // right for (int i = 0; i \u003c n; ++i) { for (int j = m - 1; j \u003e= 0; --j) { right[i][j] = 0; if (grid[i][j] != 'W') { if (grid[i][j] == 'E') { ++right[i][j]; } if (j \u003c m - 1) { right[i][j] += right[i][j + 1]; } } } } int result = 0; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (grid[i][j] == '0') { // empty result = std::max(result, up[i][j] + down[i][j] + left[i][j] + right[i][j]); } } } return result; } };","coding-6#Coding":"class Solution { public: std::vector\u003cint\u003e countBits(int num) { std::vector\u003cint\u003e f(num + 1); f[0] = 0; for (int i = 1; i \u003c= num; ++i) { f[i] = f[i \u003e\u003e 1] + (i % 2); } return f; } };","coding-669#Coding 669":"Lintcode 669: Coin Change class Solution { public: // coins // amount // {2, 5, 7} // 27 int coinChange(std::vector\u003cint\u003e\u0026 A, int M) { // 0....n: [n+1] // 0...n-1: [n] std::vector\u003cint\u003e f(M + 1); int n = A.size(); // number of kinds of coins // initialization f[0] = 0; int i, j; // f[1], f[2], ..., f[27] for (i = 1; i \u003c= M; ++i) { f[i] = INT_MAX; // last coin A[j] // f[i] = min{f[i - A[0]] + 1, ..., f[i - A[n - 1]] + 1} for (j = 0; j \u003c n; ++j) { if (i \u003e= A[j] \u0026\u0026 f[i - A[j]] != INT_MAX) { f[i] = std::min(f[i - A[j]] + 1, f[i]); } } } if (f[M] == INT_MAX) { f[M] = -1; } return f[M]; } };","coding-7#Coding":"class Solution { public: int minAdjustmentCost(std::vector\u003cint\u003e\u0026 A, int target) { int n = A.size(); // dp[i][j]表示元素A[i]=j时，A[i]与A[i-1]差值不大于target所需要付出的最小代价 int dp[n][101]; for (int i = 0; i \u003c n; ++i) { for (int j = 1; j \u003c= 100; ++j) { // 初始化为极大值 dp[i][j] = 0x3f3f3f3f; } } for (int i = 0; i \u003c n; ++i) { for (int j = 1; j \u003c= 100; ++j) { if (i == 0) { // 临界值：第一个元素A[0]调整为j的代价 dp[0][j] = abs(j - A[0]); } else { // left为A[i]=j时，A[i-1]与A[i]差值不大于target的A[i-1]最小值 // right为A[i]=j时，A[i-1]与A[i]差值不大于target的A[i-1]最大值 int left = max(1, j - target); int right = min(100, j + target); for (int k = left; k \u003c= right; ++k) { // 当A[i-1]=k时，答案为A[i-1]=k的代价dp[i-1][k]，加上A[i]=j的调整代价abs(j-A[i]) dp[i][j] = std::min(dp[i][j], dp[i - 1][k] + abs(j - A[i])); } } } } int mincost = 0x3f3f3f3f; for (int i = 1; i \u003c= 100; ++i) { mincost = min(mincost, dp[n - 1][i]); } return mincost; } };","coding-8#Coding":"","coding-solution#Coding Solution":"// DP solution // Running time error class Solution { public: int numSquares(int n) { std::vector\u003cint\u003e f(n + 1); f[0] = 0; for (int i = 1; i \u003c= n; ++i) { f[i] = INT_MAX; // last perfect square is j * j for (int j = 1; j * j \u003c= i; ++j) { f[i] = std::min(f[i], f[i - j * j] + 1); } } return f[n]; } }; A Math solution costs O(n) time, and O(1) space\n// Math solution // Accepted class Solution { public: int numSquares(int n) { while (n % 4 == 0) { n /= 4; } if (n % 8 == 7) { return 4; } for (int i = 0; i * i \u003c= n; ++i) { int j = (int)std::sqrt(n * 1.0 - i * i); if (i * i + j * j == n) { int res = 0; if (i \u003e 0) { res += 1; } if (j \u003e 0) { res += 1; } return res; } } return 3; } };","coding-the-first-solution-with-dp#Coding: The First Solution with DP":"class Solution { public: int copyBooks(std::vector\u003cint\u003e\u0026 A, int K) { int n = A.size(); if (n == 0) { return 0; } if (K \u003e n) { K = n; } int f[K + 1][n + 1]; int i, j, k, s; for (i = 1; i \u003c= n; ++i) { f[0][i] = 0x3f3f3f3f; } f[0][0] = 0; // first k copier for (k = 1; k \u003c= K; ++k) { f[k][0] = 0; // copy first i books for (i = 1; i \u003c= n; ++i) { f[k][i] = 0x3f3f3f3f; s = 0; for (j = i; j \u003e= 0; --j) { // s = A[j] + ... + A[i - 1] if (f[k - 1][j] != 0x3f3f3f3f) { f[k][i] = std::min(f[k][i], std::max(f[k - 1][j], s)); } // update s // s += A[j - 1] if (j \u003e 0) { s += A[j - 1]; } } } } return f[K][n]; } };","coding-the-second-solution-with-binary-search#Coding: The Second Solution with Binary Search":"#include // accumulate #include // max_element class Solution { public: int copyBooks(std::vector\u003cint\u003e\u0026 pages, int K) { if (pages.size() == 0) { return 0; } // int start = 0xcfcfcfcf; // maximum element of pages // int end = 0; // sum of pages // for (int i = 0; i \u003c pages.size(); ++i) { // start = std::max(start, pages[end]); // i += pages[i]; // } int start = *std::max_element(pages.begin(), pages.end()); int end = std::accumulate(pages.begin(), pages.end(), 0); while (start + 1 \u003c end) { int mid = start + (end - start) / 2; if (GetLeastPeople(pages, mid) \u003c= K) { end = mid; } else { start = mid; } } if (GetLeastPeople(pages, start) \u003c= K) { return start; } return end; } int GetLeastPeople(std::vector\u003cint\u003e\u0026 pages, int time_limit) { int count = 0; int time_cost = 0; for (auto\u0026 page : pages) { if (time_cost + page \u003e time_limit) { ++count; time_cost = 0; } time_cost += page; } return count + 1; } };","coding-with-template-important#Coding with Template (important)":"class Solution { public: int longestPalindromeSubseq(std::string\u0026 ss) { s = ss; n = s.size(); if (n \u003c= 1) { return n; } f.resize(n, std::vector\u003cint\u003e(n, 0)); // important1: clear memory int i, j; for (i = 0; i \u003c n; ++i) { for (j = i; j \u003c n; ++j) { f[i][j] = -1; // f[i][j] has not been computed yet } } calc(0, n - 1); return f[0][n - 1]; } private: void calc(int i, int j) { // compute f[i][j] if (f[i][j] != -1) { // important2: 递归里的第一句话就要写上: if f[i][j] has been computed, return directly return; } // simple case: caculate directly: length is 1 if (i == j) { f[i][i] = 1; return; } // simple case: caculate directly: length is 2 if (i + 1 == j) { f[i][i + 1] = (s[i] == s[i + 1]) ? 2 : 1; return; } // important3: 先在这里递归 calc(i + 1, j); // f[i + 1][j] is computed calc(i, j - 1); calc(i + 1, j - 1); f[i][j] = std::max(f[i + 1][j], f[i][j - 1]); if (s[i] == s[j]) { f[i][j] = std::max(f[i][j], f[i + 1][j - 1] + 2); } } // we need to do recursion, so we need some global variable std::string s; int n; std::vector\u003cstd::vector\u003cint\u003e\u003e f; };","complete-backpack#complete backpack":"Lintcode 440 backpack III class Solution { public: int backPackIII(std::vector\u003cint\u003e\u0026 A, std::vector\u003cint\u003e\u0026 V, int m) { std::vector\u003cint\u003e AA; std::vector\u003cint\u003e VV; for (int ) int n = AA.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n + 1, std::vector\u003cint\u003e(m + 1, 0)); } }; Convert to 01backpack Two dimentional matrix One dimentinoal array","correct-forum-official-solution#Correct forum official solution":"此处使用二分优化最长上升子序列，在dp数组中二分查找第一个大于等于当前数的位置，然后dp[i]=k，即第i处的最长上升子序列长度为k。 class Solution { public: int maxEnvelopes(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 envelopes) { int n = envelopes.size(); if (n == 0) { return 0; } auto cmp = [](const auto\u0026 x, const auto\u0026 y) { return x[0] == y[0] ? x[1] \u003e y[1] : x[0] \u003c y[0]; }; std::sort(envelopes.begin(), envelopes.end(), cmp); std::vector\u003cint\u003e dp(n), height(n+1, INT_MAX); for (int i = 0; i \u003c n; ++i) { int k = std::lower_bound(height.begin(), height.end(), envelopes[i][1]) - height.begin(); dp[i] = k; height[k] = envelopes[i][1]; } int ans = 0; for (int i = 0; i \u003c n; ++i) { ans = std::max(ans, dp[i]); } return ans + 1; } };","dp-official-solution#DP Official Solution":"class Solution { public: int backPack(int m, std::vector\u003cint\u003e\u0026 A) { int n = A.size(); if (n == 0) { return 0; } bool f[n + 1][m + 1]; int i, w; // initialization for (i = 1; i \u003c= m; ++i) { f[0][i] = false; } f[0][0] = true; // first i items for (i = 1; i \u003c= n; ++i) { for (w = 0; w \u003c= m; ++w) { // case 1: not using item_{i - 1} f[i][w] = f[i - 1][w]; // case 2: using item_{i - 1} if (w \u003e= A[i - 1]) { f[i][w] = f[i][w] || f[i - 1][w - A[i - 1]]; } } } for (i = m; i \u003e= 0; --i) { if (f[n][i]) { return i; } } return 0; } };","dp-solution#DP Solution":"Time Complexity O(n)\nSpace Complexity O(n)\nclass Solution { public: int modernLudo(int length, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 connections) { if (length == 1) { return 0; } if (length \u003c= 7) { return 1; } // connected[i] = j 表示i与j相连 std::vector\u003cint\u003e connected(length + 1); std::vector\u003cint\u003e dp(length + 1); // initialization for (int i = 1; i \u003c= length; ++i) { connected[i] = i; dp[i] = 0x3f3f3f3f; } dp[1] = 0; for (int i = 0; i \u003c connections.size(); ++i) { connected[connections[i][0]] = connections[i][1]; } for (int i = 2; i \u003c= length; ++i) { if (i - 6 \u003c 1) { dp[i] = 1; } else { for (int j = 1; j \u003c= 6; ++j) { dp[i] = std::min(dp[i], dp[i - j] + 1); } } dp[connected[i]] = std::min(dp[connected[i]], dp[i]); } return dp[length]; } };","dp组成部分一确定状态#DP组成部分一：确定状态":"最后一步：无论机器人用何种方式到达右下角，总有最后挪动的一步：\n向右 或者 向下 右下角坐标设为(m - 1, n - 1)\n那么前一步（倒数第二步）一定是在(m - 2, n - 1)或者(m - 1, n - 2)\n子问题：那么，如果机器人有X种方式从左上角走到(m - 2, n - 1)，有Y种方式从左上角走到(m - 1, n - 2)，则机器人有X + Y种方式走到(m - 1, n - 1)\n求总方式数的计数型动态规划经常用到加法原理: 无重复\u0026无遗漏 问题转化为，机器人有多少种方式从左上角走到(m - 2, n - 1)和(m - 1, n - 2)\n原题要求有多少种方式从左上角走到(m - 1, n - 1)\n子问题\n状态：设f[i][j]为机器人有多少种方式从左上角走到(i, j)","dp组成部分一确定状态-1#DP组成部分一：确定状态":"最后一步：如果🐸能跳到最后一块石头n - 1，我们考虑它跳的最后一步\n这一步是从(n - 1之前的)石头i跳过来，i \u003c n - 1\n这需要两个条件同时满足：\n🐸可以跳到石头i(青蛙可以跳到i) 最后一步不超过跳跃的最大距离(i和n - 1的距离不能超过a_i)(即青蛙可以从i跳过来)：n - 1 - i \u003c= a_i 子问题：那么我们需要知道青蛙能不能跳到石头i (i \u003c n - 1)\n而我们原来要求青蛙能不能跳到石头n - 1\n子问题\n状态：设f[j]表示青蛙能不能跳到石头j","dp组成部分三初始条件和边界情况#DP组成部分三：初始条件和边界情况":"DP组成部分三：初始条件和边界情况 $f[X] = min{f[X - 2] + 1, f[X - 5] + 1, f[X - 7] + 1}$ 两个问题： X - 2, X - 5 或者 X - 7小于0怎么办？ 什么时候停下来？ 如果不能拼出Y，就定义f[Y]=正无穷 例如f[-1] = f[-2] = ... =正无穷 所以f[1] = min{f[-1] + 1, f[-4] + 1, f[-6] + 1} = 正无穷，表示拼不出来1 这道题里初始条件为：f[0] = 0 初始条件其实就是 用转移方程算不出来，但又需要它的定义，此时需要手工定义 初始条件和边界情况 (人话)：最小的值搞定一下和不要数组越界","dp组成部分三初始条件和边界情况-1#DP组成部分三：初始条件和边界情况":"初始条件：f[0][0] = 1，因为机器人只有一种方式到左上角 边界情况：i = 0或j = 0，则前一步只能有一个方向过来 –\u003e f[i][j] = 1 即第一行和第一列都是1","dp组成部分三初始条件和边界情况-2#DP组成部分三：初始条件和边界情况":"设f[j]表示青蛙能不能跳到石头j 初始条件：f[0] = true，因为青蛙一开始就在石头0 这道题没有边界情况，因为枚举的i不会越界","dp组成部分二转移方程#DP组成部分二：转移方程":"对于任意一个格子(i, j), $f[i][j] = f[i - 1][j] + f[i][j - 1]$ f[i][j] f[i - 1][j] f[i][j - 1] 机器人有多少种方式走到(i, j) 机器人有多少种方式走到(i - 1, j) 机器人有多少种方式走到(i, j - 1)","dp组成部分二转移方程-1#DP组成部分二：转移方程":"设f[j]表示青蛙能不能跳到石头j, $f[j] = OR_{0 \u003c= i \u003c j}(f[i]\\ AND\\ i + a[i] \u003e= j)$ f[j] 青蛙能不能跳到石头j OR_{0\u003c=i","dp组成部分二转移方程到此对了一半比确定状态简单一些#DP组成部分二：转移方程（到此对了一半，比确定状态简单一些）":"DP组成部分二：转移方程 设状态f[X]=最少用多少枚硬币拼出X 对于任意X, $f[X] = min{f[X - 2] + 1, f[X - 5] + 1, f[X - 7] + 1}$ f[X] f[X - 2] + 1 f[X - 5] + 1 f[X - 7] + 1 拼出X所需最少的硬币数 拼出X-2所需最少的硬币数，加上最后一枚硬币2 拼出X-5所需最少的硬币数，加上最后一枚硬币5 拼出X-7所需最少的硬币数，加上最后一枚硬币7","dp组成部分四计算顺序#DP组成部分四：计算顺序":"DP组成部分四：计算顺序 拼出X所需的最少硬币数: f[X] = min{f[X - 2] + 1, f[X - 5] + 1, f[X - 7] + 1} 初始条件：f[0] = 0 然后计算f[1], f[2], ..., f[27] 当我们计算到f[x]时，f[X - 2], f[X - 5], f[X - 7]都已经得到结果了 Key: 计算顺序的确定只有一个原则，当你要算f[X]等式左边的时候，右边用到的状态都已经算过了","dp组成部分四计算顺序-1#DP组成部分四：计算顺序":"f[0][0] = 1 计算第0行：f[0][0], f[0][1], ..., f[0][n - 1] 计算第1行：f[1][0], f[1][1], ..., f[1][n - 1] … 计算第m-1行：f[m - 1][0], f[m - 1][1], ..., f[m - 1][n - 1] 顺序的定义，不是为写for循环，而是为了转移方程，f[i][j]要用到f[i - 1][j]和f[i][j - 1] 答案是f[m - 1][n - 1] 时间复杂度（计算步数）：O(MN), 空间复杂度（数组大小）：O(MN)","dp组成部分四计算顺序-2#DP组成部分四：计算顺序":"设f[j]表示青蛙能不能跳到石头j $f[j] = OR_{0 \u003c= i \u003c j}(f[i]\\ AND\\ i + a[i] \u003e= j)$ 初始化f[0] = true 计算f[1], f[2], ..., f[n - 1] 答案是f[n - 1] 时间复杂度：O(N^2)，空间复杂度（数组大小）：O(N)","dp题目特点#DP题目特点":"计数(求方案数) 有多少种方式走到右下角 有多少种方法选出k个数使得和是sum How many ways (can you / does it)? 求最大最小值(求最值) 从左上角走到右下角路径的最大数字和 最长上升子序列长度 Maximum/ Minimum/ Longest/ Shortest/ Minimum Cost … 存在性(判断可行性) 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum Yes/No, True/False, 0/1 DP都有方向性：数组顺序固定或不可变(方向性: 从头到尾或者从尾到头)\n状态：把你觉得会影响结果的信息，全部放到数组的下标中去: 觉得有两个信息影响结果，就弄成二维数组；觉得有三个信息影响结果，就弄成三位数组\n状态转移：永远考虑最后一次干了什么事情，最后一步从哪儿来，最后一次做了什么操作\n初始条件：其实就是 用转移方程算不出来，但又需要它的定义，此时需要手工定义 初始条件和边界情况 (人话)：最小的值搞定一下和不要数组越界\n计算顺序：的确定只有一个原则，当你要算f[X]等式左边的时候，右边用到的状态都已经算过了","example-lintcode-108-palindrome-partitioning-ii#Example: Lintcode 108 Palindrome Partitioning II":"Lintcode Palindrome Partitioning II","example-lintcode-118-distinct-subsequences#Example: Lintcode 118 Distinct Subsequences":"Lintcode 118 Distinct Subsequences\n类似于最长公共子序列\nB在A中出现多少次 -\u003e B的每个字符都要在A中出现\nB的“尾巴”是否和A的“尾巴”结成对子\n设f[i][j]为B前j个字符B[0 .. j - 1]在A前i个字符A[0 .. i - 1]中出现多少次\nf[i][j] = f[i - 1][j - 1] | A[i - 1] == B[j - 1] + f[i - 1][j]\nclass Solution { public: int numDistinct(std::string\u0026 s, std::string\u0026 t) { } };","example-lintcode-118-distinct-subsequences-1#Example: Lintcode 118 Distinct Subsequences":"Lintcode 118 Distinct Subsequences\n类似于最长公共子序列\nB在A中出现多少次 -\u003e B的每个字符都要在A中出现\nB的“尾巴”是否和A的“尾巴”结成对子\n设f[i][j]为B前j个字符B[0 .. j - 1]在A前i个字符A[0 .. i - 1]中出现多少次\nf[i][j] = f[i - 1][j - 1] | A[i - 1] == B[j - 1] + f[i - 1][j]\nclass Solution { public: int numDistinct(std::string\u0026 s, std::string\u0026 t) { } };","example-lintcode-119-编辑距离#Example: Lintcode 119 编辑距离":"Lintcode 119 编辑距离 最小操作次数 == 最小编辑距离","example-lintcode-119-编辑距离-1#Example: Lintcode 119 编辑距离":"Lintcode 119 编辑距离 最小操作次数 == 最小编辑距离","example-lintcode-154-regular-expression-matching#Example: Lintcode 154 Regular Expression Matching":"Lintcode 154 Regular Expression Matching","example-lintcode-154-regular-expression-matching-1#Example: Lintcode 154 Regular Expression Matching":"Lintcode 154 Regular Expression Matching","example-lintcode-168-吹气球-消去型--区间型#Example: Lintcode 168 吹气球 (消去型 \u0026ndash;\u0026gt; 区间型)":"Lintcode 168 吹气球\n消去型：一定要倒着想，不然状态过多\n观察最后被扎破的气球，分为左右两个区间\n设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数\nf[i][j] = max_{i \u003c k \u003c j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])\n时间复杂度O(N^3)\n空间复杂度O(N^2)\n类似题目： Lintcode 1694 Monster Hunter","example-lintcode-192-wildcard-matching#Example: Lintcode 192 Wildcard Matching":"Lintcode 192 Wildcard Matching","example-lintcode-192-wildcard-matching-1#Example: Lintcode 192 Wildcard Matching":"Lintcode 192 Wildcard Matching","example-lintcode-29-交叉字符串#Example: Lintcode 29 交叉字符串":"Lintcode 29 交叉字符串","example-lintcode-394-coins-in-a-line#Example: Lintcode 394 Coins in a Line":"Lintcode 394 Coins in a Line","example-lintcode-396-coins-in-a-line-iii-区间型动态规划博弈问题#Example: Lintcode 396 Coins in A Line III （区间型动态规划—博弈问题）":"Lintcode 396 Coins in A Line III","example-lintcode-430-scramble-string#Example: Lintcode 430 Scramble String":"Lintcode 430 Scramble String\n区间有两种获得方式：\n去头去尾 二分，中间劈一刀，像这道题","example-lintcode-437-copy-books#Example: Lintcode 437 Copy Books":"Lintcode 437 Copy Books\n通过关键词连续可以判断是否为划分型动态规划\n这道题有段数限制","example-lintcode-513-perfect-square划分型#Example: Lintcode 513 Perfect Square：划分型":"Lintcode 513 完美平方","example-lintcode-563-backpack-v#Example: Lintcode 563 Backpack V":"Lintcode 563 Backpack V","example-lintcode-667-longest-palindrome-subsequence#Example: Lintcode 667 Longest Palindrome Subsequence":"Lintcode 667 Longest Palindrome Subsequence","example-lintcode-668-ones-and-zeroes双背包#Example: Lintcode 668 Ones and Zeroes：双背包":"Lintcode 668 Ones and Zeroes","example-lintcode-668-ones-and-zeroes双背包-1#Example: Lintcode 668 Ones and Zeroes：双背包":"Lintcode 668 Ones and Zeroes","example-lintcode-77-最长公共子序列#Example: Lintcode 77 最长公共子序列":"Lintcode 77 最长公共子序列","example-lintcode-92-backpack#Example: Lintcode 92 Backpack":"Lintcode 92 Backpack\n黄金定律：背包问题中，数组大小和总承重有关","exercise-602-俄罗斯套娃信封#Exercise 602 俄罗斯套娃信封":"Lintcode 602 俄罗斯套娃信封\n信封按照长度从小到大排序后（相同长度按照宽度从大到小），找宽度的 Longest Increasing Subsequence\nnormal: O(n^2)\nchallenge: O(nlogn) （后面再介绍）","exercise-lintcode-125-backpack-ii#Exercise Lintcode 125 backpack II":"Lintcode 125 Backpack","exercise-lintcode-1538-卡牌游戏-ii#Exercise Lintcode 1538 卡牌游戏 II":"Lintcode 1538 卡牌游戏 II","exercise-lintcode-563-backpack-v#Exercise Lintcode 563 backpack V":"Lintcode 563 Backpack","exercise-lintcode-564-backpack-iv-组合总和-iv#Exercise: Lintcode 564 BackPack IV (组合总和 IV)":"Lintcode 564 Backpack IV (组合总和 IV)\n类似于最前面的Coin Change\n区别于BackpackV:\nHere: [5, 1, 1], [1, 1, 5] 为两种不同的方案 BackpackV: [5, 1, 1], [1, 1, 5] 只能存在一种 最后一步：背包里最后一个物品的重量是多少\nf[i] = 有多少种组合能拼出重量i\nf[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}]","exercise-lintcode-700-杆子分割#Exercise Lintcode 700 杆子分割":"Lintcode 700 杆子分割","exercise-lintcode-92-backpack#Exercise Lintcode 92 backpack":"Lintcode 92 Backpack","exercise-single-choice#Exercise: Single Choice":"","exercise-最长上升子序列#Exercise: 最长上升子序列":"LIS: Leetcode 300 Longest Increasing Subsequence class Solution { public: int lengthOfLIS(std::vector\u003cint\u003e\u0026 nums) { if (nums.size() == 0) { return 0; } std::vector\u003cint\u003e f(nums.size(), 1); for (int i = 1; i \u003c nums.size(); ++i) { // compare current number with all previous numbers // if satisfies the increasing condition then compete // [0, i) for (int j = 0; j \u003c i; ++j) { if (nums[i] \u003e nums[j]) { f[i] = std::max(f[i], f[j] + 1); } } } return *max_element(f.begin(), f.end()); } };","exercise-相关题目#Exercise: 相关题目":"Lintcode 151 买卖股票的最佳时机III\nLintcode 515 房屋染色","exercise1-金字塔#Exercise1: 金字塔":"$dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + array[i][j]$","exercise2-乘积最大子序列#Exercise2: 乘积最大子序列":"Lintcode 191 Maximum Product Subarray\nMaximum Product Subarray\n因为负数乘法的原因，需要记录到每个位置为止最大和最小的乘积\n状态：设f[j] =以a[j]结尾的连续子序列的最大乘积，设g[j] = 以a[j]结尾的连续子序列的最小乘积\nf[j] = max{a[j], max{a[j] * f[j - 1], a[j] * g[j - 1]} | j \u003e 0}\ng[j] = min{a[j], min{a[j] * f[j - 1], a[j] * g[j - 1]} | j \u003e 0}","follow-up#Follow up":"有多少种方式把N表示成完全平方数之和（1^2 + 2^2和2^2 + 1^2属于不同的方式）————方案数 Ans: replace min with sum 能不能把N表示成恰好K个完全平方数之和————可行性 状态：f[i][k]能不能将i表示成恰好k个完全平方数之和 状态转移：f[i][k] = OR_{1 \u003c= j * j \u003c= i}(f[i - j^2][k - 1])","how-to-realize-a-dp-problem#How to realize a DP problem":"First, if the question is asking for the How many ways Maximum or Minimum Yes/No Second, we have to make decisions that may depend on previously made decisions","how-to-use-heap-in-c#How to use heap in c++":"#include #include #define assertm(exp, msg) assert(((void)msg, exp)) #define print(input) for (auto\u0026 elem : input) std::cout \u003c\u003c elem \u003c\u003c std::endl int main() { auto cmp = [](const std::pair\u003cint, int\u003e\u0026 a, const std::pair\u003cint, int\u003e\u0026 b) {return a.second \u003c b.second;}; std::set\u003cstd::pair\u003cint, int\u003e, decltype(cmp)\u003e heap; heap.insert(std::make_pair(1, 3)); heap.insert(std::make_pair(31, 1)); heap.insert(std::make_pair(4, 4)); heap.insert(std::make_pair(2, 2)); heap.insert(std::make_pair(5, 5)); auto it = heap.begin(); it = std::next(it, 2); it = std::prev(it, 1); std::cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; std::cout \u003c\u003c \"size: \" \u003c\u003c heap.size() \u003c\u003c std::endl; int index = 31; auto it2 = std::find_if(heap.begin(), heap.end(), [\u0026index](const std::pair\u003cint, int\u003e\u0026 a) {return a.first == index;}); heap.erase(it2); it = heap.begin(); std::cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; std::cout \u003c\u003c \"size: \" \u003c\u003c heap.size() \u003c\u003c std::endl; return 0; }","how-to-use-heap-in-c-1#How to use heap in c++":"#include #include #define assertm(exp, msg) assert(((void)msg, exp)) #define print(input) for (auto\u0026 elem : input) std::cout \u003c\u003c elem \u003c\u003c std::endl int main() { auto cmp = [](const std::pair\u003cint, int\u003e\u0026 a, const std::pair\u003cint, int\u003e\u0026 b) {return a.second \u003c b.second;}; std::set\u003cstd::pair\u003cint, int\u003e, decltype(cmp)\u003e heap; heap.insert(std::make_pair(1, 3)); heap.insert(std::make_pair(31, 1)); heap.insert(std::make_pair(4, 4)); heap.insert(std::make_pair(2, 2)); heap.insert(std::make_pair(5, 5)); auto it = heap.begin(); it = std::next(it, 2); it = std::prev(it, 1); std::cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; std::cout \u003c\u003c \"size: \" \u003c\u003c heap.size() \u003c\u003c std::endl; int index = 31; auto it2 = std::find_if(heap.begin(), heap.end(), [\u0026index](const std::pair\u003cint, int\u003e\u0026 a) {return a.first == index;}); heap.erase(it2); it = heap.begin(); std::cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; std::cout \u003c\u003c \"size: \" \u003c\u003c heap.size() \u003c\u003c std::endl; return 0; }","in-summary#In summary":"四个组成部分： 确定状态：确定要开的数组的意义定下来：\n研究最优策略的最后一步 化为子问题（把公共的汉字抽出来，有几个变量就是几维数组） 转移方程\n根据子问题定义直接得到 初始条件和边界情况\n细心，考虑周全（验证初值对不对，f[3]或f[4]的正确性）（边界情况数组不能越界） 计算顺序\n根本原理：利用之前的计算结果（大部分都是从小到达，二维的话就是从上到下然后从左到右）","in-summary-seq-type#In summary: seq-type":"序列型动态规划：…前i个…最小/方式数/可行性 f[i] 代表前i个：f[0], f[1], ..., f[i - 1] 在设计动态规划的过程中，发现需要知道油漆前N - 1栋房子的最优策略中，房子N - 2的颜色 如果只用f[N - 1]，将无法区分 解决方法：记录下房子N - 2的颜色 在房子N - 2是 红/蓝/绿 色的情况下，油漆前N - 1栋房子的最小花费 问题迎刃而解 序列+状态","lintcode-752-rogue-knight-sven#Lintcode 752 Rogue Knight Sven":"","mine-correct-answer-onk2#Mine Correct Answer O(nk^2)":"class Solution { public: int minCostII(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { if (costs.size() == 0) { return 0; } int n = costs.size(); int m = costs[0].size(); if (n == 1 \u0026\u0026 m == 1) { return costs[0][0]; } int dp[n + 1][m]; for (int i = 0; i \u003c m; ++i) { dp[0][i] = 0; } for (int i = 1; i \u003c= n; ++i) { for (int j = 0; j \u003c m; ++j) { dp[i][j] = costs[i - 1][j]; int min_cost = 0x3f3f3f3f; for (int k = 0; k \u003c m; ++k) { if (k == j) { continue; } min_cost = std::min(min_cost, dp[i][j] + dp[i - 1][k]); } dp[i][j] = min_cost; } } int ans = 0x3f3f3f3f; for (int i = 0; i \u003c m; ++i) { ans = std::min(ans, dp[n][i]); } return ans; } }; follow up: can you make it faster?\nMine solution is O(nk^2), how to make it faster","mine-correct-solution#Mine Correct Solution":"class Solution { public: int flipDigit(std::vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) { return 0; } int f[n + 1][2]; f[0][0] = 0; f[0][1] = 0; for (int i = 1; i \u003c= n; ++i) { if (nums[i - 1] == 1) { f[i][0] = std::min(f[i - 1][1] + 1, f[i - 1][0] + 1); f[i][1] = f[i - 1][1]; } else { f[i][0] = std::min(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][1] + 1; } } return std::min(f[n][0], f[n][1]); } }; index in nums should minus 1\nI think my solution is better than offical","mine-correct-solution-1#Mine correct solution":"class Solution { public: int maxProfit(std::vector\u003cint\u003e\u0026 prices) { int n = prices.size(); if (n \u003c= 1) { return 0; } int min_index = 0; int max_profit = 0; for (int j = 1; j \u003c n; ++j) { if (prices[j] \u003c prices[min_index]) { min_index = j; continue; } if (max_profit \u003c prices[j] - prices[min_index]) { max_profit = prices[j] - prices[min_index]; } } return max_profit; } };","mine-correct-time-optimized-solution#Mine correct time optimized solution":"class Solution { public: int minCostII(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { if (costs.size() == 0) { return 0; } int n = costs.size(); int m = costs[0].size(); if (n == 1 \u0026\u0026 m == 1) { return costs[0][0]; } int dp[n + 1][m]; for (int i = 0; i \u003c m; ++i) { dp[0][i] = 0; } // record min and second_minimum number std::vector\u003cstd::vector\u003cint\u003e\u003e min_secondmin(2, std::vector\u003cint\u003e(2, 0x3f3f3f3f)); for (int i = 1; i \u003c= n; ++i) { int index_min = min_secondmin[0][0]; int first_min = min_secondmin[0][1]; int second_min = min_secondmin[1][1]; min_secondmin[0][1] = min_secondmin[1][1] = 0x3f3f3f3f; for (int j = 0; j \u003c m; ++j) { dp[i][j] = costs[i - 1][j]; if (i == 1 \u0026\u0026 dp[i][j] \u003c min_secondmin[0][1]) { min_secondmin[1][1] = min_secondmin[0][1]; min_secondmin[1][0] = min_secondmin[0][0]; min_secondmin[0][1] = dp[i][j]; min_secondmin[0][0] = j; continue; } if (i == 1 \u0026\u0026 dp[i][j] \u003c min_secondmin[1][1]) { min_secondmin[1][1] = dp[i][j]; min_secondmin[1][0] = j; } if (i == 1) { continue; } if (j == index_min) { // j is the smallest and choose the second smallest dp[i][j] += second_min; } else { // j is not the smallest one and choose the smallest dp[i][j] += first_min; } if (dp[i][j] \u003c min_secondmin[0][1]) { min_secondmin[1][1] = min_secondmin[0][1]; min_secondmin[1][0] = min_secondmin[0][0]; min_secondmin[0][1] = dp[i][j]; min_secondmin[0][0] = j; continue; } if (dp[i][j] \u003c min_secondmin[1][1]) { min_secondmin[1][1] = dp[i][j]; min_secondmin[1][0] = j; } } } int ans = 0x3f3f3f3f; for (int i = 0; i \u003c m; ++i) { ans = std::min(ans, dp[n][i]); } return ans; } };","mine-first-solution-time-limit-exceeded-dp#Mine first solution: Time Limit Exceeded: dp":"class Solution { public: int maxEnvelopes(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 envelopes) { int n = envelopes.size(); if (n \u003c= 1) { return n; } int f[n]; std::sort(envelopes.begin(), envelopes.end(), [](const auto\u0026 l, const auto\u0026 r) { return (l[0] == r[0]) ? l[1] \u003e r[1] : l[0] \u003c r[0]; } ); int max = 0; for (int j = 0; j \u003c n; ++j) { f[j] = 1; for (int i = 0; i \u003c j; ++i) { if (envelopes[i][1] \u003c envelopes[j][1]) { f[j] = std::max(f[j], f[i] + 1); } } max = std::max(f[j], max); } return max; } };","mine-second-solution-time-limit-exceeded-dfs#Mine second solution: Time Limit Exceeded: dfs":"class Solution { public: int maxEnvelopes(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 envelopes) { int n = envelopes.size(); if (n \u003c= 1) { return n; } std::sort(envelopes.begin(), envelopes.end()); int ans = 0; dfs(envelopes, 0, 0, ans); return ans; } private: void dfs(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 envelopes, int current, int num, int\u0026 ans) { ans = std::max(ans, num); for (int i = current; i \u003c envelopes.size(); ++i) { if (current == 0 || envelopes[i][0] \u003e envelopes[current - 1][0] \u0026\u0026 envelopes[i][1] \u003e envelopes[current - 1][1]) { dfs(envelopes, i + 1, num + 1, ans); } } } };","mine-solution#Mine solution":"class Solution { public: int maxDiffSubArrays(std::vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c 2) { return 0; } std::vector\u003cint\u003e prefix_sum(n + 1, 0); for (int i = 1; i \u003c n + 1; ++i) { prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]; } std::vector\u003cint\u003e left_max(n, nums[0]); std::vector\u003cint\u003e right_max(n, nums[n - 1]); std::vector\u003cint\u003e left_min(n, nums[0]); std::vector\u003cint\u003e right_min(n, nums[n - 1]); int temp_min = nums[0]; int temp_max = nums[0]; for (int i = 1; i \u003c n; ++i) { } } };","multiple-backpack#multiple backpack":"Convert the problem to 01-backpack","my-correct-solution#My Correct Solution":"class Solution { public: int backPackV(std::vector\u003cint\u003e\u0026 nums, int target) { int n = nums.size(); int dp[n + 1][target + 1]; for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= target; ++j) { if (i == 0 \u0026\u0026 j == 0) { dp[i][j] = 1; } else if (i == 0) { dp[i][j] = 0; } else if (j - nums[i - 1] \u003e= 0) { dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j]; } else { dp[i][j]= dp[i - 1][j]; } } } return dp[n][target]; } };","offical-solution#Offical Solution":"class Solution { public: int backPackVI(std::vector\u003cint\u003e\u0026 A, int m) { int n = A.size(); int f[m + 1]; f[0] = 1; int i, j; for (i = 1; i \u003c= m; ++i) { // how many ways can we make weight // last item A[j] f[i] = 0; for (j = 0; j \u003c n; ++j) { if (A[j] \u003c= i) { f[i] += f[i - A[j]]; } } } return f[m]; } };","official-solution#Official Solution":"class Solution { public: int flipDigit(std::vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) { return 0; } int f[n + 1][2]; f[0][0] = 0; f[0][1] = 0; // first i digits: nums[0, ..., i - 1] for (int i = 1; i \u003c= n; ++i) { for (int j = 0; j \u003c 2; ++j) { f[i][j] = 0x3f3f3f3f; // nums[i - 1]--\u003ej, should I flip? int t = 0; if (nums[i - 1] != j) { t = 1; } // nums[i - 2]--\u003ek for (int k = 0; k \u003c 2; ++k) { if (k == 0 \u0026\u0026 j == 1) { continue; } f[i][j] = std::min(f[i][j], f[i - 1][k] + t); } } } return std::min(f[n][0], f[n][1]); } };","official-solution--rolling-array-optimization#Official Solution : rolling array optimization":"class Solution { public: int maxProfit(int K, std::vector\u003cint\u003e\u0026 prices) { int n = prices.size(); if (n == 0) { return 0; } int i, j, k; if (K \u003e n / 2) { int ans = 0; for (i = 0; i \u003c n - 1; ++i) { if (prices[i + 1] - prices[i] \u003e 0) { ans += prices[i + 1] - prices[i]; } } return ans; } // rolling array optimization int f[2][2 * K + 1 + 1]; int old, now = 0; for (k = 1; k \u003c= 2 * K + 1; ++k) { f[now][k] = 0xcfcfcfcf; // impossible } f[now][1] = 0; for (i = 1; i \u003c= n; ++i) { // 先交换old, now old = now; now = 1 - now; // 阶段 1, 3, 2 * K + 1：f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]) for (j = 1; j \u003c= 2 * K + 1; j += 2) { // keep state f[now][j] = f[old][j]; // sell today if (j \u003e 1 \u0026\u0026 i \u003e 1 \u0026\u0026 f[old][j - 1] != 0xcfcfcfcf) { f[now][j] = std::max(f[now][j], f[old][j - 1] + prices[i - 1] - prices[i - 2]); } } // 阶段 2, 2 * K：f[i][j] = max(f[i - 1][j] + prices[i - 1] - prices[i - 2], f[i - 1][j - 1]) for (j = 2; j \u003c= 2 * K; j += 2) { // buy today f[now][j] = f[old][j - 1]; // keep state, calculate profit today if (i \u003e 1 \u0026\u0026 f[old][j] != 0xcfcfcfcf) { f[now][j] = std::max(f[now][j], f[old][j] + prices[i - 1] - prices[i - 2]); } } } int res = 0; for (j = 1; j \u003c= 2 * K + 1; j += 2) { res = std::max(res, f[now][j]); } return res; } };","official-solution-1#Official solution":"// 贪心 class Solution { public: int maxProfit(std::vector\u003cint\u003e\u0026 prices) { if (prices.size() == 0) { return 0; } int res = 0; for (int i = 0; i \u003c prices.size() - 1; ++i) { if (prices[i + 1] \u003e prices[i]) { res += prices[i + 1] - prices[i]; } // res += std::max(prices[i + 1] - prices[i], 0) } return res; } };","official-solution-2#Official Solution":"class Solution { public: int maxProfit(std::vector\u003cint\u003e\u0026 prices) { int n = prices.size(); if (n == 0) { return 0; } int f[n + 1][5 + 1]; int i, j, k; for (k = 1; k \u003c= 5; ++k) { f[0][k] = 0xcfcfcfcf; // impossible } f[0][1] = 0; for (i = 1; i \u003c= n; ++i) { // 阶段 1, 3, 5：f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]) for (j = 1; j \u003c= 5; j += 2) { // keep state f[i][j] = f[i - 1][j]; // sell today if (j \u003e 1 \u0026\u0026 i \u003e 1 \u0026\u0026 f[i - 1][j - 1] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]); } } // 阶段 2, 4：f[i][j] = max(f[i - 1][j] + prices[i - 1] - prices[i - 2], f[i - 1][j - 1]) for (j = 2; j \u003c= 5; j += 2) { // buy today f[i][j] = f[i - 1][j - 1]; // keep state, calculate profit today if (i \u003e 1 \u0026\u0026 f[i - 1][j] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j] + prices[i - 1] - prices[i - 2]); } } } int res = 0; for (j = 1; j \u003c= 5; j += 2) { res = std::max(res, f[n][j]); } return res; } };","official-solution-3#Official Solution":"class Solution { public: int maxProfit(int K, std::vector\u003cint\u003e\u0026 prices) { int n = prices.size(); if (n == 0) { return 0; } int i, j, k; if (K \u003e n / 2) { int ans = 0; for (i = 0; i \u003c n - 1; ++i) { if (prices[i + 1] - prices[i] \u003e 0) { ans += prices[i + 1] - prices[i]; } } return ans; } int f[n + 1][2 * K + 1 + 1]; for (k = 1; k \u003c= 2 * K + 1; ++k) { f[0][k] = 0xcfcfcfcf; // impossible } f[0][1] = 0; for (i = 1; i \u003c= n; ++i) { // 阶段 1, 3, 2 * K + 1：f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]) for (j = 1; j \u003c= 2 * K + 1; j += 2) { // keep state f[i][j] = f[i - 1][j]; // sell today if (j \u003e 1 \u0026\u0026 i \u003e 1 \u0026\u0026 f[i - 1][j - 1] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]); } } // 阶段 2, 2 * K：f[i][j] = max(f[i - 1][j] + prices[i - 1] - prices[i - 2], f[i - 1][j - 1]) for (j = 2; j \u003c= 2 * K; j += 2) { // buy today f[i][j] = f[i - 1][j - 1]; // keep state, calculate profit today if (i \u003e 1 \u0026\u0026 f[i - 1][j] != 0xcfcfcfcf) { f[i][j] = std::max(f[i][j], f[i - 1][j] + prices[i - 1] - prices[i - 2]); } } } int res = 0; for (j = 1; j \u003c= 2 * K + 1; j += 2) { res = std::max(res, f[n][j]); } return res; } };","official-solution-4#Official Solution":"class Solution { public: bool firstWillWin(int n) { if (n == 0) { return false; } std::vector\u003cbool\u003e f(n + 1); f[0] = false; f[1] = true; int i, j, k; for (i = 2; i \u003c= n; ++i) { f[i] = f[i - 1] == false || f[i - 2] == false; } return f[n]; } };","official-solution-5#Official Solution":"class Solution { public: int backPackV(std::vector\u003cint\u003e\u0026 A, int m) { int n = A.size(); if (n == 0) { return 0; } int f[n + 1][m + 1]; int i, w; // initialization for (i = 1; i \u003c= m; ++i) { f[0][i] = 0; } f[0][0] = 1; // first i items for (i = 1; i \u003c= n; ++i) { for (w = 0; w \u003c= m; ++w) { // case 1: not using item_{i - 1} f[i][w] = f[i - 1][w]; // case 2: using item_{i - 1} if (w \u003e= A[i - 1]) { f[i][w] = f[i][w] + f[i - 1][w - A[i - 1]]; } } } return f[n][m]; } };","official-solution-6#Official Solution":"class Solution { public: int longestPalindromeSubseq(std::string\u0026 S) { int n = S.size(); if (n \u003c= 1) { return n; } int f[n][n]; int i, j, len; // case 1: len == 1 for (i = 0; i \u003c n; ++i) { f[i][i] = 1; } // case 2: len == 2 for (i = 0; i \u003c n - 1; ++i) { f[i][i + 1] = (S[i] == S[i + 1]) ? 2 : 1; } for (len = 3; len \u003c= n; ++len) { // [i .. i + len - 1] // i + len - 1 \u003c n ==\u003e i \u003c n - len + 1 ==\u003e i \u003c= n - len for (i = 0; i \u003c= n - len; ++i) { // i 是起点 j = i + len - 1; // j 是终点 // S[i .. j], length is len // 三种情况： f[i][j] = std::max(f[i + 1][j], f[i][j - 1]); if (S[i] == S[j]) { f[i][j] = std::max(f[i][j], f[i + 1][j - 1] + 2); } } } return f[0][n - 1]; } }; 区间动态规划的初始化和计算顺序都是基于区间长度","official-solution-better#Official solution: Better":"class Solution { public: int maxProfit(std::vector\u003cint\u003e\u0026 prices) { int n = prices.size(); if (n \u003c= 1) { return 0; } int min = prices[0]; int res = 0; for (int j = 1; j \u003c n; ++j) { // The minimum among prices[0] ... prices[j - 1] is stored in min res = std::max(res, prices[j] - min); min = std::min(min, prices[j]); } return res; } };","official-solution-on2#Official Solution: O(n^2)":"class Solution { public: int longestIncreasingSubsequence(std::vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int f[n]; int max = 0; for (int j = 0; j \u003c n; ++j) { f[j] = 1; // previous element `nums[i]` for (int i = 0; i \u003c j; ++i) { if (nums[i] \u003c nums[j]) { f[j] = std::max(f[j], f[i] + 1); } } max = std::max(f[j], max); } return max; } };","official-solution-with-some-greedy-idea#Official Solution: with some Greedy idea":"class Solution { public: int maxDiffSubArrays(std::vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c 2) { return 0; } // max_sum_of_left[i], min_sum_of_left[i]分别表示从左到i的范围内的子数组最大/最小和 int max_sum_of_left[n]; int min_sum_of_left[n]; // max_sum_of_right[i], min_sum_of_right[i]分别表示从右到i的范围内的子数组最大/最小和 int max_sum_of_right[n]; int min_sum_of_right[n]; // 求从左到i的范围内的子数组最大和 max_sum_of_left[0] = nums[0]; for (int i = 1, now = nums[0]; i \u003c n; ++i) { now = std::max(nums[i], now + nums[i]); max_sum_of_left[i] = std::max(max_sum_of_left[i - 1], now); } // 求从右到i的范围内的子数组最大和 max_sum_of_right[n - 1] = nums[n - 1]; for (int i = n - 2, now = nums[n - 1]; i \u003e= 0; --i) { now = std::max(nums[i], now + nums[i]); max_sum_of_right[i] = std::max(max_sum_of_right[i + 1], now); } // 求从左到i的范围内的子数组最小和 min_sum_of_left[0] = nums[0]; for (int i = 1, now = nums[0]; i \u003c n; ++i) { now = std::min(nums[i], now + nums[i]); min_sum_of_left[i] = std::min(min_sum_of_left[i - 1], now); } // 求从右到i的范围内的子数组最小和 min_sum_of_right[n - 1] = nums[n - 1]; for (int i = n - 2, now = nums[n - 1]; i \u003e= 0; --i) { now = std::min(nums[i], now + nums[i]); min_sum_of_right[i] = std::min(min_sum_of_right[i + 1], now); } int ans = 0xcfcfcfcf; for (int i = 0; i \u003c n - 1; ++i) { // max(左大右小的差值，左小右大的差值) ans = std::max(ans, std::max(std::abs(max_sum_of_left[i] - min_sum_of_right[i + 1]), std::abs(min_sum_of_left[i] - max_sum_of_right[i + 1]))); } return ans; } };","official-time-optimized-solution#Official time optimized solution":"class Solution { public: int minCostII(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { int n = costs.size(); if (n == 0) { return 0; } int m = costs[0].size(); if (m == 0) { return 0; } if (n == 1 \u0026\u0026 m == 1) { return costs[0][0]; } int dp[n + 1][m]; int f[n + 1][m]; int i, j, k, a, b; for (int i = 0; i \u003c m; ++i) { f[0][i] = 0; } // first i houses: 0 ... i - 1 for (i = 1; i \u003c= n; ++i) { // find minimum and 2nd minimum among // f[i - 1][0], ..., f[i - 1][m - 1] a = b = -1; // this is index for (k = 0; k \u003c m; ++k) { if (a == -1 || f[i - 1][k] \u003c f[i - 1][a]) { // new minimum is f[i - 1][k] b = a; // old minimum becomes now the 2nd minimum a = k; // new minimum is f[i - 1][k] } else { if (b == -1 || f[i - 1][k] \u003c f[i - 1][b]) { b = k; } } } for (j = 0; j \u003c m; ++j) { if (j != a) { // remove an element which is NOT the minimum f[i][j] = f[i - 1][a] + costs[i - 1][j]; } else { // remove an element which IS the minimum f[i][j] = f[i - 1][b] + costs[i - 1][j]; } } } int ans = 0x3f3f3f3f; for (int i = 0; i \u003c m; ++i) { ans = std::min(ans, f[n][i]); } return ans; } }; remember the strategy to calculate minimum and the 2nd minimum with one time iteration\na == -1 || f[a] ....","optimize-pruning#Optimize: Pruning":"class Solution { public: int minCost(int nn, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u003cint\u003e(n, 0x3f3f3f3f)); for (i = 0; i \u003c costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; dfs(1, 0, 0); return result; } private: void dfs(int level, int p, int c) { // 1. pruning!!! if (c \u003e= result) { return; } if (level == n) { // 2. pruning, remove this branch // c \u003c result result = c; return; } int i; for (i = 0; i \u003c n; ++i) { if (!done[i] \u0026\u0026 g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u003cstd::vector\u003cint\u003e\u003e g; // g[i][j] is the cost to go from city i to j (\u003c---\u003e 双向) std::vector\u003cbool\u003e done; int result; };","optimize-pruning-1#Optimize: Pruning":"class Solution { public: int minCost(int nn, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 costs) { n = nn; result = 0x3f3f3f3f; int i, j, x, y; g.resize(n, std::vector\u003cint\u003e(n, 0x3f3f3f3f)); for (i = 0; i \u003c costs.size(); ++i) { x = costs[i][0] - 1; y = costs[i][1] - 1; g[x][y] = std::min(g[x][y], costs[i][2]); g[y][x] = std::min(g[y][x], costs[i][2]); } done.resize(n, false); done[0] = true; dfs(1, 0, 0); return result; } private: void dfs(int level, int p, int c) { // 1. pruning!!! if (c \u003e= result) { return; } if (level == n) { // 2. pruning, remove this branch // c \u003c result result = c; return; } int i; for (i = 0; i \u003c n; ++i) { if (!done[i] \u0026\u0026 g[p][i] != 0x3f3f3f3f) { done[i] = true; dfs(level + 1, i, c + g[p][i]); done[i] = false; } } } int n; std::vector\u003cstd::vector\u003cint\u003e\u003e g; // g[i][j] is the cost to go from city i to j (\u003c---\u003e 双向) std::vector\u003cbool\u003e done; int result; };","others-note#Others Note":"","others-note-1#Others Note":"","phone-interview#phone interview":"组里做什么 下一步什么时候","really-important-the-most-relevant-problem#(Really Important) The most relevant problem":"LCS: Longest common subsequences LIS: Longest increasing subsequences","relative-problems#Relative Problems":"Lintcode 32 最小子串覆盖 Lintcode 397 最长上升连续子序列 Lintcode 77 最长公共子序列","relevant-problems#Relevant Problems":"Lintcode 640 一次编辑距离 Lintcode 623 K步编辑","solution-1-排列型dfs#Solution 1: 排列型DFS":"需要开数组存储哪些位置/元素已经被访问 递归中用循环选择下一个符合条件的位置/元素 循环内： 标记访问 递归 标记未访问","solution-1-排列型dfs-1#Solution 1: 排列型DFS":"需要开数组存储哪些位置/元素已经被访问 递归中用循环选择下一个符合条件的位置/元素 循环内： 标记访问 递归 标记未访问","solution-2-状态压缩型动态规划#Solution 2: 状态压缩型动态规划???":"设城市数为n，则有2^n个子集合 时间复杂度：枚举全部集合2^n，起点n，子问题n。时间复杂度为O(n^2 * 2^n) 空间复杂度：DP数组规模为n * (2^n)。空间复杂度为O(n * 2^n) class Solution { public: int minCost(int n, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 roads) { int inf = 1000000000; std::vector\u003cstd::vector\u003cint\u003e\u003e graph(n + 1, std::vector\u003cint\u003e(n + 1, 0)); ConstructGraph(graph, roads, n); // state_size represent the number of cities int state_size = 1 \u003c\u003c n; std::vector\u003cstd::vector\u003cint\u003e\u003e f(state_size, std::vector\u003cint\u003e(n + 1, 0)); for (int i = 0; i \u003c state_size; i++) { for (int j = 0; j \u003c n + 1; j++) { f[i][j] = inf; } } f[1][1] = 0; for (int state = 0; state \u003c state_size; state++) { for (int i = 2; i \u003c n + 1; i++) { if ((state \u0026 (1 \u003c\u003c (i - 1))) == 0) { continue; } int prev_state = state ^ (1 \u003c\u003c (i - 1)); for (int j = 1; j \u003c n + 1; j++) { if ((prev_state \u0026 (1 \u003c\u003c (j - 1))) == 0) { continue; } f[state][i] = std::min(f[state][i], f[prev_state][j] + graph[j][i]); } } } int minimal_cost = inf; for (int i = 0; i \u003c n + 1; i++) { minimal_cost = std::min(minimal_cost, f[state_size - 1][i]); } return minimal_cost; } private: void ConstructGraph(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 graph, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 roads, int n) { int inf = 1000000000; for (int i = 0; i \u003c n + 1; i++) { for (int j = 0; j \u003c n + 1; j++) { graph[i][j] = inf; } } for (int i = 0; i \u003c roads.size(); i++) { int a = roads[i][0], b = roads[i][1], c = roads[i][2]; graph[a][b] = std::min(graph[a][b], c); graph[b][a] = std::min(graph[b][a], c); } } };","solution-2-状态压缩型动态规划-1#Solution 2: 状态压缩型动态规划???":"设城市数为n，则有2^n个子集合 时间复杂度：枚举全部集合2^n，起点n，子问题n。时间复杂度为O(n^2 * 2^n) 空间复杂度：DP数组规模为n * (2^n)。空间复杂度为O(n * 2^n) class Solution { public: int minCost(int n, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 roads) { int inf = 1000000000; std::vector\u003cstd::vector\u003cint\u003e\u003e graph(n + 1, std::vector\u003cint\u003e(n + 1, 0)); ConstructGraph(graph, roads, n); // state_size represent the number of cities int state_size = 1 \u003c\u003c n; std::vector\u003cstd::vector\u003cint\u003e\u003e f(state_size, std::vector\u003cint\u003e(n + 1, 0)); for (int i = 0; i \u003c state_size; i++) { for (int j = 0; j \u003c n + 1; j++) { f[i][j] = inf; } } f[1][1] = 0; for (int state = 0; state \u003c state_size; state++) { for (int i = 2; i \u003c n + 1; i++) { if ((state \u0026 (1 \u003c\u003c (i - 1))) == 0) { continue; } int prev_state = state ^ (1 \u003c\u003c (i - 1)); for (int j = 1; j \u003c n + 1; j++) { if ((prev_state \u0026 (1 \u003c\u003c (j - 1))) == 0) { continue; } f[state][i] = std::min(f[state][i], f[prev_state][j] + graph[j][i]); } } } int minimal_cost = inf; for (int i = 0; i \u003c n + 1; i++) { minimal_cost = std::min(minimal_cost, f[state_size - 1][i]); } return minimal_cost; } private: void ConstructGraph(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 graph, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 roads, int n) { int inf = 1000000000; for (int i = 0; i \u003c n + 1; i++) { for (int j = 0; j \u003c n + 1; j++) { graph[i][j] = inf; } } for (int i = 0; i \u003c roads.size(); i++) { int a = roads[i][0], b = roads[i][1], c = roads[i][2]; graph[a][b] = std::min(graph[a][b], c); graph[b][a] = std::min(graph[b][a], c); } } };","soluton-1-row--2#Soluton 1: row % 2":"class Solution { public: double champagneTower(int poured, int query_row, int query_glass) { double dp[2][101]; dp[0][0] = poured; for (int row = 1; row \u003c= query_row; ++row) { for (int i = 0; i \u003c= row; ++i) { if (i == 0) { dp[row % 2][i] = std::max(0.0, (dp[(row - 1) % 2][i] - 1) / 2.0); } else if (i == row) { dp[row % 2][i] = std::max(0.0, (dp[(row - 1) % 2][i - 1] - 1) / 2.0); } else { dp[row % 2][i] = std::max(0.0, (dp[(row - 1) % 2][i - 1] + dp[(row - 1) % 2][i] - 2) / 2.0); // here is wrong, we should compare both left and right with the 0 } } } return std::min(dp[query_row % 2][query_glass], 1.0); } };","soluton-2-一维数组#Soluton 2: 一维数组":"// Solution 2 class Solution { public: double champagneTower(int poured, int query_row, int query_glass) { double dp[101]; dp[0] = poured; for (int row = 1; row \u003c= query_row; ++row) { for (int i = row; i \u003e= 0; --i) { if (i == 0) { dp[i] = std::max(0.0, (dp[i] - 1) / 2.0); } else if (i == row) { dp[i] = std::max(0.0, (dp[i - 1] - 1) / 2.0); } else { dp[i] = std::max(0.0, (dp[i - 1] + dp[i] - 2) / 2.0); // here is wrong, we should compare both left and right with the 0 } } } return std::min(dp[query_glass], 1.0); } };","step-1--如何定义状态#Step 1 : 如何定义状态？":"令dp[i][j]为(i, j)位置的杯子的流入香槟总体积占比","step-1--如何定义状态-1#Step 1 : 如何定义状态？":"令dp[i]表示从位置1到位置i的最小投掷骰子次数","step-2--临界值是什么#Step 2 : 临界值是什么？":"dp[0][0] = poured 将所有的香槟都倒在顶端","step-2--临界值是什么-1#Step 2 : 临界值是什么？":"当位置i 属于 [2, 7]的时候，可以通过投掷一次骰子抵达，即dp[i] = 1。 并且dp[1] = 0","step-3--状态转移方程怎么写#Step 3 : 状态转移方程怎么写？":"(i, j)的杯子流入的香槟总体积 = ((i - 1, j - 1)香槟体积 - 1 + (i - 1, j)香槟体积 - 1) / 2.0 状态转移方程为：dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] - 2) / 2.0","step-3--状态转移方程怎么写-1#Step 3 : 状态转移方程怎么写？":"如果投掷骰子：dp[i] = min(dp[i], dp[i - j] + 1), j 属于 [1, 6] 当前位置投掷一次骰子所能走到的位置的dp值是当前dp值加一。 如果有另外相连的位置：dp[相连的位置] = min(dp[相连的位置], dp[i])，这里实际上是更新后面的结果 可以不需要投掷骰子直接向前走","step-4--dp结果是什么#Step 4 : DP结果是什么？":"min(dp[query_row][query_glass], 1) 这个杯子能装的香槟永远不会超过一杯 class Solution { public: double champagneTower(int poured, int query_row, int query_glass) { double dp[101][101]; dp[0][0] = poured; for (int row = 1; row \u003c= query_row; ++row) { for (int i = 0; i \u003c= row; ++i) { if (i == 0) { dp[row][i] = std::max(0.0, (dp[row - 1][i] - 1) / 2.0); } else if (i == row) { dp[row][i] = std::max(0.0, (dp[row - 1][i - 1] - 1) / 2.0); } else { dp[row][i] = std::max(0.0, (dp[row - 1][i - 1] + dp[row - 1][i] - 2) / 2.0); // here is wrong, we should compare both left and right with the 0 } } } return std::min(dp[query_row][query_glass], 1.0); } }; don’t forget to minus one\nthe reason we use std::max there is that to keep volume of each cup to be positive","step-4--dp结果是什么-1#Step 4 : DP结果是什么？":"棋盘的长度 length 的 dp 值即为答案: dp[length]","summary#Summary":"划分型动态规划 要求将一个序列或字符串划分成若干满足要求的片段 解决方法：最后一步-\u003e最后一段 枚举最后一段的起点，然后把最后一段拿出来判断满不满足性质，然后再看前面最少的段数啊最少的时间等等 如果题目不指定段数，用f[i]表示前i个元素分段后的最值，可行性，方式数：Perfect Squares, Palindrome Partition II 如果题目指定段数，用f[i][j]表示前i个元素分成j段后的最值，可行性，方案数：Copy Books","summary-1#Summary":"方法二： 要求不超过M时能拼出的最大重量 记录前i个物品能拼出哪些重量 前i个物品能拼出的重量： 前i - 1个物品能拼出的重量 前i - 1个物品能拼出的重量 + 第i个物品重量A_{i - 1} 如果我们的重量不是正数，而是保留的两位小数，那么我们应该怎么处理? 把重量扩大100倍进行背包，但一般仅限于小数位数比较少的时候，不然我们需要大量的空间来存储背包。","summary-2#Summary":"划分型动态规划\n如果不需要段数，f[i]: 前i个元素分段的最优值，方案数，可行性 如果需要段数，f[i][k] 博弈型动态规划\n必胜 vs 必败 只考虑先手 当前状态必胜，说明当前状态至少有一种状态 可以走到 必败 当前状态必败，说明不管怎么走都到 必胜的局面 背包型动态规划\n黄金定律：背包的总承重一定要放在状态里","summary-3#Summary":"区间型动态规划 状态用区间左右端点：f[i][j] 有时需要逆向思考，从最后一个操作开始考虑，分成左右两个独立的空间 如何发现是否是区间型动态规划 去头去尾 二分: Scramble String 消去型，其实也是二分，但是一定要倒着想","the-first-solution-with-on2--n--m-approximate-to-on3#The first solution with O(n^2 * (n + m)) approximate to O(n^3)":"The first solution we should come up with is brute force: use O(n^2) to find all sub-string of a string, and then check each sub-string whether they include the sub-sequence of string T. The total time cost O(n^2 * (n + m))","the-second-solution-with-on--n--m-approximate-to-on2-we-should-let-time-less-than-108-if-n-is-20000-then-it-becomes-4--108--108-which-is-not-good#The second solution with O(n * (n + m)) approximate to O(n^2), we should let time less than 10^8, if n is 20000, then it becomes 4 * 10^8 \u0026gt; 10^8, which is not good":"Then to optimize time complexity, we should consider which part can be optimized. The first part which is to find the sub-string. We just enumerate left of sub-string and ignore right of sub-string. Then the total time becomes O(n * (n + m))","the-second-solution-with-time-o1-space-o1#The Second Solution with Time O(1) Space O(1)":"class Solution { public: bool firstWillWin(int n) { return n % 3 != 0; } };","the-thrid-solution-dynamic-programming-time-on--m-space-on--m#The thrid solution: Dynamic Programming: Time O(n * m) Space O(n * m)":"State: let dp[i][j] represent the left start pointer which successfully have previous j characters of string T is the sub-sequence of previous i characters of string S\n状态：令dp[i][j]表示成功匹配T串的前j个字符为S中前i个字符的子序列时的匹配起点（即第几个字符）\nFunction:\nS[i] == T[j] \u0026\u0026 j == 1 : dp[i][j] = i S[i] == T[j] \u0026\u0026 j != 1 : dp[i][j] = dp[i - 1][j - 1] S[i] != T[j] : dp[i][j] = dp[i - 1][j] Initialization: dp[i][0] = 0 represents the left start pointer of pairation of an empty string and previous i characters of string S.\nExplanation: it equals to 0 means 0th character, not the index here Alternative: To initialize here is let dp[i][0] = -1, because index 0 represent a real character Answer:\nEnumerate dp[][T.size()]: if dp[i][T.size()] != 0(here 0 is 0th character, -1 is index), then here exist left start pointer of the window dp[i][T.size()], the length of window is i - dp[i][T.size()] + 1 At this time, we maintain our minimum length of window len and the most left start pointer start Answer: S.substr(start, start + len) class Solution { public: std::string minWindow(std::string\u0026 S, std::string\u0026 T) { int n = S.size(); int m = T.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n + 1, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { if (S[i - 1] == T[j - 1]) { if (j == 1) { dp[i][j] = i; } else { dp[i][j] = dp[i - 1][j - 1]; } } else { dp[i][j] = dp[i - 1][j]; } } } int start = 0; int len = n + 1; for (int i = 1; i \u003c= n; ++i) { if (dp[i][m] != 0) { if (i - dp[i][m] + 1 \u003c len) { start = dp[i][m] - 1; len = i - dp[i][m] + 1; } } } if (len == n + 1) { return \"\"; } return S.substr(start, len); } };","time-complexity#Time Complexity":"每一步尝试三种硬币，一共27步 与递归算法相比，没有任何重复计算 算法时间复杂度（即需要进行的步数）：时间复杂度 = 27 * 3 如果这道题是：拼出n块钱，有m枚硬币：时间复杂度 = n * m 递归时间复杂读为指数级别","与递推方法比较#与递推方法比较":"递推方法 自下而上（从简单到复杂）：f[0], f[1], ..., f[N] 记忆化方法 自上而下（从复杂到简单）：f[N], f[N - 1], ... 记忆化搜索编写一般比较简单 递推方法在某些条件下可以做空间优化，记忆化搜索则必须存储所有f值","代码思路#代码思路":"将要不要打劫的这个决策，记录到状态当中去(每走到一个坐标(房子)，都有两种情况:打劫/不打劫):\n可以设dp[i][0]为如果不抢第i个房屋，前i个房屋的最优方案为多少 设dp[i][1]为如果抢第i个房屋，前i个房屋的最优方案为多少 可以得出一下的状态转移方程式： $dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])$ 因为如果不打劫当前的房子，从前一个位置选择一个最大值 $dp[i][1] = A[i] + dp[i - 1][0]$ 因为如果打劫当前的房子，之前的房子只能选择不打劫 class Solution { public: int rob(std::vector\u003cint\u003e\u0026 A) { int n = A.size(); if (n == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n, std::vector\u003cint\u003e(2, 0)); dp[0][0] = 0; dp[0][1] = A[0]; for (int i = 1; i \u003c n; ++i) { // 如果不抢第i个，取前i - 1个位置dp较大值 dp[i][0] = std::max(dp[i - 1][0], dp[i - 1][1]); // 如果抢第i个，前一个不抢，考虑从前i - 2个位置的dp值转移，即i - 1选择不打劫 dp[i][1] = A[i] + dp[i - 1][0]; } int result = std::max(dp[n - 1][0], dp[n - 1][1]); return result; } };","位操作型动态规划counting-bits#位操作型动态规划：Counting Bits":"位操作（二进制） \u0026与，|或，^异或，!非 逐位操作 Leetcode 338 Counting Bits","分析#分析":"DFS 相当于所有城市全排列，但是第一个城市固定是1，需要找到代价最小的路径（全排列） 需要记录当前的路径（包括上一个城市） 搜索过程中可以剪枝：当前路径长度已经 \u003e= 当前最优解即退出","分析-1#分析":"DFS 相当于所有城市全排列，但是第一个城市固定是1，需要找到代价最小的路径（全排列） 需要记录当前的路径（包括上一个城市） 搜索过程中可以剪枝：当前路径长度已经 \u003e= 当前最优解即退出","划分型动态规划#划分型动态规划":"定义： 给定长度为N的序列或字符串，要求划分成若干段，每一段要满足一定的性质\n段数不限，或指定K段 每一段满足一定的性质 做法：\n类似于序列型动态规划，但是通常要加上段数信息 一般用f[i][j]记录前i个元素（元素0 ~ i-1）分成j段的性质，如最小代价","初始条件和边界情况#初始条件和边界情况":"f[i][j] = 机器人有多少种方式从左上角走到(i, j) 如果左上角(0, 0)格或者右下角(m - 1, n - 1)格有障碍，直接输出0 如果(i, j)格有障碍，f[i][j] = 0，表示机器人不能到达此格(0种方式) 初始条件：f[0][0] = 1，f[i][j] = ： 0, 如果(i, j)格有障碍 1, i == 0 \u0026\u0026 j == 0 f[i - 1][j], 如果j == 0，即第一列 f[i][j - 1], 如果i == 0，即第一行 f[i - 1][j] + f[i][j - 1]，其他","初探-划分型动态规划#初探 划分型动态规划":"Leetcode 91 Decode Ways","初探-坐标型动态规划#初探 坐标型动态规划":"Lintcode 115 Unique Paths II","初探-序列型动态规划#初探 序列型动态规划":"Lintcode 515 Paint House\n动态规划里，如果你需要知道一个信息，而状态无法体现这个信息，就把这个信息记录下来\n序列型特点：状态里出现了前这个字\n序列型f[i]代表前i个：0, 1, 2, ..., i - 1\n相较于坐标型：在开初始状态与转移方程的时候序列型有很好的作用 坐标型f[i]代表到i为止：0, 1, 2, ..., i","初探-最长上升子序列lis#初探 最长上升子序列(LIS)":"","前缀型#前缀型":"坐标型关心走到哪儿，前缀型不关心\n前缀型永远是用前缀来表示子状态: 看前i个数怎样怎样，和前j个数或前i - 1个数的怎样怎样，之间的关系\n$$\\begin{align} dp[i] \u0026= 前`i`个数取出的最大和(不关心第`i`个取或者不取) \\\\ \u0026= max(dp[i - 2] + a[i], dp[i - 1]) 以此来避免取相邻的两个房子 \\\\ 优化：dp[i \\% 3] \u0026= 前`i`个数取出的最大和(不关心第`i`个取或者不取) \\\\ \u0026= max(dp[(i - 2) \\% 3] + a[i], dp[(i - 1) \\% 3]) 以此来避免取相邻的两个房子 \\end{align}$$","动态规划#动态规划":"由抢房屋的性质可以看出，抢前i个房屋能得到的最大值，与后面如何抢的方案无关，只与前i - 1个房屋的最优方案有关。这满足了动态规划的无后效性和最优子结构 同时，由于题目不能抢相邻房屋，那么如果抢了第i个房屋，就不能抢第i - 1个房屋，可以得出前i个的最优方案也与前i - 2个的最优方案有关","动态规划的题型#动态规划的题型":"坐标型：Triangle, Unique Paths, Jump Game\n前缀型：\n匹配型：Longest Increasing Subsequence, Wildcard Matching 划分型：Word Break 区间型：Stone Game\n背包型：Backpack series\n博弈型：Coins in a Line\n状态压缩型：Traveling Salesman Problem\n树型：Binary Tree Maximum Path Sum\n图型：（面试基本没考过）\n常见DP类型：\n坐标型（20%）\n序列型（20%）\n划分型（20%）\n区间型（15%）\n背包型（10%）\n博弈型（5%）\n最长序列型（5%）\n综合型（5%）\nleft: 清华动态规划专题课\n美团：最长公共子序列 微软：最长上升子序列 阿里巴巴、腾讯：最长回文子串 猿辅导：零钱兑换II 第一章 动态规划了入门 第二章 动态规划初探+坐标型动态规划+位操作型动态规划 第九章 序列型动态规划 第十六章 划分型，博弈型和背包型动态规划 第十七章 背包型动态规划和区间型动态规划 第二十二章 双序列动态规划 right: 国内大厂高频动规题详解","动态规划的题型-1#动态规划的题型":"坐标型：Triangle, Unique Paths, Jump Game\n前缀型：\n匹配型：Longest Increasing Subsequence, Wildcard Matching 划分型：Word Break 区间型：Stone Game\n背包型：Backpack series\n博弈型：Coins in a Line\n状态压缩型：Traveling Salesman Problem\n树型：Binary Tree Maximum Path Sum\n图型：（面试基本没考过）\n常见DP类型：\n坐标型（20%） 序列型（20%） 划分型（20%） 区间型（15%） 背包型（10%） 最长序列型（5%） 博弈型（5%） 综合型（5%） left: 清华动态规划专题课\n美团：最长公共子序列 微软：最长上升子序列 阿里巴巴、腾讯：最长回文子串 猿辅导：零钱兑换II 第一章 动态规划了入门 第二章 动态规划初探+坐标型动态规划+位操作型动态规划 第九章 序列型动态规划 第十六章 划分型，博弈型和背包型动态规划 第十七章 背包型动态规划和区间型动态规划 第二十二章 双序列动态规划 right: 国内大厂高频动规题详解","动态规划组成部分一确定状态#动态规划组成部分一：确定状态":"最优策略是花费最小的策略 最后一步：最优策略中房子N - 1一定染成了 红、蓝、绿 中的一种 但是相邻两栋房子不能漆成一种颜色 所成如果最优策略中房子N - 1是红色，房子N - 2只能是蓝色或绿色 所成如果最优策略中房子N - 1是蓝色，房子N - 2只能是红色或绿色 所成如果最优策略中房子N - 1是绿色，房子N - 2只能是红色或蓝色 !!!太复杂，如何优化：\n如果直接套用以前的思路，记录油漆前N栋房子的最小花费 根据套路，也需要记录油漆前N - 1栋房子的最小花费 但是，前N - 1栋房子的最小花费的最优策略中，不知道房子N - 2是什么颜色，所以有可能和房子N - 1撞色 !!!错误，正确做法：\n不知道房子N - 2是什么颜色，就把它记录下来 方法：放到状态里 分别记录油漆前N - 1栋房子并且房子N - 2是红色、蓝色、绿色的最小花费","动态规划组成部分一确定状态-1#动态规划组成部分一：确定状态":"解密数字串即划分成若干段数字，每段数字对应一个字母 最后一步（最后一段）：对应一个字母 A, B, …, Z 这个字母加密时变成1, 2, …, 26","动态规划组成部分一确定状态-10#动态规划组成部分一：确定状态":"博弈动态规划通常从第一步分析，而不是最后一步 因为局面越来越简单，石子数越来越少 面对N个石子，先手Alice第一步可以拿1个或2个石子 这样后手Bob就面对N - 1个石子或N - 2个石子 先手Alice一定会选择能让自己赢的一步 因为双方都是采取最优策略 假如后手Bob面对N - 1个石子 其实这和一开始Bob是先手，有N - 1个石子的情况是一样的 那么Bob也会选择让自己赢的一步：取走1个或2个石子 之后Alice面对新的局面，自己成为新的先手，选择让自己赢的一步 …","动态规划组成部分一确定状态-11#动态规划组成部分一：确定状态":"需要知道N个物品是否能拼出重量W（W = 0, 1, …, M）\n最后一步：最后一个物品（重量A_{N - 1}是否进入背包）\n情况一：如果前N - 1个物品能拼出W，当然前N个物品也能拼出W\n情况二：如果前N - 1个物品能拼出W - A_{N - 1}，再加上最后的物品A_{N - 1}，拼出W\n例子:\n4个物品，重量为 2, 3, 5, 7\n前3个物品可以拼出重量8(即3 + 5)，自然4个物品可以拼出重量8\n前3个物品可以拼出重量2（即2），加上最后一个物品，可以拼出重量9","动态规划组成部分一确定状态-12#动态规划组成部分一：确定状态":"需要知道N个物品有多少种方式拼出重量W (W = 0, 1, ..., Target) 最后一步：第N个物品（重量A_{N - 1}）是否进入背包 情况一：用前N - 1个物品拼出W 情况二：用前N - 1个物品能拼出W - A_{N - 1}，再加上最后的物品A_{N - 1}，拼出W 情况一的个数 + 情况二的个数 = 用前N个物品拼出W的方式","动态规划组成部分一确定状态-13#动态规划组成部分一：确定状态":"关注最后一步：最后一个物品的重量是多少 关键点1: 任何一个正确的组合中，所有物品总重量是Target 关键点2: 如果最后一个物品重量是K，则前面的物品重量是Target - K 如果最后一个物品重量是A_{0}，则要求有多少种组合能拼成Target - A_{0} 如果最后一个物品重量是A_{1}，则要求有多少种组合能拼成Target - A_{1} … 如果最后一个物品重量是A_{N - 1}，则要求有多少种组合能拼成Target - A_{N - 1}","动态规划组成部分一确定状态-14#动态规划组成部分一：确定状态":"最优策略产生最长的回文子序列T，长度是M\n情况1: 回文串长度是1，即一个字母\n情况2: 回文串长度大于1，那么必定有T[0] = T[M - 1]\n设T[0]是S[i]，T[M - 1]是S[j]\nT剩下的部分T[1 ... M - 2]仍然是一个回文串，而且是S[i + 1 ... j - 1]的最长回文子序列","动态规划组成部分一确定状态-15#动态规划组成部分一：确定状态":"如果Alice第一步取走a[0]，Bob面对a[1 .. N - 1]\nBob的最大数字差是S_Y\nAlice的数字差是a[0] - S_Y\n如果Alice第一步取走a[N - 1]，Bob面对a[0 .. N - 2]\nBob的最大数字差是S_Y_prime\nAlice的数字差是a[N - 1] - S_Y_prime\nAlice 选择较大的数字差","动态规划组成部分一确定状态-16#动态规划组成部分一：确定状态":"显然，T如果长度和S不一样，那么肯定不能由S变换而来 如果T是S变换而来的，并且我们知道S最上层二分被分成S = S_1 S_2，那么一定有： T也有两部分T = T_1 T_2，T_1是S_1变换而来的，T_2是S_2变换而来的 T也有两部分T = T_1 T_2，T_1是S_2变换而来的，T_2是S_1变换而来的","动态规划组成部分一确定状态-17#动态规划组成部分一：确定状态":"这里所有串都是S和T的子串，且长度一样 所以每个串都可以用**（起始位置， 长度）**表示 例如： S_1长度是5，在S中位置7开始 T_1长度是5，在T中位置0开始 可以用f[7][0][5] = True/False表示S_1能否通过变换成为T_1 状态：设f[i][j][k]表示S_1能否通过变换成为T_1 S_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串","动态规划组成部分一确定状态-18#动态规划组成部分一：确定状态":"所有N个气球都被扎破 最后一步：一定有最后一个被扎破的气球，编号是i 扎破i时，左边是气球0，右边是气球N + 1，获得金币1 * a_i * 1 = a_i 此时气球1 ~ i-1以及i+1 ~ N都已经被扎破，并且已经获得对应金币","动态规划组成部分一确定状态-19#动态规划组成部分一：确定状态":"设A长度是m，B长度是n\n现在我们考虑最优策略产生出的最长公共子序列（虽然还不知道是什么）\n最后一步：观察A[m - 1]和B[n - 1]这两个字符是否作为一个对子在最优策略中\n最长公共子序列也是公共子序列：长度是L -\u003e 选定了L个对应的对子 最长公共子序列 情况一：对子中没有A[m - 1] 推论：A和B的最长公共子序列就是 A 前 m - 1 个字符和 B 前 n 个字符的最长公共子序列 情况二：对子中没有B[n - 1] 推论：A和B的最长公共子序列就是 A 前 m 个字符和 B 前 n - 1 个字符的最长公共子序列 情况三：对子中有 A[m - 1] - B[n - 1] 推论：A和B的最长公共子序列就是 A 前 m - 1 个字符和 B 前 n - 1 个字符的最长公共子序列 + A[m - 1]","动态规划组成部分一确定状态-2#动态规划组成部分一：确定状态":"我们假设有敌人或有墙的格子也能放炸弹 有敌人的格子：格子里的敌人被炸死，并继续向上爆炸 有墙的格子：炸弹不能炸死任何敌人 在(i, j)格放一个炸弹，它向上能炸死的敌人数是： (i, j)格为空地：(i - 1, j)格向上能炸死的敌人数 (i, j)格为敌人：(i - 1, j)格向上能炸死的敌人数 + 1 (i, j)格为墙：0","动态规划组成部分一确定状态-20#动态规划组成部分一：确定状态":"首先，如果 X的长度 不等于 A的长度 + B的长度，直接输出 False 设A长度是m，B长度是n，X的长度是m + n 最后一步：假设X是由A和B交错形成的，那么X的最后一个字符X[m + n - 1] 要么是A[m - 1] 那么X[0 .. m + n - 2]是由A[0 .. m - 2]和B[0 .. n - 1]交错形成的 要么是B[n - 1] 那么X[0 .. m + n - 2]是由A[0 .. m - 1]和B[0 .. n - 2]交错形成的","动态规划组成部分一确定状态-21#动态规划组成部分一：确定状态":"设A长度是m，B长度是n\n全部操作完成后A的长度也是n，并且A[n - 1] = B[n - 1]\n于是最优策略（以及所有合法策略）最终都是让A的最后一个字符变成B的最后一个字符\n情况一：A在最后插入B[n - 1]\n要将A[0 .. m - 1]变成B[0 .. n - 2] 情况二：A最后一个字符替换成B[n - 1]\n要将A[0 .. m - 2]变成B[0 .. n - 2] 情况三：A删掉最后一个字符\n要将A[0 .. m - 2]变成B[0 .. n - 1] 情况四：A和B最后一个字符相等\n要将A[0 .. m - 2]变成B[0 .. n - 2]","动态规划组成部分一确定状态-22#动态规划组成部分一：确定状态":"双序列型动态规划\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于正则表达式B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非.非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是.，则A[m - 1]一定是和.匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它代表B[n - 2] = c可以重复0次或多次，它们是一个整体c*，需要考虑A[m - 1]是0个c，还是多个c中的最后一个\nA[m - 1]是0个c，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 3]是否匹配 A[m - 1]是多个c中的最后一个，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配 这种情况必须A[m - 1] = c或者c = .","动态规划组成部分一确定状态-23#动态规划组成部分一：确定状态":"双序列型动态规划\n和Regular Expression Matching很类似，因为.和?作用相同，但是这题中*可以匹配0个或多个任意字符\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于Wildcard B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非?非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是?，则A[m - 1]一定是和?匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它可以匹配0个或任意多个字符，需要考虑A[m - 1]有没有被这个*匹配\nA[m - 1]不被*匹配，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 2]是否匹配 A[m - 1]被*匹配，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配","动态规划组成部分一确定状态-24#动态规划组成部分一：确定状态":"最后一步：最优策略组成了最多的01串，其中有没有最后一个字符串S_{T - 1} 情况一：没有S_{T - 1} 需要知道前T - 1个01串中，用m个0和n个1最多能组成多少个01串 情况二：有S_{T - 1} 设第T - 1个01串中有a_{T - 1}个0，b_{T - 1}个1 需要知道前T - 1个01串中，用m - a_{T - 1}个0和n - b_{T - 1}个1最多能组成多少个01串 子问题 0和1的个数在变化，如何记录？ 直接放入状态 状态：设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成","动态规划组成部分一确定状态-25#动态规划组成部分一：确定状态":"设A长度是m，B长度是n\n全部操作完成后A的长度也是n，并且A[n - 1] = B[n - 1]\n于是最优策略（以及所有合法策略）最终都是让A的最后一个字符变成B的最后一个字符\n情况一：A在最后插入B[n - 1]\n要将A[0 .. m - 1]变成B[0 .. n - 2] 情况二：A最后一个字符替换成B[n - 1]\n要将A[0 .. m - 2]变成B[0 .. n - 2] 情况三：A删掉最后一个字符\n要将A[0 .. m - 2]变成B[0 .. n - 1] 情况四：A和B最后一个字符相等\n要将A[0 .. m - 2]变成B[0 .. n - 2]","动态规划组成部分一确定状态-26#动态规划组成部分一：确定状态":"双序列型动态规划\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于正则表达式B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非.非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是.，则A[m - 1]一定是和.匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它代表B[n - 2] = c可以重复0次或多次，它们是一个整体c*，需要考虑A[m - 1]是0个c，还是多个c中的最后一个\nA[m - 1]是0个c，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 3]是否匹配 A[m - 1]是多个c中的最后一个，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配 这种情况必须A[m - 1] = c或者c = .","动态规划组成部分一确定状态-27#动态规划组成部分一：确定状态":"双序列型动态规划\n和Regular Expression Matching很类似，因为.和?作用相同，但是这题中*可以匹配0个或多个任意字符\n设A长度是m，B长度是n\n现在我们考虑A和B如何匹配\n最后一步：关注最后的字符\n主要取决于Wildcard B中最后的字符B[n - 1]是什么\n如果B[n - 1]是一个正常字符（非?非*），则必须A[m - 1] = B[n - 1]，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配；否则不能匹配\n如果B[n - 1]是?，则A[m - 1]一定是和?匹配，之后能否匹配取决于A[0 .. m - 2]和B[0 .. n - 2]是否匹配\n如果B[n - 1]是*，它可以匹配0个或任意多个字符，需要考虑A[m - 1]有没有被这个*匹配\nA[m - 1]不被*匹配，能否匹配取决于A[0 .. m - 1]和B[0 .. n - 2]是否匹配 A[m - 1]被*匹配，能否匹配取决于A[0 .. m - 2]和B[0 .. n - 1]是否匹配","动态规划组成部分一确定状态-28#动态规划组成部分一：确定状态":"最后一步：最优策略组成了最多的01串，其中有没有最后一个字符串S_{T - 1} 情况一：没有S_{T - 1} 需要知道前T - 1个01串中，用m个0和n个1最多能组成多少个01串 情况二：有S_{T - 1} 设第T - 1个01串中有a_{T - 1}个0，b_{T - 1}个1 需要知道前T - 1个01串中，用m - a_{T - 1}个0和n - b_{T - 1}个1最多能组成多少个01串 子问题 0和1的个数在变化，如何记录？ 直接放入状态 状态：设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成","动态规划组成部分一确定状态-3#动态规划组成部分一：确定状态":"观察一个数的二进制位\n$(170)_{10} = (10101010)_2$ 最后一步：观察这个数最后一个二进制位（最低位），去掉它，看剩下多少个1\n$(170)_{10} = (10101010)_2$ $(85)_{10} = (1010101)_2$ 85 的二进制表示里有4个1 170 的二进制表示里有4个1","动态规划组成部分一确定状态-4#动态规划组成部分一：确定状态":"最后一步：最优策略中，最后一位数是否翻转 但需要知道前一位数已经变成0还是1 并且前N - 1位数最少翻转多少次，满足要求（无01子串） 不知道的信息加入状态里 状态 用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求","动态规划组成部分一确定状态-5#动态规划组成部分一：确定状态":"最后一步：最优策略中，最后一次卖发生在第 j 天 枚举最后一次买发生在第几天 但是不知道之前有没有买卖过","动态规划组成部分一确定状态-6#动态规划组成部分一：确定状态":"最后一步：对于最优的策略，一定有最后一个元素a[j] 第一种情况：最优策略种最长上升子序列就是{a[j]}，答案是1 第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素是a[i]，并且a[i] \u003c a[j]（不一定是连续的） 因为是最优策略，那么它选中的以a[i]结尾的上升子序列一定是最长的","动态规划组成部分一确定状态-7#动态规划组成部分一：确定状态":"确定状态：关注最优策略中最后一个完全平方数j^2 最优策略中n - j^2也一定被划分成最少的完全平方数之和 需要知道n - j^2最少被分成几个完全平方数之和 原来是求n最少被分成几个完全平方数之和 子问题 状态：设f[i]表示i最少被分成几个完全平方数之和（copy下来，变量变成下标，就能得到状态） 这道题只开一维数组，没有段数，原因是段数不是我们需要限定的。比如说如果这道题问，能不能分成10段，就需要改一下。","动态规划组成部分一确定状态-8#动态规划组成部分一：确定状态":"最后一步：关注最优策略中最后一段回文串，设为S[j .. N-1] 需要知道S前j个字符[0 .. j-1]最少可以划分成几个回文串","动态规划组成部分一确定状态-9#动态规划组成部分一：确定状态":"最后一步：最优策略中最后一个抄写员Bob（设他是第K个）抄写的部分 一段连续的书，包含最后一本 如果Bob抄写第j本到第N - 1本书 则Bob需要时间A[j] + ... + A[N - 1] 需要知道前面K - 1个人最少需要多少时间抄完前j本书（第0 ~ j-1本书）(这里也是指 时间的最大值最小)","动态规划组成部分一确定状态-continued#动态规划组成部分一：确定状态 continued":"最优策略一定是前 N 天（第 N - 1 天）结束后，处于\n阶段1: 没买卖过；阶段3: 买卖过一次；阶段5: 买卖过两次 状态：f[i][j]表示前i天（第 i - 1天）结束后，在阶段j的最大获利\n例如，如果要求前 N 天（第 N - 1 天）结束后，在阶段5的最大获利，设为f[N][5]\n情况1: 第 N - 2 天就在阶段5 — f[N - 1][5] 情况2: 第 N - 2 天还在阶段4（第二次持有股票），第 N - 1 天卖掉 f[N - 1][4] + (P_{N - 1} - P_{N - 2}) 例如，如果要求前 N 天（第 N - 1 天）结束后，在阶段4的最大获利，设为f[N][4]\n情况1: 第 N - 2 天就在阶段4 — f[N - 1][4] + (P_{N - 1} - P_{N - 2}) 情况2: 第 N - 2 天还在阶段3 — f[N - 1][3]","动态规划组成部分三初始条件和边界情况#动态规划组成部分三：初始条件和边界情况":"设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] 初始条件：f[0][0] = f[0][1] = f[0][2] = 0 即不油漆任何房子的花费 无边界情况","动态规划组成部分三初始条件和边界情况-1#动态规划组成部分三：初始条件和边界情况":"设数字串S前i个数字解密成字母串有f[i]种方式\n初始条件：f[0] = 1，即空串有1种方式解密\n解密成空串 边界情况：如果i = 1，只看最后一个数字","动态规划组成部分三初始条件和边界情况-10#动态规划组成部分三：初始条件和边界情况":"设f[k][i]为k个抄写员最少需要多少时间抄完前i本书\nf[k][i] = min_{j = 0, ..., i}(max(f[k - 1][j], A[j] + ... A[i - 1]))\n初始条件：\n0 个抄写员只能抄0本书 f[0][0] = 0, f[0][1] = f[0][2] = ... = f[0][N] = +inf k 个抄写员（k \u003e 0）需要 0 时间抄 0 本书 f[k][0] = 0(k \u003e 0)","动态规划组成部分三初始条件和边界情况-11#动态规划组成部分三：初始条件和边界情况":"设f[i]表示面对i个石子，是否先手必胜（f[i] = TRUE / FALSE）\nf[i] = f[i - 1] == false || f[i - 2] == false\nf[0] = false 面对0个石子，先手必败\nf[1] = f[2] = true 面对1个或2个石子，先手必胜","动态规划组成部分三初始条件和边界情况-12#动态规划组成部分三：初始条件和边界情况":"f[i][w] = f[i - 1][w] || f[i - 1][w - A_{i - 1}] 初始条件： f[0][0] = true : 0个物品可以拼出重量0 f[0][1 .. M] = false : 0个物品不能拼出大于0的重量 边界情况： f[i - 1][w - A_{i - 1}] 只能在w \u003e= A_{i - 1}时使用","动态规划组成部分三初始条件和边界情况-13#动态规划组成部分三：初始条件和边界情况":"f[i][w] = f[i - 1][w] + f[i - 1][w - A_{i - 1}]\n初始条件：\nf[0][0] = 1 : 0 个物品可以有一种方式拼出重量 0 f[0][1 .. M] = 0 : 0 个物品不能拼出大于 0 的重量 边界情况：\nf[i - 1][w - A_{i - 1}]只能在w \u003e= A_{i - 1}时使用","动态规划组成部分三初始条件和边界情况-14#动态规划组成部分三：初始条件和边界情况":"f[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}]\n出事条件：\nf[0] = 1\n有1种组合能拼出重量0（什么都不选） 边界情况：\n如果i \u003c A_{j}，则对应的f[i - A_{j}]不加入f[i]\nA_{0} = 1, A_{1} = 2, A_{2} = 4 f[3] = f[3 - A_{0}] + f[3 - A_{1}]","动态规划组成部分三初始条件和边界情况-15#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为S[i ... j]的最长回文子序列的长度\nf[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 初始条件：\nf[0][0] = f[1][1] = ... = f[N - 1][N - 1] = 1 一个字母也是一个长度为1的回文串 如果S[i] == S[i + 1], f[i][i + 1] = 2(即相邻) 如果S[i] != S[i + 1], f[i][i + 1] = 1(即相邻)","动态规划组成部分三初始条件和边界情况-16#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为一方先手在面对a[i .. j]这些数字时，能得到的最大的与对手的数字差 f[i][j] = std::max(a[i] - f[i + 1][j], a[j] - f[i][j - 1]) 只有一个数字a[i]时，己方得a[i]分，对手0分，数字差为a[i] f[i][i] = a[i] (i = 0, 1, ..., N - 1)","动态规划组成部分三初始条件和边界情况-17#动态规划组成部分三：初始条件和边界情况":"状态：设f[i][j][k]表示S_1能否通过变换成为T_1\nS_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串 如果S[i] = T[j], f[i][j][1] = True否则f[i][j][1] = False","动态规划组成部分三初始条件和边界情况-18#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数\ni和j不能扎破 f[i][j] = max_{i \u003c k \u003c j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])\n初始条件：f[0][1] = f[1][2] = ... = f[N][N + 1] = 0\n当没有气球要扎破时，最多获得0枚金币","动态规划组成部分三初始条件和边界情况-19#动态规划组成部分三：初始条件和边界情况":"f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符[0 .. j - 1]的最长公共子序列的长度 转移方程：f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1 | A[i - 1] == B[j - 1]) 初始条件：空串和任何串的最长公共子序列长度是0 f[0][j] = 0, j = 0 .. n f[i][0] = 0, i = 0 .. m","动态规划组成部分三初始条件和边界情况-2#动态规划组成部分三：初始条件和边界情况":"设Up[i][j]表示(i, j)格放一个炸弹向上能炸死的敌人数\n初始条件： 第0行的Up值和格子内容相关\nUp[0][j] = 0，如果(0, j)格不是敌人 Up[0][j] = 1，如果(0, j)格是敌人","动态规划组成部分三初始条件和边界情况-20#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为X前i + j个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 f[i][j] = (f[i - 1][j] \u0026\u0026 X[i + j - 1] == A[i - 1]) || (f[i][j - 1] \u0026\u0026 X[i + j - 1] == B[j - 1]) 初始条件：空串由A的空串和B的空串交错形成 -\u003e f[0][0] = true 边界情况：如果i = 0，不考虑情况一；如果j = 0，不考虑情况二","动态规划组成部分三初始条件和边界情况-21#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离\n要求f[m][n]\nf[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1]) 初始条件：一个空串和一个长度为L的串的最小编辑距离是L\nf[0][j] = j (j = 0, 1, 2, ..., n) f[i][0] = i (j = 0, 1, 2, ..., m)","动态规划组成部分三初始条件和边界情况-22#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空正则表达式匹配：f[0][0] = true 空正则表达式不能匹配长度\u003e 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 2]","动态规划组成部分三初始条件和边界情况-23#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空Wildcard匹配：f[0][0] = true 空Wildcard不能匹配长度\u003e 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 1]","动态规划组成部分三初始条件和边界情况-24#动态规划组成部分三：初始条件和边界情况":"设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u003e= a_{i - 1} \u0026\u0026 k \u003e= b_{i - 1}) 初始条件：f[0][0 ~ m][0 ~ n] = 0 无论有多少0和1，前0个01串最多能组成0个 边界情况：f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1必须j \u003e= a_{i - 1} \u0026\u0026 k \u003e= b_{i - 1}","动态规划组成部分三初始条件和边界情况-25#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离\n要求f[m][n]\nf[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1]) 初始条件：一个空串和一个长度为L的串的最小编辑距离是L\nf[0][j] = j (j = 0, 1, 2, ..., n) f[i][0] = i (j = 0, 1, 2, ..., m)","动态规划组成部分三初始条件和边界情况-26#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空正则表达式匹配：f[0][0] = true 空正则表达式不能匹配长度\u003e 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 2]","动态规划组成部分三初始条件和边界情况-27#动态规划组成部分三：初始条件和边界情况":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 空串和空Wildcard匹配：f[0][0] = true 空Wildcard不能匹配长度\u003e 0的串 f[1][0] = ... = f[m][0] = false 注意：f[0][1 .. n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情况中的f[i][j - 1]","动态规划组成部分三初始条件和边界情况-28#动态规划组成部分三：初始条件和边界情况":"设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u003e= a_{i - 1} \u0026\u0026 k \u003e= b_{i - 1}) 初始条件：f[0][0 ~ m][0 ~ n] = 0 无论有多少0和1，前0个01串最多能组成0个 边界情况：f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1必须j \u003e= a_{i - 1} \u0026\u0026 k \u003e= b_{i - 1}","动态规划组成部分三初始条件和边界情况-3#动态规划组成部分三：初始条件和边界情况":"设f[i]表示i的二进制表示中有多少个1\nf[i] = f[i \u003e\u003e 1] + (i mod 2)\n初始条件：f[0] = 0","动态规划组成部分三初始条件和边界情况-4#动态规划组成部分三：初始条件和边界情况":"用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 $f[i][j] = min_{(k, j) ≠ (0, 1)}(f[i - 1][k] + 1_{A[i - 1] ≠ j})$ 初始条件： f[0][0] = f[0][1] = 0","动态规划组成部分三初始条件和边界情况-5#动态规划组成部分三：初始条件和边界情况":"刚开始（前 0 天）处于阶段1 f[0][1] = 0 f[0][2] = f[0][3] = f[0][4] = f[0][5] = -inf 阶段 1, 3, 5: f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + P_{i - 1} - P_{i - 2}) 阶段 2, 4: f[i][j] = max(f[i - 1][j] + P_{i - 1} - P_{i - 2}, f[i - 1][j - 1]) 如果 j - 1 \u003c 1 或 i - 2 \u003c 0，对应项不计入 max 因为最多买卖两次，所以答案是max(f[N][1], f[N][3], f[N][5])，即清仓状态下最后一天最大获利","动态规划组成部分三初始条件和边界情况-6#动态规划组成部分三：初始条件和边界情况":"刚开始（前 0 天）处于阶段1 f[0][1] = 0 f[0][2] = f[0][3] = f[0][4] = f[0][**2K + 1**] = -inf 阶段 1, 3, 5, …, 2K + 1: f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + P_{i - 1} - P_{i - 2}) 阶段 2, 4, …, 2K: f[i][j] = max(f[i - 1][j] + P_{i - 1} - P_{i - 2}, f[i - 1][j - 1]) 如果 j - 1 \u003c 1 或 i - 2 \u003c 0，对应项不计入 max 因为最多买卖K次，所以答案是max(f[N][1], f[N][3], ..., f[N][**2K + 1**])，即清仓状态下最后一天最大获利","动态规划组成部分三初始条件和边界情况-7#动态规划组成部分三：初始条件和边界情况":"情况2必须满足： i \u003e= 0 a[j] \u003e a[i]，满足单调性 初始条件：空","动态规划组成部分三初始条件和边界情况-8#动态规划组成部分三：初始条件和边界情况":"设f[i]表示i最少被分成几个完全平方数之和\nf[i] = min_{1 \u003c= j * j \u003c= i}(f[i - j^2] + 1)\n初始条件：0被分成0个完全平方数之和\nf[0] = 0","动态规划组成部分三初始条件和边界情况-9#动态规划组成部分三：初始条件和边界情况":"设f[i]为S前i个字符S[0 .. i-1]最少可以划分成几个回文串 f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) 初始条件：空串可以被分成0个回文串 f[0] = 0","动态规划组成部分二转移方程#动态规划组成部分二：转移方程":"设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] f[i][0] = min{f[i - 1][1] + cost[i - 1][0], f[i - 1][2] + cost[i - 1][0]} f[i][1] = min{f[i - 1][0] + cost[i - 1][1], f[i - 1][2] + cost[i - 1][1]} f[i][2] = min{f[i - 1][0] + cost[i - 1][2], f[i - 1][1] + cost[i - 1][2]}","动态规划组成部分二转移方程-1#动态规划组成部分二：转移方程":"设数字串S前i个数字解密成字母串有f[i]种方式 f[i] = f[i - 1] | S[i - 1]对应一个字母 + f[i - 2] | S[i - 2]S[i - 1]对应一个字母 f[i]: 数字串S前i个数字解密成字母串的方式数 f[i - 1] | S[i - 1]对应一个字母: 数字串S前i - 1个数字解密成字母串的方式数 f[i - 2] | S[i - 2]S[i - 1]对应一个字母: 数字串S前i - 2个数字解密成字母串的方式数","动态规划组成部分二转移方程-10#动态规划组成部分二：转移方程":"设f[k][i]为k个抄写员最少需要多少时间抄完前i本书 f[k][i] = min_{i = 0, ..., i}(max(f[k - 1][j], A[j] + ... + A[i - 1]))(Note: min的下标可以到i，代表这个人根本就不抄书，有些人可能分到0本书，所以是0 到 i)","动态规划组成部分二转移方程-11#动态规划组成部分二：转移方程":"设f[i]表示面对i个石子，是否先手必胜（f[i] = TRUE / FALSE）\nf[i] = true, f[i - 1] == False \u0026\u0026 f[i - 2] == false 拿1或2个石子都必胜 true, f[i - 1] == false \u0026\u0026 f[i - 2] == true 拿1个石子必胜 true, f[i - 1] == true \u0026\u0026 f[i - 2] == false 拿2个石子必胜 false, f[i - 1] == true \u0026\u0026 f[i - 2] == true 必败 Simplify: f[i] = f[i - 1] == false || f[i - 2] == false","动态规划组成部分二转移方程-12#动态规划组成部分二：转移方程":"设f[i][w] = 能否用前i个物品拼出重量w (TRUE / FALSE) f[i][w] = f[i - 1][w] || f[i - 1][w - A_{i - 1}]","动态规划组成部分二转移方程-13#动态规划组成部分二：转移方程":"设f[i][w] = 用前 i 个物品有多少种方式拼出重量w f[i][w] = f[i - 1][w] + f[i - 1][w - A_{i - 1}]","动态规划组成部分二转移方程-14#动态规划组成部分二：转移方程":"设f[i] = 有多少种组合能拼出重量i f[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}]","动态规划组成部分二转移方程-15#动态规划组成部分二：转移方程":"设f[i][j]为S[i ... j]的最长回文子序列的长度 f[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j])","动态规划组成部分二转移方程-16#动态规划组成部分二：转移方程":"设f[i][j]为一方先手在面对a[i .. j]这些数字时，能得到的最大的与对手的数字差 f[i][j] = std::max(a[i] - f[i + 1][j], a[j] - f[i][j - 1])","动态规划组成部分二转移方程-17#动态规划组成部分二：转移方程":"状态：设f[i][j][k]表示S_1能否通过变换成为T_1 S_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串","动态规划组成部分二转移方程-18#动态规划组成部分二：转移方程":"设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数 i和j不能扎破 f[i][j] = max_{i \u003c k \u003c j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])","动态规划组成部分二转移方程-19#动态规划组成部分二：转移方程":"状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符[0 .. j - 1]的最长公共子序列的长度 要求f[m][n] f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1 | A[i - 1] == B[j - 1])","动态规划组成部分二转移方程-2#动态规划组成部分二：转移方程":"设Up[i][j]表示(i, j)格放一个炸弹向上能炸死的敌人数 Up[i][j]: Up[i - 1][j]，如果(i, j)格是空地 Up[i - 1][j] + 1，如果(i, j)格是敌人 0，如果(i, j)格是墙","动态规划组成部分二转移方程-20#动态规划组成部分二：转移方程":"设f[i][j]为X前i + j个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 f[i][j] = (f[i - 1][j] \u0026\u0026 X[i + j - 1] == A[i - 1]) || (f[i][j - 1] \u0026\u0026 X[i + j - 1] == B[j - 1])","动态规划组成部分二转移方程-21#动态规划组成部分二：转移方程":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离 要求f[m][n] f[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1])","动态规划组成部分二转移方程-22#动态规划组成部分二：转移方程":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u003e 0，并且B[j - 1] = .或者A[i - 1] = B[j - 1] f[i][j - 2] || (f[i - 1][j] \u0026\u0026 (B[j - 2] == . || B[j - 2] == A[i - 1]))，如果B[j - 1] = *","动态规划组成部分二转移方程-23#动态规划组成部分二：转移方程":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u003e 0，并且B[j - 1] = ?或者A[i - 1] = B[j - 1] f[i - 1][j] || f[i][j - 1]，如果B[j - 1] = *","动态规划组成部分二转移方程-24#动态规划组成部分二：转移方程":"设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u003e= a_{i - 1} \u0026\u0026 k \u003e= b_{i - 1})","动态规划组成部分二转移方程-25#动态规划组成部分二：转移方程":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]的最小编辑距离 要求f[m][n] f[i][j] = std::min(f[i][j - 1] + 1, f[i - 1][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] | A[i - 1] == B[j - 1])","动态规划组成部分二转移方程-26#动态规划组成部分二：转移方程":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u003e 0，并且B[j - 1] = .或者A[i - 1] = B[j - 1] f[i][j - 2] || (f[i - 1][j] \u0026\u0026 (B[j - 2] == . || B[j - 2] == A[i - 1]))，如果B[j - 1] = *","动态规划组成部分二转移方程-27#动态规划组成部分二：转移方程":"设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配 f[i][j] = f[i - 1][j - 1]，如果i \u003e 0，并且B[j - 1] = ?或者A[i - 1] = B[j - 1] f[i - 1][j] || f[i][j - 1]，如果B[j - 1] = *","动态规划组成部分二转移方程-28#动态规划组成部分二：转移方程":"设f[i][j][k]为前i个01串最多能有多少个被j个0和k个1组成 设S_i中有a_i个0，b_i个1 f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - a_{i - 1}][k - b_{i - 1}] + 1 | j \u003e= a_{i - 1} \u0026\u0026 k \u003e= b_{i - 1})","动态规划组成部分二转移方程-3#动态规划组成部分二：转移方程":"设f[i]表示i的二进制表示中有多少个1\nf[i] = f[i \u003e\u003e 1] + (i mod 2)","动态规划组成部分二转移方程-4#动态规划组成部分二：转移方程":"用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 $f[i][j] = min_{(k, j) ≠ (0, 1)}(f[i - 1][k] + 1_{A[i - 1] ≠ j})$","动态规划组成部分二转移方程-5#动态规划组成部分二：转移方程":"f[i][j]: 前i天（第 i - 1天）结束后，处在阶段j，最大获利","动态规划组成部分二转移方程-6#动态规划组成部分二：转移方程":"f[i][j]: 前i天（第i - 1天）结束后，处在阶段j，最大获利","动态规划组成部分二转移方程-7#动态规划组成部分二：转移方程":"f[j] = 以a[j]结尾的最长上升子序列的长度 f[j] = max(1, f[i] + 1 | i \u003c j and a[i] \u003c a[j])","动态规划组成部分二转移方程-8#动态规划组成部分二：转移方程":"设f[i]表示i最少被分成几个完全平方数之和 f[i] = min_{1 \u003c= j * j \u003c= i}(f[i - j^2] + 1) 此处{1 \u003c= j * j \u003c= i}是限定条件","动态规划组成部分二转移方程-9#动态规划组成部分二：转移方程":"设f[i]为S前i个字符S[0 .. i-1]最少可以划分成几个回文串 f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串)","动态规划组成部分四计算顺序#动态规划组成部分四：计算顺序":"设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] 初始化f[0][0], f[0][1], f[0][2] 计算f[1][0], f[1][1], f[1][2] … 计算f[N][0], f[N][1], f[N][2] 答案是min{f[N][0], f[N][1], f[N][2]}时间复杂度O(N)，空间复杂度O(N)","动态规划组成部分四计算顺序-1#动态规划组成部分四：计算顺序":"f[0], f[1], ..., f[N] 答案是f[N] 时间复杂度O(N)，空间复杂度O(N)","动态规划组成部分四计算顺序-10#动态规划组成部分四：计算顺序":"计算f[0][0], f[0][1], ..., f[0][N] 计算f[1][0], f[1][1], ..., f[1][N] … 计算f[K][0], f[K][1], ..., f[K][N] 答案是f[K][N] 时间复杂度O(N^2 * K) 空间复杂度O(NK)，优化后可以达到O(N) 如果K \u003e N, 可以赋值K \u003c- N","动态规划组成部分四计算顺序-11#动态规划组成部分四：计算顺序":"f[0], f[1], f[2], ..., f[N] 如果f[N] = true则先手必胜，否则先手必败 时间复杂度O(N) 空间复杂度O(N)，可以滚动数组优化至O(1)","动态规划组成部分四计算顺序-12#动态规划组成部分四：计算顺序":"初始化f[0][0], f[0][1], ..., f[0][M] 计算前 1 个物品能拼出哪些重量：f[1][0], f[1][1], ..., f[1][M] 计算前 2 个物品能拼出哪些重量：f[2][0], f[2][1], ..., f[2][M] … 计算前 N 个物品能拼出哪些重量：f[N][0], f[N][1], ..., f[N][M] 时间复杂度（计算步数）：O(MN) 空间复杂度（数组大小）：优化后可以达到O(M)","动态规划组成部分四计算顺序-13#动态规划组成部分四：计算顺序":"初始化f[0][0], f[0][1], ..., f[0][Target] 计算前 1 个物品有多少种方式拼出重量：f[1][0], f[1][1], ..., f[1][Target] … 计算前 N 个物品有多少种方式拼出重量：f[N][0], f[N][1], ..., f[N][Target] 答案是f[N][Target] 时间复杂度（计算步数）：O(N * Target) 空间复杂度（数组大小）：滚动数组优化后可以达到O(Target)","动态规划组成部分四计算顺序-14#动态规划组成部分四：计算顺序":"设f[i] = 有多少种组合能拼出重量i f[i] = f[i - A_{0}] + f[i - A_{1}] + ... + f[i - A_{N - 1}] f[0] = 1 计算f[1], f[2], ..., f[Target] 结果为f[Target] 时间复杂度（计算步数）：O(N * Target) 空间复杂度：O(Target)","动态规划组成部分四计算顺序-15#动态规划组成部分四：计算顺序":"设f[i][j]为S[i ... j]的最长回文子序列的长度 f[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 不能按照i的顺序去算 区间动态规划：按照长度j - i从小到大的顺序去算 即for循环那个长度，不能循环i或j 长度 1 ：f[0][0], f[1][1], f[2][2], ..., f[N - 1][N - 1] 长度 2 ：f[0][1], ..., f[N - 2][N - 1] … 长度 N ：f[0][N - 1] 答案是f[0][N - 1] 时间复杂度O(N^2) 空间复杂度O(N^2)","动态规划组成部分四计算顺序-16#动态规划组成部分四：计算顺序":"长度1: f[0][0], f[1][1], f[2][2], ..., f[N - 1][N - 1] 长度2: f[0][1], ..., f[N - 2][N - 1] … 长度N: f[0][N - 1] 如果f[0][N - 1] \u003e= 0，先手Alice必赢，否则必输 时间复杂度O(N^2) 空间复杂度O(N^2) // 博弈型与区间型的结合类问题 class Solution { public: bool firstWillWin(std::vector\u003cint\u003e\u0026 values) { int n = values.size(); if (n == 0) { return true; } int f[n][n]; int i, j, len; // len == 1 for (i = 0; i \u003c n; ++i) { f[i][i] = values[i]; } for (len = 2; len \u003c= n; ++len) { for (i = 0; i \u003c= n - len; ++i) { j = i + len - 1; // A[i ... j] f[i][j] = std::max(values[i] - f[i + 1][j], values[j] - f[i][j - 1]); } } return f[0][n - 1] \u003e= 0; } };","动态规划组成部分四计算顺序-17#动态规划组成部分四：计算顺序":"状态：设f[i][j][k]表示S_1能否通过变换成为T_1\nS_1为S从字符i开始的长度为k的子串 T_1为T从字符j开始的长度为k的子串 按照k从小到大的顺序去计算\nf[i][j][1], 0 \u003c= i \u003c N, 0 \u003c= j \u003c N f[i][j][2], 0 \u003c= i \u003c N - 1, 0 \u003c= j \u003c N - 1 … f[0][0][N] 答案是f[0][0][N]\n时间复杂度O(N^4)\n空间复杂度O(N^3)\nclass Solution { public: bool isScramble(std::string\u0026 S, std::string\u0026 T) { int m = S.size(); int n = T.size(); if (m != n) { return false; } bool f[n][n][n + 1]; int i, j, w, len; // len = 1 for (i = 0; i \u003c n; ++i) { for (j = 0; j \u003c n; ++j) { f[i][j][1] = (S[i] == T[j]); } } for (len = 2; len \u003c= n; ++len) { for (i = 0; i \u003c= n - len; ++i) { // S[i ... i+len-1] for (j = 0; j \u003c= n - len; ++j) { // T[j ... j+len-1] f[i][j][len] = false; // break into S1 and S2 // S1 has length w, S2 has length len - w for (w = 1; w \u003c len; ++w) { //no swap // S1--\u003eT1, S2--\u003eT2 if (f[i][j][w] \u0026\u0026 f[i + w][j + w][len - w]) { f[i][j][len] = true; break; } // swap // S1--\u003eT2, S2--\u003eT1 if (f[i][j + len - w][w] \u0026\u0026 f[i + w][j][len - w]) { f[i][j][len] = true; break; } } } } } return f[0][0][n]; } };","动态规划组成部分四计算顺序-18#动态规划组成部分四：计算顺序":"设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数\ni和j不能扎破 f[i][j] = max_{i \u003c k \u003c j}(f[i][k] + f[k][j] + a[i] * a[k] * a[j])\n区间动态规划：按照长度j - i从小到大的顺序去算\nf[0][1], f[1][2], f[2][3], ..., f[N][N + 1] f[0][2], f[1][3], f[2][4], ..., f[N - 1][N + 1] … f[0][N + 1] 时间复杂度O(N^3) 空间复杂度O(N^2)\nclass Solution { public: int maxCoins(std::vector\u003cint\u003e\u0026 AA) { int n = AA.size(); if (n == 0) { return 0; } int i, j, k, len; int A[n + 2]; A[0] = A[n + 1] = 1; for (i = 1; i \u003c= n; ++i) { A[i] = AA[i - 1]; } n += 2; // AA: 3 2 8 7 9 // A: 1 3 2 8 7 9 1 int f[n][n]; for (i = 0; i \u003c n - 1; ++i) { f[i][i + 1] = 0; } for (len = 3; len \u003c= n; ++len) { for (i = 0; i \u003c= n - len; ++i) { j = i + len - 1; // i ... k ... j f[i][j] = 0; for (k = i + 1; k \u003c j; ++k) { f[i][j] = std::max(f[i][j], f[i][k] + f[k][j] + A[i] * A[k] * A[j]); } } } return f[0][n - 1]; // n here has added 2 before } };","动态规划组成部分四计算顺序-19#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: int longestCommonSubsequence(std::string\u0026 A, std::string\u0026 B) { int n = A.size(); int m = B.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e f(n + 1, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= m; ++j) { if (i == 0 || j == 0) { f[i][j] = 0; continue; } f[i][j] = std::max(f[i][j - 1], f[i - 1][j]); if (A[i - 1] == B[j - 1]) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + 1); } } } return f[n][m]; } };","动态规划组成部分四计算顺序-2#动态规划组成部分四：计算顺序":"逐行计算 Up[0][0], Up[0][1], ..., Up[0][n - 1] Up[1][0], Up[1][1], ..., Up[1][n - 1] … Up[m - 1][0], Up[m - 1][1], ..., Up[m - 1][n - 1] 时间复杂度O(MN)，空间复杂度O(MN)","动态规划组成部分四计算顺序-20#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][m] f[1][0], f[1][1], ..., f[1][m] … f[n][0], f[n][1], ..., f[n][m] 答案是f[n][m] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isInterleave(std::string\u0026 A, std::string\u0026 B, std::string\u0026 X) { int n = A.size(); int m = B.size(); if (X.size() != n + m) { return false; } std::vector\u003cstd::vector\u003cbool\u003e\u003e f(n + 1, std::vector\u003cbool\u003e(m + 1, false)); int i, j; for (i = 0; i \u003c= n; ++i) { for (j = 0; j \u003c= m; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = true; continue; } f[i][j] = false; if (i \u003e 0 \u0026\u0026 X[i + j - 1] == A[i - 1] \u0026\u0026 f[i - 1][j]) { f[i][j] = true; } if (j \u003e 0 \u0026\u0026 X[i + j - 1] == B[j - 1] \u0026\u0026 f[i][j - 1]) { f[i][j] = true; } } } return f[n][m]; } };","动态规划组成部分四计算顺序-21#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: int minDistance(std::string\u0026 A, std::string\u0026 B) { int m = A.size(); int n = B.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e f(m + 1, std::vector\u003cint\u003e(n + 1, 0)); int i, j; for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { if (i == 0) { // insert, insert, ... f[i][j] = j; continue; } if (j == 0) { // delete, delete, ... f[i][j] = i; continue; } // insert, delete, replace f[i][j] = std::min(std::min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { // 情况四 f[i][j] = std::min(f[i][j], f[i - 1][j - 1]); } } } return f[m][n]; } };","动态规划组成部分四计算顺序-22#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026 s, std::string\u0026 p) { int m = s.size(); int n = p.size(); std::vector\u003cstd::vector\u003cbool\u003e\u003e f(m + 1, std::vector\u003cbool\u003e(n + 1, false)); int i, j; for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = true; continue; } if (j == 0) { // i \u003e 0 f[i][j] = false; continue; } f[i][j] = false; if (p[j - 1] != '*') { if (i \u003e 0 \u0026\u0026 (p[j - 1] == '.' || p[j - 1] == s[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // c* // 0 c's if (j \u003e 1) { f[i][j] = f[i][j - 2]; } // \u003e= 1 c's, c: p[j - 2] if (i \u003e 0 \u0026\u0026 j \u003e 1 \u0026\u0026 (p[j - 2] == '.' || p[j - 2] == s[i - 1])) { f[i][j] = f[i][j] || f[i - 1][j]; } } } } return f[m][n]; } };","动态规划组成部分四计算顺序-23#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026 A, std::string\u0026 B) { int m = A.size(); int n = B.size(); std::vector\u003cstd::vector\u003cbool\u003e\u003e f(m + 1, std::vector\u003cbool\u003e(n + 1, false)); int i, j; for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = true; continue; } if (j == 0) { f[i][j] = false; continue; } // j \u003e 0 f[i][j] = false; if (B[j - 1] != '*') { if (i \u003e 0 \u0026\u0026 (B[j - 1] == '?' || B[j - 1] == A[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // * represents 0 character f[i][j] = f[i][j - 1]; if (i \u003e 0) { f[i][j] = (f[i][j] || f[i - 1][j]); } } } } return f[m][n]; } };","动态规划组成部分四计算顺序-24#动态规划组成部分四：计算顺序":"f[0][0][0], f[0][0][1], ..., f[0][0][n], f[0][1][0], ..., f[0][1][n], ..., f[0][m][n] f[1][0][0], f[1][0][1], ..., f[1][0][n], f[1][1][0], ..., f[1][1][n], ..., f[1][m][n] … f[T][0][0], f[T][0][1], ..., f[T][0][n], f[T][1][0], ..., f[T][1][n], ..., f[T][m][n] 答案是max(f[T][0][0], f[T][0][1], ..., f[T][m][n]) 时间复杂度：O(Tmn) 空间复杂度：O(Tmn)，可以用滚动数组优化空间至O(mn) class Solution { public: int findMaxForm(std::vector\u003cstd::string\u003e\u0026 A, int m, int n) { if (A.size() == 0) { return 0; } int T = A.size(); std::vector\u003cint\u003e cnt0(T, 0); std::vector\u003cint\u003e cnt1(T, 0); int i, j, k; for (i = 0; i \u003c T; ++i) { cnt0[i] = cnt1[i] = 0; std::string s = A[i]; for (j = 0; j \u003c s.size(); ++j) { if (s[j] == '0') { ++cnt0[i]; } else { ++cnt1[i]; } } } std::vector\u003cstd::vector\u003cstd::vector\u003cint\u003e\u003e\u003e f(T + 1, std::vector\u003cstd::vector\u003cint\u003e\u003e(m + 1, std::vector\u003cint\u003e(n + 1, 0))); for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { f[0][i][j] = 0; } } for (i = 1; i \u003c= T; ++i) { for (j = 0; j \u003c= m; ++j) { for (k = 0; k \u003c= n; ++k) { // j 0's, k 1's // do not take A[i - 1] f[i][j][k] = f[i - 1][j][k]; // take A[i - 1] if (j \u003e= cnt0[i - 1] \u0026\u0026 k \u003e= cnt1[i - 1]) { f[i][j][k] = std::max(f[i][j][k], f[i - 1][j - cnt0[i - 1]][k - cnt1[i - 1]] + 1); } } } } int ans = 0; for (j = 0; j \u003c= m; ++j) { for (k = 0; k \u003c= n; ++k) { ans = std::max(ans, f[T][j][k]); } } return ans; } };","动态规划组成部分四计算顺序-25#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: int minDistance(std::string\u0026 A, std::string\u0026 B) { int m = A.size(); int n = B.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e f(m + 1, std::vector\u003cint\u003e(n + 1, 0)); int i, j; for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { if (i == 0) { // insert, insert, ... f[i][j] = j; continue; } if (j == 0) { // delete, delete, ... f[i][j] = i; continue; } // insert, delete, replace f[i][j] = std::min(std::min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { // 情况四 f[i][j] = std::min(f[i][j], f[i - 1][j - 1]); } } } return f[m][n]; } };","动态规划组成部分四计算顺序-26#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026 s, std::string\u0026 p) { int m = s.size(); int n = p.size(); std::vector\u003cstd::vector\u003cbool\u003e\u003e f(m + 1, std::vector\u003cbool\u003e(n + 1, false)); int i, j; for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = true; continue; } if (j == 0) { // i \u003e 0 f[i][j] = false; continue; } f[i][j] = false; if (p[j - 1] != '*') { if (i \u003e 0 \u0026\u0026 (p[j - 1] == '.' || p[j - 1] == s[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // c* // 0 c's if (j \u003e 1) { f[i][j] = f[i][j - 2]; } // \u003e= 1 c's, c: p[j - 2] if (i \u003e 0 \u0026\u0026 j \u003e 1 \u0026\u0026 (p[j - 2] == '.' || p[j - 2] == s[i - 1])) { f[i][j] = f[i][j] || f[i - 1][j]; } } } } return f[m][n]; } };","动态规划组成部分四计算顺序-27#动态规划组成部分四：计算顺序":"f[0][0], f[0][1], ..., f[0][n] f[1][0], f[1][1], ..., f[1][n] … f[m][0], f[m][1], ..., f[m][n] 答案是f[m][n] 时间复杂度（计算步数）O(MN) 空间复杂度（数组大小）O(MN)，可以用滚动数组优化空间至O(N) class Solution { public: bool isMatch(std::string\u0026 A, std::string\u0026 B) { int m = A.size(); int n = B.size(); std::vector\u003cstd::vector\u003cbool\u003e\u003e f(m + 1, std::vector\u003cbool\u003e(n + 1, false)); int i, j; for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = true; continue; } if (j == 0) { f[i][j] = false; continue; } // j \u003e 0 f[i][j] = false; if (B[j - 1] != '*') { if (i \u003e 0 \u0026\u0026 (B[j - 1] == '?' || B[j - 1] == A[i - 1])) { f[i][j] = f[i - 1][j - 1]; } } else { // * represents 0 character f[i][j] = f[i][j - 1]; if (i \u003e 0) { f[i][j] = (f[i][j] || f[i - 1][j]); } } } } return f[m][n]; } };","动态规划组成部分四计算顺序-28#动态规划组成部分四：计算顺序":"f[0][0][0], f[0][0][1], ..., f[0][0][n], f[0][1][0], ..., f[0][1][n], ..., f[0][m][n] f[1][0][0], f[1][0][1], ..., f[1][0][n], f[1][1][0], ..., f[1][1][n], ..., f[1][m][n] … f[T][0][0], f[T][0][1], ..., f[T][0][n], f[T][1][0], ..., f[T][1][n], ..., f[T][m][n] 答案是max(f[T][0][0], f[T][0][1], ..., f[T][m][n]) 时间复杂度：O(Tmn) 空间复杂度：O(Tmn)，可以用滚动数组优化空间至O(mn) class Solution { public: int findMaxForm(std::vector\u003cstd::string\u003e\u0026 A, int m, int n) { if (A.size() == 0) { return 0; } int T = A.size(); std::vector\u003cint\u003e cnt0(T, 0); std::vector\u003cint\u003e cnt1(T, 0); int i, j, k; for (i = 0; i \u003c T; ++i) { cnt0[i] = cnt1[i] = 0; std::string s = A[i]; for (j = 0; j \u003c s.size(); ++j) { if (s[j] == '0') { ++cnt0[i]; } else { ++cnt1[i]; } } } std::vector\u003cstd::vector\u003cstd::vector\u003cint\u003e\u003e\u003e f(T + 1, std::vector\u003cstd::vector\u003cint\u003e\u003e(m + 1, std::vector\u003cint\u003e(n + 1, 0))); for (i = 0; i \u003c= m; ++i) { for (j = 0; j \u003c= n; ++j) { f[0][i][j] = 0; } } for (i = 1; i \u003c= T; ++i) { for (j = 0; j \u003c= m; ++j) { for (k = 0; k \u003c= n; ++k) { // j 0's, k 1's // do not take A[i - 1] f[i][j][k] = f[i - 1][j][k]; // take A[i - 1] if (j \u003e= cnt0[i - 1] \u0026\u0026 k \u003e= cnt1[i - 1]) { f[i][j][k] = std::max(f[i][j][k], f[i - 1][j - cnt0[i - 1]][k - cnt1[i - 1]] + 1); } } } } int ans = 0; for (j = 0; j \u003c= m; ++j) { for (k = 0; k \u003c= n; ++k) { ans = std::max(ans, f[T][j][k]); } } return ans; } };","动态规划组成部分四计算顺序-3#动态规划组成部分四：计算顺序":"f[0], f[1], f[2], ..., f[N] 时间复杂度O(N) 空间复杂度O(N)","动态规划组成部分四计算顺序-4#动态规划组成部分四：计算顺序":"用f[i][0]表示A[i - 1]变成0的情况下，前i位最少翻转多少个能满足要求 用f[i][1]表示A[i - 1]变成1的情况下，前i位最少翻转多少个能满足要求 $f[i][j] = min_{(k, j) ≠ (0, 1)}(f[i - 1][k] + 1_{A[i - 1] ≠ j})$ 答案是min(f[N][0], f[N][1]) 算法时间复杂度O(N)，空间复杂度O(N)，可以用滚动数组优化至O(1)","动态规划组成部分四计算顺序-5#动态规划组成部分四：计算顺序":"初始化f[0][1], ..., f[0][5] f[1][1], ..., f[1][5] … f[N][1], ..., f[N][5] 时间复杂度：O(N), 空间复杂度：O(N), 优化后可以O(1), 因为f[i][1..5]只依赖于f[i - 1][1..5]","动态规划组成部分四计算顺序-6#动态规划组成部分四：计算顺序":"初始化f[0][1], ..., f[0][**2K + 1**] f[1][1], ..., f[1][**2K + 1**] … f[N][1], ..., f[N][**2K + 1**] 时间复杂度：O(NK), 空间复杂度：O(NK), 优化后可以O(1), 因为f[i][1..**2K + 1**]只依赖于f[i - 1][1..**2K + 1**]","动态规划组成部分四计算顺序-7#动态规划组成部分四：计算顺序":"f[j] = 以a[j]结尾的最长上升子序列的长度 计算f[0], f[1], f[2], ..., f[n - 1] 答案是max(f[0], f[1], f[2], …, f[n - 1]) 算法时间复杂度O(n^2), 空间复杂度O(n)","动态规划组成部分四计算顺序-8#动态规划组成部分四：计算顺序":"初始化f[0] 计算f[1], ..., f[N] 答案是f[N] 空间复杂度是O(n)并且不能用滚动数组 时间复杂度是sqrt(1) + sqrt(2) + ... + sqrt(n) = O(n * sqrt(n))","动态规划组成部分四计算顺序-9#动态规划组成部分四：计算顺序":"计算f[0], f[1], ..., f[N]","动态规划解法#动态规划解法":"从 0 到 N - 1 枚举 j, 即第几天卖 时刻保存当前为止（即 0 ~ j - 1 天）的最低加个P_i 最大的P_j - P_i 即为答案","区间型动态规划#区间型动态规划":"给定一个序列/字符串，进行一些操作 最后一步会将序列/字符串 去头/去尾 剩下的会是一个区间[i, j] 状态自然定义为f[i][j]，表示面对子序列[i, ..., j]时的最优性质","博弈#博弈":"这道题是一道博弈题，目标是让自己拿到的数字之和不比对手小 设己方数字和是A，对手数字和是B，即目标是A \u003e= B 等价于A - B \u003e= 0 也就是说，如果Alice和Bob都存着自己的数字和与对手的数字和之差，分别记为S_A = A - B，S_B = B - A 则Alice的目标是最大化S_A，Bob的目标是最大化S_B 当一方X面对剩下的数字，可以认为X就是当前的先手，他的目标就是最大化S_X = X - Y 当他取走一个数字m后，对手Y变成先手，同理他也要最大化S_Y = Y - X important: 对于X来说，S_X = - S_Y + m 其中，m是当前这步的数字，-S_Y是对手看来的数字差取相反数（因为先手是X） 现在X有两种选择，取第一个数字m_1或最后一个数字m_2，为了最大化S_X，应该选择较大的那个S_X","博弈型动态规划#博弈型动态规划":"博弈为两方游戏\n一方先下，在一定规则下依次出招\n如果满足一定条件，则一方胜\n目标：取胜\n先手：先出招的一方\n出招后，先手换人，新的先手面对一个新的局面\nNote: 只记先手(为了简化状态)，当前要下棋的那个人\n只有博弈型动态规划不是从最后一步分析，而是从第一步分析 反例：如果往一个空棋盘上加石子，先到n的人先赢，那这个时候应该按最后一步来想，因为这个时候子问题从后往前会更小 博弈型动态规划基本上都是: 取数字，取石子","博弈型动态规划必胜-vs-必败#博弈型动态规划：必胜 vs 必败":"怎么选择让自己赢的一步 就是走了这一步之后，对手面对剩下的石子，他必输(这里不是循环定义) 知识点：如果取1个或2个石子后，能让剩下的局面先手必败，则当前先手必胜 知识点：如果不管怎么走，剩下的局面都是先手必胜，则当前先手必败 宗旨： 必胜：在当下的局面走出一步，让对手无路可逃（即必败） 必败：自己无路可逃（即必败）","博弈子问题#博弈子问题":"当Bob面对a[1 .. N - 1]，他这时是先手 他的目标同样是最大化先手（自己）和后手（Alice）的数字差 但是此时的数字少了一个：a[1 .. N - 1] 子问题 状态：设f[i][j]为一方先手在面对a[i .. j]这些数字时，能得到的最大的与对手的数字差","四个方向#四个方向":"Up[i][j]表示如果(i, j)放一个炸弹向上可以最多炸死多少敌人 一共四个方向 可以类似地计算Down[i][j], Left[i][j], Right[i][j]，注意计算顺序会有改变 (i, j)如果是空地，放一个炸弹最多炸死的敌人数是： Up[i][j] + Down[i][j] + Left[i][j] + Right[i][j] 取最大值即可 时间复杂度和空间复杂度依然为O(MN)","回到原题#回到原题":"S最少划分成多少个回文串 f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | isPlain[j][i - 1] = True) 答案是f[N] - 1(因为原题是求最少划分几次) 时间复杂度O(n^2) 空间复杂度O(n^2) class Solution { public: int minCut(std::string\u0026 S) { int n = S.size(); if (n == 0) { return 0; } std::vector\u003cstd::vector\u003cbool\u003e\u003e palin = CalcPalin(S); std::vector\u003cint\u003e f(n + 1); f[0] = 0; int i, j; // S[0 .. i-1] for (i = 1; i \u003c= n; ++i) { f[i] = 0x3f3f3f3f; // S[j .. i-1] for (j = 0; j \u003c i; ++j) { if (palin[j][i - 1]) { f[i] = std::min(f[i], f[j] + 1); } } } return f[n] - 1; } std::vector\u003cstd::vector\u003cbool\u003e\u003e CalcPalin(std::string\u0026 S) { int n = S.size(); std::vector\u003cstd::vector\u003cbool\u003e\u003e palin(n, std::vector\u003cbool\u003e(n, false)); int i, j, mid; for (mid = 0; mid \u003c n; ++mid) { // odd-length palindrome i = j = mid; while (i \u003e= 0 \u0026\u0026 j \u003c n \u0026\u0026 S[i] == S[j]) { palin[i][j] = true; --i; ++j; } // even-length palindrome i = mid - 1; j = mid; while (i \u003e= 0 \u0026\u0026 j \u003c n \u0026\u0026 S[i] == S[j]) { palin[i][j] = true; --i; ++j; } } return palin; } };","回文串判断#回文串判断":"方法一：从左到右 和 从右到左 各读一遍，完全一样 方法二：可以用两个指针从两头向中间移动，每一步两个指针指向的字符都必须相等 但是动态规划转移方程是f[i] = min_{j = 0, ..., i-1}(f[j] + 1 | S[j .. i-1]是回文串) 每次都判断S[j .. i-1]是不是回文串很慢( 转移方程为O(n^3)太慢) 如何优化？","回文串种类#回文串种类":"回文串分两种： 长度为奇数 长度为偶数","在字符串中找到所有回文串#在字符串中找到所有回文串":"以字符串的每一个字符为中点，向两边扩展，找到所有回文串","坐标型#坐标型":"dp[坐标] = 行走到这个坐标的最优值\n转移：上一个坐标从哪里来，比如：上一次打劫了哪个房屋，或上一次行走了那个坐标","坐标型动态规划-总结#坐标型动态规划 总结":"给定输入为序列或者网格/矩阵 动态规划状态下标为序列下标i或者网格坐标(i, j) f[i]：以第i个元素结尾的某种性质 f[i][j]：到格子(i, j)的路径的性质 初始化设置f[0]的值 / f[0][0 ... n - 1]的值 二维空间优化：如果f[i][j]的值只依赖于当前行和前一行，则可以用滚动数组节省空间","坐标型动态规划最小路径和#坐标型动态规划：最小路径和":"Leetcode 64 Minimum Path Sum // Mine correct version class Solution { public: int minPathSum(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e f(n, std::vector\u003cint\u003e(m)); f[0][0] = grid[0][0]; for (int i = 1; i \u003c m; ++i) { f[0][i] = f[0][i - 1] + grid[0][i]; } for (int i = 1; i \u003c n; ++i) { f[i][0] = f[i - 1][0] + grid[i][0]; } for (int i = 1; i \u003c n; ++i) { for (int j = 1; j \u003c m; ++j) { f[i][j] = std::min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; } } return f[n - 1][m - 1]; } }; // Official correct version class Solution { public: int minPathSum(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e f(n, std::vector\u003cint\u003e(m)); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = grid[i][j]; continue; } f[i][j] = INT_MAX; // if it has a grid above if (i \u003e 0) { f[i][j] = std::min(f[i][j], f[i - 1][j] + grid[i][j]); } // if it has a grid to the left if (j \u003e 0) { f[i][j] = std::min(f[i][j], f[i][j - 1] + grid[i][j]); } } } return f[n - 1][m - 1]; } };","坐标型动态规划最小路径和空间优化#坐标型动态规划：最小路径和\u0026ndash;空间优化":"f[i][j] = std::min{f[i - 1][j], f[i][j - 1]} + A[i][j] 计算第i行时，只需要第i行和第i - 1行的f 所以，只需要保存两行的f值：f[i][0 ... n - 1]和f[i - 1][0 ... n - 1] 用滚动数组实现 开数组时，只开f[0][0 ... n - 1]和f[1][0 ... n - 1] 计算f[0][0], ..., f[0][n - 1]，计算f[1][0], ..., f[1][n - 1] 计算f[2][0 ... n - 1]时，开f[2][0 ... n - 1]，删掉f[0][0 ... n - 1]，因为已经不需要f[0][0 ... n - 1]的值了 计算f[3][0 ... n - 1]时，开f[3][0 ... n - 1]，删掉f[1][0 ... n - 1]，因为已经不需要f[1][0 ... n - 1]的值了 实际操作时，可以不用每次开数组，而是用滚动法 计算f[0][0], ..., f[0][n - 1]，计算f[1][0], ..., f[1][n - 1] 计算f[2][0 ... n - 1]时，把值写在f[0][0 ... n - 1]的数组里 同理，f[3][0 ... n - 1]写在f[1][0 ... n - 1]的数组里 最后f[m - 1][n - 1]存储在f[0][n - 1]（或者f[1][n - 1]）里，直接输出 对于网格上的动态规划，如果f[i][j]只依赖于本行的f[i][x]与前一行的f[i - 1][y]，那么就可以采用滚动数组的方法压缩空间。空间复杂度O(n)\n如果网格行数少列数多（大胖子网格），那么就可以逐列计算，滚动数组的长度为行数，空间复杂度O(M)\nclass Solution { public: int minPathSum(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e f(2, std::vector\u003cint\u003e(m)); int old, now = 0; // old: f[old][...] is holding f[i - 1][...] // now: f[now][...] is holding f[i][...] for (int i = 0; i \u003c n; ++i) { // swap old and now old = now; now = 1 - now; // 0--\u003e1, 1--\u003e0 // 将所有的 f[i] 变成 f[now]； f[i - 1] 变成 f[old] for (int j = 0; j \u003c m; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[now][j] = grid[i][j]; continue; } f[now][j] = INT_MAX; // if it has a grid above if (i \u003e 0) { f[now][j] = std::min(f[now][j], f[old][j] + grid[i][j]); } // if it has a grid to the left if (j \u003e 0) { f[now][j] = std::min(f[now][j], f[now][j - 1] + grid[i][j]); } } } return f[now][m - 1]; } }; 取模运算(%) 会比这个稍微慢一些","坐标型动态规划最小路径和路径打印#坐标型动态规划：最小路径和\u0026ndash;路径打印":"最值和可行性都可以打印方案，但存在数不行 class Solution { public: int minPathSum(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 grid) { int n = grid.size(); int m = grid[0].size(); if (n == 0 || m == 0) { return 0; } std::vector\u003cstd::vector\u003cint\u003e\u003e f(n, std::vector\u003cint\u003e(m)); std::vector\u003cstd::vector\u003cint\u003e\u003e pi(n, std::vector\u003cint\u003e(m)); // if f[i][j] depends on f[i - 1][j], pi[i][j] = 0 // if f[i][j] depends on f[i][j - 1], pi[i][j] = 1 for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[i][j] = grid[i][j]; continue; } f[i][j] = INT_MAX; // if it has a grid above if (i \u003e 0) { f[i][j] = std::min(f[i][j], f[i - 1][j] + grid[i][j]); if (f[i][j] == f[i - 1][j] + grid[i][j]) { pi[i][j] = 0; } } // if it has a grid to the left if (j \u003e 0) { f[i][j] = std::min(f[i][j], f[i][j - 1] + grid[i][j]); if (f[i][j] == f[i][j - 1] + grid[i][j]) { pi[i][j] = 1; } } } } // (n - 1, m - 1) std::vector\u003cstd::vector\u003cint\u003e\u003e path(n + m - 1, std::vector\u003cint\u003e(2)); int p; int i = n - 1; int j = m - 1; // infer the path backward from (n - 1, m - 1) for (p = n + m - 2; p \u003e= 0; --p) { path[p][0] = i; path[p][1] = j; if (p == 0) { break; } if (pi[i][j] == 0) { --i; } else { --j; } } for (p = 0; p \u003c n + m - 1; ++p) { std::cout \u003c\u003c \"(\" \u003c\u003c path[p][0] \u003c\u003c \", \" \u003c\u003c path[p][1] \u003c\u003c \"): \" \u003c\u003c grid[path[p][0]][path[p][1]] \u003c\u003c std::endl; } return f[n - 1][m - 1]; } }; # expected result from the test case: [[1,5,7,6,8],[4,7,4,4,9],[10,3,2,3,2]] (0, 0): 1 (1, 0): 4 (1, 1): 7 (2, 1): 3 (2, 2): 2 (2, 3): 3 (2, 4): 2","坐标型动态规划炸弹袭击#坐标型动态规划：炸弹袭击":"Leetcode 361 Bomb Enemy","子问题#子问题":"求油漆前N栋房子并且房子N - 1是红色、蓝色、绿色的最小花费 需要知道油漆前N - 1栋房子并且房子N - 2是红色、蓝色、绿色的最小花费 子问题 状态：设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2] f = new int[n + 1][3]","子问题-1#子问题":"设数字串长度为N 要求数字串前N个字符的解密方式数 需要知道数字串前N - 1和N - 2个字符的解密方式数 子问题 状态：设数字串S前i个数字解密成字母串有f[i]种方式","子问题-10#子问题":"要求前N个物品有多少种方式拼出重量 0, 1, …, Target 需要知道前N - 1个物品有多少种方式拼出重量 0, 1, …, Target 子问题 状态：设f[i][w] = 用前 i 个物品有多少种方式拼出重量w","子问题-11#子问题":"原问题要求 有多少种组合能拼成Target 子问题 设f[i] = 有多少种组合能拼出重量i","子问题-12#子问题":"要求S[i ... j]的最长回文子序列 如果S[i] = S[j]，需要知道S[i + 1 ... j - 1]的最长回文子序列 否则答案是S[i + 1 .. j]的最长回文子序列 或 S[i ... j - 1]的最长回文子序列 子问题 状态：设f[i][j]为S[i ... j]的最长回文子序列的长度","子问题-13#子问题":"要求T是否由S变换而来 需要知道T_1是否由S_1变换而来的，T_2是否由S_2变换而来 需要知道T_1是否由S_2变换而来的，T_2是否由S_1变换而来 S_1, S_2, T_1, T_2长度更短 子问题 状态：f[i][j][k][h]表示T[k .. h]是否由S[i .. j]变换而来","子问题-14#子问题":"要求扎破1 ~ N号气球，最多获得的金币数 需要知道扎破1 ~ i - 1号气球，最多获得的金币数和扎破i+1 ~ N号气球，最多获得的金币数 子问题 状态：设f[i][j]为扎破i+1 ~ j-1号气球，最多获得的金币数","子问题-15#子问题":"要求A[0 .. m - 1]和B[0 .. n - 2]的最长公共子序列，A[0 .. m - 2]和B[0 .. n - 1]的最长公共子序列和A[0 .. m - 2]和B[0 .. n - 2]的最长公共子序列 原来是求A[0 .. m - 1]和B[0 .. n - 1]的最长公共子序列 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符[0 .. j - 1]的最长公共子序列的长度","子问题-16#子问题":"要求X[0 .. m + n - 1]是否由A[0 .. m - 1]和B[0 .. n - 1]交错形成 需要知道X[0 .. m + n - 2]是否由A[0 .. m - 2]和B[0 .. n - 1]交错形成，以及X[0 .. m + n - 2]是否由A[0 .. m - 1]和B[0 .. n - 2]交错形成 子问题 状态：设f[s][i][j]为X前s个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成 但是s = i + j，所以可以简化为：设f[i][j]为X前i + j个字符是否由A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]交错形成","子问题-17#子问题":"要求A[0 .. m - 1]和B[0 .. n - 2]的最小编辑距离，A[0 .. m - 2]和B[0 .. n - 1]的最小编辑距离和A[0 .. m - 2]和B[0 .. n - 2]的最小编辑距离 原来是求A[0 .. m - 1]和B[0 .. n - 1]的最小编辑距离 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B的前j个字符B[0 .. j - 1]的最小编辑距离","子问题-18#子问题":"要求A前m个字符和B前n个字符能否匹配，需要知道A前m个字符和B前n - 1个字符，A前m - 1个字符和B前n个字符以及A前m个字符和B前n - 2个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配","子问题-19#子问题":"要求A前m个字符和B前n个字符能否匹配，需要知道A前m - 1个字符和B前n - 1个字符，A前m个字符和B前n - 1个字符以及A前m - 1个字符和B前n个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配","子问题-2#子问题":"需要知道(i - 1, j)格放一个炸弹向上能炸死的敌人数 原来要求(i, j)格放一个炸弹向上能炸死的敌人数 子问题 状态： Up[i][j]表示(i, j)格放一个炸弹向上能炸死的敌人数","子问题-20#子问题":"要求A[0 .. m - 1]和B[0 .. n - 2]的最小编辑距离，A[0 .. m - 2]和B[0 .. n - 1]的最小编辑距离和A[0 .. m - 2]和B[0 .. n - 2]的最小编辑距离 原来是求A[0 .. m - 1]和B[0 .. n - 1]的最小编辑距离 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B的前j个字符B[0 .. j - 1]的最小编辑距离","子问题-21#子问题":"要求A前m个字符和B前n个字符能否匹配，需要知道A前m个字符和B前n - 1个字符，A前m - 1个字符和B前n个字符以及A前m个字符和B前n - 2个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配","子问题-22#子问题":"要求A前m个字符和B前n个字符能否匹配，需要知道A前m - 1个字符和B前n - 1个字符，A前m个字符和B前n - 1个字符以及A前m - 1个字符和B前n个字符能否匹配 子问题 状态：设f[i][j]为A前i个字符A[0 .. i - 1]和B前j个字符B[0 .. j - 1]能否匹配","子问题-3#子问题":"要求N的二进制表示中有多少1 在N的二进制去掉最后一位N mod 2（有两种方法：» and floor(/)），设新的数是Y = (N \u003e\u003e 1)（右移一位） 要知道Y的二进制表示中有多少1 子问题 状态：设f[i]表示i的二进制表示中有多少个1 知识点：和位操作相关的动态规划一般用值作状态","子问题-4#子问题":"要求f[N][1], ..., f[N][5] 需要知道f[N - 1][1], ..., f[N - 1][5] 子问题","子问题-5#子问题":"因为不确定最优策略中a[j]前一个元素a[i]是哪个，需要枚举每个i 求以a[i]结尾的最长上升子序列 本来是求以a[j]结尾的最长上升子序列 化为子问题：i","子问题-6#子问题":"求S前N个字符S[0 .. N-1]最少划分为几个回文串 需要知道S前j个字符[0 .. j-1]最少可以划分成几个回文串 子问题 状态：设S前i个字符S[0 .. i-1]最少可以划分成f[i]个回文串","子问题-7#子问题":"求K个人最短需要多少时间抄完前N本书 需要知道K - 1个人最少需要多少时间抄完前j本书 子问题 状态：设f[k][i]为前k个抄写员最少需要多少时间抄完前i本书","子问题-8#子问题":"要求面对N个石子，是否先手必胜 需要知道面对N - 1个石子和N - 2个石子，是否先手必胜 子问题 状态：设f[i]表示面对i个石子，是否先手必胜（f[i] = TRUE / FALSE）","子问题-9#子问题":"要求前N个物品能不能拼出重量 0, 1, …, M 需要知道前N - 1个物品能不能拼出重量 0, 1, …, M 子问题 状态：设f[i][w] = 能否用前i个物品拼出重量w (TRUE / FALSE) 常见误区：错误 设f[i]表示前i个物品能拼出的最大重量（不超过M） 反例：A = [3 9 5 2], M = 10 错误原因：最优策略中，前N - 1个物品拼出的不一定是不超过M的最大重量 或者用黄金定律，即一定要有背包承重的维度","存在型动态规划#存在型动态规划":"Lintcode 116 Jump Game","常见dp类型#常见DP类型：":"坐标型（20%）\n序列型（20%）\n划分型（20%）\n区间型（15%）\n背包型（10%）\n最长序列型（5%）\n博弈型（5%）\n综合型（5%）\nDP时间空间优化\nFollowUp 常考：滚动数组 或者 降维 DP打印路径","序列型动态规划买卖股票1#序列型动态规划\u0026ndash;买卖股票1":"Lintcode 149 买卖股票1","序列型动态规划买卖股票2#序列型动态规划\u0026ndash;买卖股票2":"Lintcode 150 买卖股票2","序列型动态规划买卖股票3-序列型#序列型动态规划\u0026ndash;买卖股票3: 序列型":"Lintcode 151 买卖股票3 e.g. 输入：[4,4,6,1,1,4,2,5] 输出：6（4买入，6卖出，1买入，5卖出，收益为(6 - 4) + (5 - 1) = 6)","序列型动态规划买卖股票4#序列型动态规划\u0026ndash;买卖股票4":"Lintcode 393 买卖股票4","序列型动态规划小结#序列型动态规划\u0026ndash;小结":"当思考序列型动态规划最后一步时，这一步的选择依赖于前一步的某种状态 题目 最后一步需要知道的信息 序列 + 状态 Paint House 房子N - 1 油漆成红色，则房子N - 2不能油漆成红色 记录油漆前N - 1栋房子并且房子N - 2是红、蓝、绿色的最小花费 Digital Flip 翻转A[i]时，A[i - 1]A[i]不能是01 记录翻转前N - 1位并且第N - 2位是0/1的最小翻转次数 Best Time to Buy and Sell Stock III 第j天卖股票，第i天买股票(i \u003c j)时，需要知道第i天之前是不是已经买了股票 记录前N天买卖股票最大获利，并且第N - 1天：1.未买卖股票；2.买了第一次股票还没卖；…；5.已经第二次卖了股票 初始化时，f[0]代表前0个元素/前0天当情况 与坐标型动态规划区别 计算时，f[i]代表前i个元素（即元素0~i-1）的某种性质","序列型动态规划数字翻转#序列型动态规划\u0026ndash;数字翻转":"Lintcode 843 数字翻转","序列型动态规划的时间优化房屋染色ii#序列型动态规划的时间优化\u0026ndash;房屋染色II":"Lintcode 516 房屋染色II\n时间优化有三个可以做的事情：\n看式子，并展开(也许会发现里面有重复) 画图 小例子","序列型动态规划简介#序列型动态规划\u0026ndash;简介":"给定一个序列 动态规划方程f[i]中的下标i表示前i个元素a[0], a[1], ..., a[i - 1]的某种性质 坐标型的f[i]表示以a[i]为结尾的某种性质 初始化中，f[0]表示空序列的性质 坐标型动态规划的初始条件f[0]就是指以a_0为结尾的子序列的性质","思考如何做到时间复杂度onlogn#思考：如何做到时间复杂度O(nlogn)":"","思路#思路":"已知每个整数范围[1,100]，那么对于每个元素，为了调整到该元素和与之相邻的元素的差不大于target，该元素调整的范围就在[1,100]。所以对于数组A[]的每一位元素，我们都需要进行[1,100]范围内的可能状态的转移。\n令dp[i][j]表示元素A[i]=j时，A[i]与A[i-1]差值不大于target所需要付出的最小代价。\n当A[i]=j时，可行的A[i-1]的范围为[max(1, j - target)，min(100, j + target)]。而dp[i][j]为所有可行的A[i-1]中，花费代价最小的一种可能，再加上A[i]调整到 j 所需花费abs(j - A[i])。\n当A[i]=j时，k在[max(1, j - target)，min(100, j + target)]范围内时，我们可以写出以下式子：","打印最长公共子序列#打印最长公共子序列":"class Solution { public: int longestCommonSubsequence(std::string\u0026 A, std::string\u0026 B) { int n = A.size(); int m = B.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e f(n + 1, std::vector\u003cint\u003e(m + 1, 0)); std::vector\u003cstd::vector\u003cint\u003e\u003e pi(n + 1, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= m; ++j) { if (i == 0 || j == 0) { f[i][j] = 0; continue; } f[i][j] = std::max(f[i][j - 1], f[i - 1][j]); if (f[i][j] == f[i - 1][j]) { pi[i][j] = 1; } else { pi[i][j] = 2; } if (A[i - 1] == B[j - 1]) { f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + 1); if (f[i][j] == f[i - 1][j - 1] + 1) { pi[i][j] = 3; } } } } std::vector\u003cchar\u003e routine(f[n][m]); int p = f[n][m] - 1; int i = n; int j = m; while (i \u003e 0 \u0026\u0026 j \u003e 0) { if (pi[i][j] == 1) { --i; // not using A's tail } else { if (pi[i][j] == 2) { --j; // not using B's tail } else { routine[p] = A[i - 1]; --p; --i; --j; } } } for (p = 0; p \u003c f[n][m]; ++p) { std::cout \u003c\u003c routine[p]; } return f[n][m]; } };","打印路径#打印路径":"class Solution { public: int backPackII(int m, std::vector\u003cint\u003e\u0026 A, std::vector\u003cint\u003e\u0026 V) { int n = A.size(); std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n + 1, std::vector\u003cint\u003e(m + 1, 0)); // pi has the same size with dp std::vector\u003cstd::vector\u003cint\u003e\u003e pi(n + 1, std::vector\u003cint\u003e(m + 1, 0)); for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= m; ++j) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (j - A[i - 1] \u003e= 0) { dp[i][j] = std::max(dp[i - 1][j - A[i - 1]] + V[i - 1], dp[i - 1][j]); // keep tracking whether we choose the item if (dp[i][j] == dp[i - 1][j - A[i - 1]] + V[i - 1]) { pi[i][j] = 1; } } else { dp[i][j] = dp[i - 1][j]; } } } // print path std::vector\u003cbool\u003e selected(n); int weight = m; for (int i = n; i \u003e= 1; --i) { if (pi[i][weight] == 1) { selected[i - 1] = true; weight -= A[i - 1]; } else { selected[i - 1] = false; } } for (int i = 0; i \u003c n; ++i) { if (selected[i]) { std::cout \u003c\u003c \"i: \" \u003c\u003c i \u003c\u003c \"A[i]: \" \u003c\u003c A[i] \u003c\u003c \"V[i]: \" \u003c\u003c V[i] \u003c\u003c std::endl; } } return dp[n][m]; } };","时间优化#时间优化":"优化方法 记录下最小值f[i - 1][a]和次小值f[i - 1][b] 如果去掉的是最小值，则f[i][a] = f[i - 1][b] + cost[i - 1][a] 如果去掉的不是最小值，则f[i][j] = f[i - 1][a] + cost[i - 1][j] 时间复杂度降为O(nk)","最值型动态规划--dp组成部分一确定状态#最值型动态规划 \u0026amp;\u0026amp; DP组成部分一：确定状态":"Lintcode 669: Coin Change DP组成部分一：确定状态 状态在DP中的作用属于定海神针 简单的说，解DP的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么 类似于解数学题中 X, Y, Z 代表什么 确定状态需要两个意识： 最后一步：最优策略中的最后一个决策 当前问题： 虽然我们不知道最优策略是什么，但是最优策略肯定是K枚硬币a1, a2, ..., ak面值加起来是27 所以一定有一枚最后的硬币：ak 除掉这枚硬币，前面硬币的面值加起来是27 - ak Key 1: 我们不关心前面的K - 1枚硬币是怎么拼出27 - ak的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道ak和K，但是我们确定前面的硬币拼出了27 - ak Key 2: 因为是最优策略，所以拼出27 - ak的硬币数一定要最少，否则这就不是最优策略了 子问题 所以我们就要求：最少用多少枚硬币拼出27 - ak 愿问题是 最少用多少枚硬币拼出27 我们将原问题转化成了一个子问题，而且规模更小：27 - ak 为了简化定义，我们设状态f(X) = 最少用多少枚硬币拼出X","最大矩形#最大矩形":"Leetcode 85 最大矩形\n这题和Lintcode 122 直方图最大矩形覆盖很相似，只需要求出以每一行作为底最大的矩形是多少，每一行都有一个height数组，利用单调栈，每次更新height数组，height数组代表的是这一列上面有多少个连续的1，即矩形的高度，以每一行作为底（直方图最下面）时最大矩形面积，然后记录最大值即可。\n初始化dp数组，用dp数组记录当前位置上方有多少个连续1。对于每一行作为底，利用单调栈求高度，寻找最大的底乘高。\n注意这个栈是 从栈底到栈顶依次是从小到大的。如果栈中的数比当前的数大（或着等于）就要处理栈顶的（记录左右两边的比它小的第一个数）。\n然后如果遍历完之后，单独处理栈，此时所有元素右边都不存在比它小的height[j]表示目前的底上（第1行），j位置往上（包括j位置）有多少连续的1。\n不断更新最大面积。\n时间复杂度O(mn): dp的O(nm)和单调栈的O(n) 空间复杂度O(mn): dp的大小（下面的代码的空间复杂度可以优化成O(n)） class Solution { public: int maximalRectangle(std::vector\u003cstd::vector\u003cchar\u003e\u003e\u0026 matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return 0; } int ans = 0; int n = matrix.size(); int m = matrix[0].size(); std::vector\u003cstd::vector\u003cint\u003e\u003e dp(n, std::vector\u003cint\u003e(m + 1)); for (int i = 0; i \u003c n; ++i) { // 每个位置上方有多少连续的1 for (int j = 0; j \u003c m; ++j) { if (i == 0 \u0026\u0026 matrix[i][j] == '1') { dp[i][j] = 1; continue; } if (matrix[i][j] == '1') { dp[i][j] = dp[i - 1][j] + 1; } } } for (int i = 0; i \u003c n; ++i) { // 把每一行作为底找最大矩形 ans = std::max(ans, largestRectangleArea(dp[i])); } return ans; } private: int largestRectangleArea(std::vector\u003cint\u003e\u0026 heights) { std::deque\u003cint\u003e S; heights[heights.size() - 1] = 0; int sum = 0; for (int i = 0; i \u003c heights.size(); ++i) { if (S.empty() || heights[i] \u003e heights[S.back()]) { S.push_back(i); } else { int temp = S.back(); S.pop_back(); sum = std::max(sum, heights[temp] * (S.empty() ? i : i - S.back() - 1)); --i; // 拿着右边界，寻找左边界 } } return sum; } };","最长序列型动态规划#最长序列型动态规划":"题目给定一个序列\n要求找出符合条件的最长子序列\n方法\n记录以每个元素i结尾的最长子序列的长度 计算时，在i之前枚举子序列上一个元素是哪个 为坐标型动态规划\nLintcode 76 Longest Increasing Subsequence","滚动数组优化#滚动数组优化":"class Solution { public: bool isInterleave(std::string\u0026 A, std::string\u0026 B, std::string\u0026 X) { int n = A.size(); int m = B.size(); if (X.size() != n + m) { return false; } // first std::vector\u003cstd::vector\u003cbool\u003e\u003e f(2, std::vector\u003cbool\u003e(m + 1, false)); int i, j; // second int old, now = 0; for (i = 0; i \u003c= n; ++i) { // third old = now; now = 1 - now; // then change all f[i] to f[now] // change all f[i - 1] to f[old] for (j = 0; j \u003c= m; ++j) { if (i == 0 \u0026\u0026 j == 0) { f[now][j] = true; continue; } f[now][j] = false; if (i \u003e 0 \u0026\u0026 X[i + j - 1] == A[i - 1] \u0026\u0026 f[old][j]) { f[now][j] = true; } if (j \u003e 0 \u0026\u0026 X[i + j - 1] == B[j - 1] \u0026\u0026 f[now][j - 1]) { f[now][j] = true; } } } return f[now][m]; } };","滚动数组优化-1#滚动数组优化":"class Solution { public: int minDistance(std::string\u0026 A, std::string\u0026 B) { int m = A.size(); int n = B.size(); // first std::vector\u003cstd::vector\u003cint\u003e\u003e f(2, std::vector\u003cint\u003e(n + 1, 0)); int i, j; // second int old, now = 0; for (i = 0; i \u003c= m; ++i) { // third old = now; now = 1 - now; for (j = 0; j \u003c= n; ++j) { if (i == 0) { f[now][j] = j; continue; } if (j == 0) { f[now][j] = i; continue; } f[now][j] = std::min(std::min(f[old][j], f[now][j - 1]), f[old][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { f[now][j] = std::min(f[now][j], f[old][j - 1]); } } } return f[now][n]; } };","滚动数组优化-2#滚动数组优化":"class Solution { public: int minDistance(std::string\u0026 A, std::string\u0026 B) { int m = A.size(); int n = B.size(); // first std::vector\u003cstd::vector\u003cint\u003e\u003e f(2, std::vector\u003cint\u003e(n + 1, 0)); int i, j; // second int old, now = 0; for (i = 0; i \u003c= m; ++i) { // third old = now; now = 1 - now; for (j = 0; j \u003c= n; ++j) { if (i == 0) { f[now][j] = j; continue; } if (j == 0) { f[now][j] = i; continue; } f[now][j] = std::min(std::min(f[old][j], f[now][j - 1]), f[old][j - 1]) + 1; if (A[i - 1] == B[j - 1]) { f[now][j] = std::min(f[now][j], f[old][j - 1]); } } } return f[now][n]; } };","状态#状态":"令dp[i][j]表示从左到右调整到前i个数时，将第i个数的数值调整为j所需要付出的最小代价。 整个调整的过程中要满足相邻两数之差不超过target","生成回文串#生成回文串":"假设我们现在不是寻找回文串，而是生成回文串 从中间开始，向两边扩展，每次左右两端加上同样的字符","直方图最大矩形覆盖#直方图最大矩形覆盖":"Leetcode 84 直方图最大矩形覆盖 // LHC version: Monotonic-stack answer class Solution { public: int largestRectangleArea(std::vector\u003cint\u003e\u0026 height) { std::deque\u003cint\u003e S; std::vector\u003cint\u003e heights = height; heights.push_back(-1); int sum = 0; for (int i = 0; i \u003c heights.size(); ++i) { if (S.empty() || heights[i] \u003e heights[S.back()]) { S.push_back(i); } else { int temp = S.back(); S.pop_back(); sum = std::max(sum, heights[temp] * (S.empty() ? i : i - S.back() - 1)); --i; // 拿着右边界，寻找左边界 } } return sum; } }; // Correct Monotonic-stack answer from other students class Solution { public: int largestRectangleArea(std::vector\u003cint\u003e\u0026 heights) { if (heights.size() == 0) { return 0; } std::deque\u003cint\u003e stack; int sum = 0; for (int i = 0; i \u003c= heights.size(); ++i) { int curt = (i == heights.size()) ? -1 : heights[i]; while (!stack.empty() \u0026\u0026 curt \u003c= heights[stack.back()]) { int h = heights[stack.back()]; stack.pop_back(); int w = stack.empty() ? i : i - stack.back() - 1; sum = std::max(sum, h * w); } stack.push_back(i); } return sum; } };","直觉#直觉":"逐个放物品，看是否还能放入 两个关键点: 还有几个物品 还剩多少承重","相关题目#相关题目":"Lintcode 1833 钢笔盒\nLintcode 1850 捡苹果","空间优化#空间优化：":"","简历-最好一页#简历: 最好一页":"清楚简洁，简明扼要，但不要太花里胡哨。不要有错字，错词或者语法错误 Project \u0026 Experience: 一定要和申请的职位相关 写清楚Contribution。避免写成产品介绍，主要写我做了什么，必要的时候写用了什么工具。e.g. I drove …, drove …, design … 可以放一些数字: reduce pipline time by 51.7% 选最喜欢，最擅长，贡献最大的三个projects 倒背如流细节","简历-最好一页-1#简历: 最好一页":"清楚简洁，简明扼要，但不要太花里胡哨。不要有错字，错词或者语法错误 Project \u0026 Experience: 一定要和申请的职位相关 写清楚Contribution。避免写成产品介绍，主要写我做了什么，必要的时候写用了什么工具。e.g. I drove …, drove …, design … 可以放一些数字: reduce pipline time by 51.7% 选最喜欢，最擅长，贡献最大的三个projects 倒背如流细节","编辑距离的实际用途#编辑距离的实际用途":"比较两个字符串 显示较错：input “Chia” 然后根据最小编辑距离1 显示结果\"China\"，然后根据最小编辑距离2 显示结果\"Chinaa\", …","编辑距离的实际用途-1#编辑距离的实际用途":"比较两个字符串 显示较错：input “Chia” 然后根据最小编辑距离1 显示结果\"China\"，然后根据最小编辑距离2 显示结果\"Chinaa\", …","背包型#背包型":"f[i][j] 表示前i次骰子（掷i次骰子）我能够凑出和为j的概率是多少 能想出这个的原因： 影响到状态，影响到每个计算结果的是掷多少次 我们要求的和，求的和是1，求的和是2，的概率也不一样 将以上两个信息全部放到状态当中去 class Solution { public: std::vector\u003cstd::pair\u003cint, double\u003e\u003e dicesSum(int n) { std::vector\u003cstd::pair\u003cint, double\u003e\u003e result; std::vector\u003cstd::vector\u003cdouble\u003e\u003e f(n + 1, std::vector\u003cdouble\u003e(6 * n + 1, 0)); // has to be double for (int i = 1; i \u003c= 6; ++i) { f[1][i] = 1.0 / 6; } for (int i = 2; i \u003c= n; ++i) { for (int j = i; j \u003c= 6 * n; ++j) { // n or i, both work for (int k = 1; k \u003c= 6; ++k) { if (j \u003e k) { f[i][j] += f[i - 1][j - k]; } } f[i][j] /= 6.0; } } for (int j = n; j \u003c= 6 * n; ++j) { result.push_back(std::make_pair(j, f[n][j])); } return result; } };","背包型动态规划#背包型动态规划":"你有一个背包，背包有最大承重 商店里有若干物品，都是免费拿 每个物品有重量和价值 目标：不撑爆背包的前提下 装下最多重量物品 装下最大总价值的物品 有多少种方式正好带走满满一书包物品","计数型动态规划#计数型动态规划":"Lintcode 114 Unique Paths","记录回文串#记录回文串":"从S每一个字符开始向两边扩展 考虑奇数长度回文串 和 偶数长度回文串 用isPlain[i][j]表示S[i .. j]是否是回文串 时间复杂度O(n^2)","记录阶段#记录阶段":"不知道有没有买过，就记录下来 阶段可以保持：即不进行买卖操作 在阶段2，继续持有，获利为当天价格减昨天价格（当天获利，当天结算） 阶段可以变化：买或卖 在阶段2，卖了一股后，进入阶段3","记录阶段-1#记录阶段":"阶段1: 没买卖过 阶段3: 买卖过一次，现在空仓 阶段5: 买卖过两次，现在空仓 … 阶段2K + 1: 买卖过K次，现在空仓 阶段2: 第一次持有，还没有卖 阶段4: 第二次持有，还没有卖 阶段6: 第三次持有，还没有卖 … 阶段2K: 第K次持有，还没有卖","记忆化搜索#记忆化搜索":"class Solution { public: bool isScramble(std::string\u0026 SS, std::string\u0026 TT) { S = SS; T = TT; int m = S.size(); n = T.size(); if (m != n) { return false; } int i, j, len; f.resize(n, std::vector\u003cstd::vector\u003cbool\u003e\u003e(n, std::vector\u003cbool\u003e(n + 1))); done.resize(n, std::vector\u003cstd::vector\u003cbool\u003e\u003e(n, std::vector\u003cbool\u003e(n + 1))); for (len = 1; len \u003c= n; ++len) { for (i = 0; i \u003c= n - len; ++i) { // S[i ... i+len-1] for (j = 0; j \u003c= n - len; ++j) { // T[j ... j+len-1] done[i][j][len] = false; // f[i][j][len] not computed yet } } } calc(0, 0, n); return f[0][0][n]; } private: void calc(int i, int j, int len) { if (done[i][j][len]) { return; } int w; if (len == 1) { f[i][j][1] = (S[i] == T[j]); return; } // break into S1 and S2 // S1 has length w, S2 has length len - w for (w = 1; w \u003c len; ++w) { //no swap // S1--\u003eT1, S2--\u003eT2 calc(i, j, w); calc(i + w, j + w, len - w); if (f[i][j][w] \u0026\u0026 f[i + w][j + w][len - w]) { f[i][j][len] = true; break; } // swap // S1--\u003eT2, S2--\u003eT1 calc(i, j + len - w, w); calc(i + w, j, len - w); if (f[i][j + len - w][w] \u0026\u0026 f[i + w][j][len - w]) { f[i][j][len] = true; break; } } done[i][j][len] = true; // has been computed } std::vector\u003cstd::vector\u003cstd::vector\u003cbool\u003e\u003e\u003e f; std::vector\u003cstd::vector\u003cstd::vector\u003cbool\u003e\u003e\u003e done; int n; std::string S; std::string T; };","记忆化搜索方法#记忆化搜索方法":"一种写程序的方法，不是新的算法 动态规划编程的另一个选择 f[i][j] = max(f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + 2 | S[i] == S[j]) 计算f[0][N - 1] 递归计算f[1][N - 1], f[0, N - 2], f[1][N - 2] 记忆化：计算f[i][j]结束后，将结果保存在数组f[i][j]里，下次如果需要再次计算f[i][j]，直接返回f[i][j] 两种解决动态规划的思路: top-down 记忆化搜索 bottom-up 递推 recurrence 任何动态规划的题 既可以用 记忆化搜索 又可以用 递推","课后习题#课后习题":"","转移方程#转移方程":"dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - A[i])) k是把第i - 1个数调整为k k和j差值不超过target j - target \u003c= k \u003c= j + target","进一步空间优化#进一步空间优化":"f[i][w] = f[i - 1][w] + f[i - 1][w - A_{i - 1}] 可以只开一个数组 按照f[i][Target], ..., f[i][0]的顺序更新 class Solution { public: int backPackV(std::vector\u003cint\u003e\u0026 A, int m) { int n = A.size(); if (n == 0) { return 0; } int f[m + 1]; int i, w; // initialization for (i = 1; i \u003c= m; ++i) { f[i] = 0; } f[0] = 1; // first i items for (i = 1; i \u003c= n; ++i) { for (w = m; w \u003e= A[i - 1]; --w) { // w doesn't have to be 0 here f[w] += f[w - A[i - 1]]; } } return f[m]; } };","递归写法#递归写法":"int f(int X) { // f(X)=最少用多少枚硬币拼出X if (X == 0) { // 0元钱只要0枚硬币 return 0; } int result = 0x3f3f3f3f; // INT_MAX; // 初始化用无穷大 if (X \u003e= 2) { // 最后一枚硬币是2元 result = std::max(f(X - 2) + 1, result); } if (X \u003e= 5) { // 最后一枚硬币是5元 result = std::max(f(X - 5) + 1, result); } if (X \u003e= 7) { // 最后一枚硬币是7元 result = std::max(f(X - 7) + 1, result); } return result; }","递归写法的不可行性#递归写法的不可行性":"","递归写法的问题#递归写法的问题":"做了很多重复计算，效率低下 如何避免？ DP：将计算结果保存下来，并改变计算顺序","题目分析#题目分析":"最后一步一定是从左边(i, j - 1)或上边(i - 1, j)过来 状态f[i][j]表示从左上角有多少种方式走到格子(i, j) 坐标型动态规划：数组下标[i][j]即坐标(i, j) 开的数组不需要加1 f[i][j] = f[i - 1][j] + f[i][j - 1]","题目分析-1#题目分析":"对于每个数0 \u003c= i \u003c= N，直接求i的二进制表示里有多少个1 二进制表示算法：（十进制转二进制算法） 第一步：i mod 2是最低位的bit 第二步：i \u003c- floor(i / 2)，如果i = 0，结束，否则回到第一步 时间复杂度：O(NlogN) 2个数有1位二进制(0 and 1) 2个数有2位二进制(2 and 3) 4个数有3位二进制(3, 4, 5 and 6) 8个数有4位二进制(7, 8, 9, 10, 11, 12, 13 and 14) … 大约N / 2个数有log{2}N位二进制 用动态规划的话会比上面快一些","题目分析-2#题目分析":"买卖任意多次 最优策略是如果今天的价格比明天的价格低，就今天买，明天卖（贪心） 凡事我们自己想出来的贪心算法都需要证明一下： 所有的贪心的证明都是：假设最优策略不是这样，可以改成这样，且不会更差 正确性证明可以从这里下手： 如果最优策略第10天买，第15天卖，我们可以把它分解成5天(即改成这样)，结果不会变差","题目分析-3#题目分析":"题目大意和 I, II 基本相似 只能最多两次买卖 所以需要记录已经买卖了多少次","题目分析-4#题目分析":"首先，如果 K 很大，K \u003e N / 2，则题目可以化简成为Best Time to Buy and Sell Stock II, 每天买入当且仅当价格比下一天低 Best Time to Buy and Sell Stock III 相当于这题中K = 2 所以我们可以借鉴之前的解法","题目分析-5#题目分析":"如果一个抄写员抄写第i本到第j本书，则需要时间A[i] + A[i + 1] + ... + A[j] 最后完成时间取决于耗时最长的那个抄写员 需要找到一种分段方式，分成不超过K段，使得所有段的数字之和的最大值最小","题目分析-6#题目分析":"和BackpackV唯一区别：组合中数字可以按不同的顺序，比如1 + 1 + 2与1 + 2 + 1算两种组合 不能先处理第一个物品，再处理第二个物品 似乎是更难的背包问题 其实更简单","题目分析-7#题目分析":"公共子序列一定是对应的字符按顺序都相等 找到最长的对应对子，且对子连线不能相交"},"title":"Dynamic Programming"},"/blog/note_recursion/":{"data":{"":"Covered all topics of Recursion\nChapter 1: 参数传递和递归 Chapter 2: 单向递归–递归vs循环 二阶阶乘 普通递归 普通递归 –\u003e 尾递归 尾递归 –\u003e 迭代 颠倒二进制位 普通递归 普通递归 –\u003e 尾递归 尾递归 –\u003e 迭代 Exercise: 寻找最大值 普通递归 普通递归 –\u003e 尾递归 尾递归 –\u003e 迭代 Chapter 3: 单向递归–递归的妙用 两两交换链表中的节点 递归的方式 迭代的方式 经典二分查找问题 普通写法的递归方式: Time Limit Exceeded 二分查找的递归方式 快速幂 普通写法的递归方式: 递归求解a^n 递归求解(a^n) % b: Fail 快速幂的递归方式: Pass 快速幂的迭代形式: Pass Exercise: 14. 二分查找 classic method recursion method recursion method version 2 Exercise: 458. 目标最后位置 classic method recursion method recursion method version 2 In summary: Chapter 4: 双向递归–二叉树的遍历与递归树 二叉树的深度优先遍历 递归，二叉树的遍历： 斐波那契数列 memorization of fibonacci 汉诺塔 Exercise: 1300. 巴什博弈 memorization optimization 递归的核心思想：由大化小：Best Solution In summary Chapter 5: 双向递归–二叉树的分治 分治法 vs 递归 适合分治法的数据结构 二叉树上分治模版(template of Divide and Conquer for Binary Tree) 二叉树的最大深度 最大二叉树 通过遍历序确定二叉树(important) 前序遍历和中序遍历树构造二叉树 中序遍历和后序遍历树构造二叉树 前序遍历和后序遍历树构造二叉树 Chapter 6: 多向递归–组合类问题 子集 1. 二叉树遍历解法 2. 组合数解法 子集II: ???? 1. 二叉树遍历解法 2. 组合数解法 数字组合 1. 二叉树遍历解法 2. 组合数解法 Exercise: 1208. 目标和 1. Solution Wrong answer: counter will always be 0 Approach 1.1 for python: Time Limit Exceeded Approach 1.2 for python: Time Limit Exceeded Approach 1.3 for python: Time Limit Exceeded 2. 组合数解法 Chapter 7: 多向递归–排列类问题 全排列 排列问题递归树 带重复元素的排列 如何从全排列问题转化过来 第k个排列 求解第k个排列 求解一个排列是第几个排列 下一个排列（非递归） Exercise: 990. 美丽排列 Chapter 8: 非递归–二叉树类 递归改非递归 用栈实现二叉树非递归遍历 前序遍历 中序遍历 后序遍历 用Morris算法实现二叉树非递归遍历 前序遍历 中序遍历 后序遍历 先右子树再左子树的前序遍历 VS 后序遍历 如何通过Morris解决后序遍历：先将问题转化成异样的前序遍历，然后再翻转Morris的结果 两种解法对比 Exercise: 169. 汉诺塔 Chapter 9: 非递归–排列组合类 组合类问题非递归（三种解法） 二叉树遍历解法 组合数思路解法 二进制枚举解法 排列类问题非递归 用手写栈模拟递归解法 下一个排列解法","1-solution#1. Solution":"递归的定义 // 全子集的二叉树解法 helper(nums, start, combinations, combination) start –\u003e now_index combinations –\u003e counter // counter 储存最终找到的方案数量 combination –\u003e now_sum // combination 记录当前所选取的这些方案。 对于当前问题我们不关心+1-2…， 我们只关心他们最终的和, 不关心是怎么得出这个和的 // s 用于比较 now_sum // 当前问题\nhelper(nums, now_index, now_sum, s, counter) 递归的拆解 // 全子集的二叉树解法 选取第 start 个数 不选第 start 个数 // 当前问题\n第 now_index 个数前面放 ‘+’ 第 now_index 个数前面放 ‘-’ 递归的出口 // 全子集的二叉树解法 start 越出 nums 范围的时候 // 当前问题\nnow_index 越出 nums 范围的时候","1-二叉树遍历解法#1. 二叉树遍历解法":"类似于单向递归\n递归的定义 helper(nums, start, end, combinations, combination) ==\u003e 由于end在递归调用中没有发生变化，所以可以抹掉end helper(nums, start, combinations, combination) 递归的拆解 选取第start个数 不选第start个数 递归的出口 start~end区间为空的时候 =\u003e start越出nums范围的时候 class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsets(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int start, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination) { if (start == nums.size()) { combinations.push_back(combination); // push_back make a copy of the argument and stores it in the vector return; // let return void } combination.push_back(nums[start]); Helper(nums, start + 1, combinations, combination); combination.pop_back(); Helper(nums, start + 1, combinations, combination); } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u003e List[List[int]]: combinations = list() nums.sort() # required in this question self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() if start == len(nums): # ==, not \u003e combinations.append(list(combination)) # deep copy by list(...) return combination.append(nums[start]) self.helper(nums, start + 1, combinations, combination) combination.pop() self.helper(nums, start + 1, combinations, combination)","1-二叉树遍历解法-1#1. 二叉树遍历解法":"递归的定义 helper(nums, start, combinations, combination, refuse) refuse 表示前面相同的数字是否都拿走了，如果有一个没拿走，我就不能拿当前这个数 递归的拆解 选取第start个数 不选第start个数 递归的出口 start越出nums范围的时候 class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsetsWithDup(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination, false); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int start, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination, bool refuse) { if (start == nums.size()) { combinations.push_back(combination); return; } Helper(nums, start + 1, combinations, combination, true); if (refuse \u0026\u0026 nums[start] == nums[start - 1]) { return; } combination.push_back(nums[start]); Helper(nums, start + 1, combinations, combination, false); combination.pop_back(); } }; from typing import ( List, ) class Solution: def subsets_with_dup(self, nums: List[int]) -\u003e List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None, False) return combinations def helper(self, nums, start, combinations, combination, refuse): if combination == None: combination = list() if start == len(nums): combinations.append(list(combination)) return self.helper(nums, start + 1, combinations, combination, True) if refuse and nums[start] == nums[start - 1]: return combination.append(nums[start]) self.helper(nums, start + 1, combinations, combination, False) combination.pop()","1-二叉树遍历解法-2#1. 二叉树遍历解法":"递归的定义 helper(nums, now, combinations, combination) 递归的拆解 选取第now个数 选取某个数之后，还能再选这个数 不选第now个数 不选某个数之后，就不能再选这个数 递归的出口 选取的数的和 到达target的时候 now越过nums范围的时候 class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e combinationSum(std::vector\u003cint\u003e\u0026 candidates, int target) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; // remove duplicates and sort std::set\u003cint\u003e candidates_set{candidates.begin(), candidates.end()}; candidates = {candidates_set.begin(), candidates_set.end()}; Helper(candidates, 0, combinations, combination, target); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int now, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination, int target) { if (target \u003c= 0) { if (target == 0) { combinations.push_back(combination); } return; } if (now \u003e= nums.size()) { return; } combination.push_back(nums[now]); Helper(nums, now, combinations, combination, target - nums[now]); combination.pop_back(); Helper(nums, now + 1, combinations, combination, target); } }; from typing import ( List, ) class Solution: def combination_sum(self, candidates: List[int], target: int) -\u003e List[List[int]]: combinations = list() candidates = sorted(set(candidates)) self._helper(candidates, 0, combinations, None, target) return combinations def _helper(self, nums, now, combinations, combination, target): if combination is None: combination = list() if target \u003c= 0: if target == 0: combinations.append(list(combination)) # copy value return if now \u003e= len(nums): return combination.append(nums[now]) self._helper(nums, now, combinations, combination, target - nums[now]) combination.pop() self._helper(nums, now + 1, combinations, combination, target)","2-组合数解法#2. 组合数解法":"优化: 铲除多余节点 和之前写的递归套路不太一样\n状态的转移放在了for循环里 递归的隐式出口 class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsets(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int start, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination) { // 树上没有重复的节点，每一个节点都是需要的子集 combinations.push_back(combination); // 从start开始往后找 for (int i = start; i \u003c nums.size(); ++i) { combination.push_back(nums[i]); Helper(nums, i + 1, combinations, combination); combination.pop_back(); } } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u003e List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() # 树上没有重复的节点，每一个节点都是需要的子集 combinations.append(list(combination)) # 从start开始往后找 for i in range(start, len(nums)): combination.append(nums[i]) self.helper(nums, i + 1, combinations, combination) combination.pop()","2-组合数解法-1#2. 组合数解法":"// Mine version class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsetsWithDup(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int start, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination) { // 去重 if (std::find(combinations.begin(), combinations.end(), combination) == combinations.end()) { combinations.push_back(combination); } for (int i = start; i \u003c nums.size(); ++i) { combination.push_back(nums[i]); Helper(nums, i + 1, combinations, combination); combination.pop_back(); } } }; // Official version class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsetsWithDup(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); Helper(nums, 0, combinations, combination); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int start, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination) { combinations.push_back(combination); for (int i = start; i \u003c nums.size(); ++i) { if (i != start \u0026\u0026 nums[i] == nums[i - 1]) { continue; } combination.push_back(nums[i]); Helper(nums, i + 1, combinations, combination); combination.pop_back(); } } }; # Mine version from typing import ( List, ) class Solution: def subsetsWithDup(self, nums: List[int]) -\u003e List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() # 去重 if combination not in combinations: combinations.append(list(combination)) for i in range(start, len(nums)): combination.append(nums[i]) self.helper(nums, i + 1, combinations, combination) combination.pop() # Official version from typing import ( List, ) class Solution: def subsetsWithDup(self, nums: List[int]) -\u003e List[List[int]]: combinations = list() nums.sort() self.helper(nums, 0, combinations, None) return combinations def helper(self, nums, start, combinations, combination): if combination == None: combination = list() combinations.append(list(combination)) for i in range(start, len(nums)): if i != start and nums[i] == nums[i - 1]: continue combination.append(nums[i]) self.helper(nums, i + 1, combinations, combination) combination.pop()","2-组合数解法-2#2. 组合数解法":"递归的定义 helper(nums, start, combinations, combination) 递归的拆解 选取第start个数 选取某个数之后，还能再选这个数 不选第start个数 不选某个数之后，就不能再选这个数 递归的出口 选取的数的和 到达target的时候 start越过nums范围的时候 class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e combinationSum(std::vector\u003cint\u003e\u0026 candidates, int target) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::set\u003cint\u003e candidates_set{candidates.begin(), candidates.end()}; candidates = {candidates_set.begin(), candidates_set.end()}; Helper(candidates, 0, combinations, combination, target); return combinations; } private: void Helper(std::vector\u003cint\u003e\u0026 nums, int now, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 combinations, std::vector\u003cint\u003e\u0026 combination, int target) { if (target == 0) { // target == 0 instead of target - nums[start] == 0 combinations.push_back(combination); return; } for (int i = now; i \u003c nums.size(); ++i) { if (target - nums[i] \u003e= 0) { // needed combination.push_back(nums[i]); Helper(nums, i, combinations, combination, target - nums[i]); // i instead of i + 1 combination.pop_back(); } } } }; from typing import ( List, ) class Solution: def combination_sum(self, candidates: List[int], target: int) -\u003e List[List[int]]: combinations = list() candidates = sorted(set(candidates)) self._helper(candidates, 0, combinations, None, target) return combinations def _helper(self, nums, start, combinations, combination, target): if combination is None: combination = list() if target == 0: combinations.append(list(combination)) return for i in range(start, len(nums)): if (target - nums[i] \u003e= 0): combination.append(nums[i]) self._helper(nums, i, combinations, combination, target - nums[i]) combination.pop()","2-组合数解法-3#2. 组合数解法":"递归的定义 helper(nums, start_index, now_sum, s) 递归的拆解 在 start_index 后面的位置中选择一个 将其符号修改成 ‘+’ 并进入递归下一层 递归的出口 start_index 越出 nums 范围的时候 // Accepted #include // include numeric for std::accumulate class Solution { public: int findTargetSumWays(std::vector\u003cint\u003e\u0026 nums, int s) { int now_sum = -std::accumulate(nums.begin(), nums.end(), 0); return helper(nums, 0, now_sum, s); } private: int helper(std::vector\u003cint\u003e\u0026 nums, int start_index, int now_sum, int s) { int counter = now_sum == s ? 1 : 0; for (int i = start_index; i \u003c nums.size(); ++i) { now_sum += 2 * nums[i]; counter += helper(nums, i + 1, now_sum, s); now_sum -= 2 * nums[i]; } return counter; } }; # Time limit exceeded from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u003e int: now_sum = -sum(nums) return self.helper(nums, 0, now_sum, s) def helper(self, nums, start_index, now_sum, s): counter = 1 if now_sum == s else 0 for i in range(start_index, len(nums)): now_sum += 2 * nums[i] counter += self.helper(nums, i + 1, now_sum, s) now_sum -= 2 * nums[i] return counter","approach-11-for-python-time-limit-exceeded#Approach 1.1 for python: Time Limit Exceeded":"from typing import ( List, ) class Result: def __init__(self, val): self.val = val class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u003e int: # counter = 0 counter = Result(0) self.helper(nums, 0, 0, s, counter) # return counter return counter.val def helper(self, nums, now_index, now_sum, s, counter): if now_index == len(nums): # counter += 1 if now_sum == s else 0 counter.val += 1 if now_sum == s else 0 return now_sum += nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum -= nums[now_index] now_sum -= nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum += nums[now_index]","approach-12-for-python-time-limit-exceeded#Approach 1.2 for python: Time Limit Exceeded":"from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u003e int: # counter = 0 counter = [0] self.helper(nums, 0, 0, s, counter) # return counter return counter[0] def helper(self, nums, now_index, now_sum, s, counter): if now_index == len(nums): # counter += 1 if now_sum == s else 0 counter[0] += 1 if now_sum == s else 0 return now_sum += nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum -= nums[now_index] now_sum -= nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum += nums[now_index]","approach-13-for-python-time-limit-exceeded#Approach 1.3 for python: Time Limit Exceeded":"from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u003e int: # counter = 0 # self.helper(nums, 0, 0, s, counter) # return counter return self.helper(nums, 0, 0, s) # def helper(self, nums, now_index, now_sum, s, counter): def helper(self, nums, now_index, now_sum, s): if now_index == len(nums): # counter += 1 if now_sum == s else 0 return 1 if now_sum == s else 0 counter = 0 now_sum += nums[now_index] # self.helper(nums, now_index + 1, now_sum, s, counter) counter += self.helper(nums, now_index + 1, now_sum, s) now_sum -= nums[now_index] now_sum -= nums[now_index] # self.helper(nums, now_index + 1, now_sum, s, counter) counter += self.helper(nums, now_index + 1, now_sum, s) now_sum += nums[now_index] return counter","chapter-1-参数传递和递归#Chapter 1: 参数传递和递归":"栈空间一般用于存放对象的引用，值类型变量和函数调用信息，堆空间才是用于存放对象本身的\n. and [] 修改的是对象本身，不是引用\n递归的三要素：Recursion\n递归的定义（代表什么含义，接受什么参数，返回什么值） 递归的拆解（把大问题拆成小问题) 递归的出口（到什么时候结束） # 1. 递归的定义 def print_n(n): # 3. 递归的出口 if n \u003c 1: return # 2. 递归的拆解 print_n(n - 1) print(n) 时间复杂度： 迭代O(n), 递归O(n)\n空间复杂度： 迭代O(1), 递归O(n)\n内存中的堆和栈：\n堆空间： - 存放new得到的对象\n- 无限制（剩余内存的大小） 栈空间： - 存放对象的引用\n- 值类型变量\n- C++函数中的数组\n- 有限制，一般很小，MB量级\n- 函数调用栈 递归需谨慎：\n递归调用容易爆栈 人为调用栈不会爆栈 除非C/C++的函数中定义大数组——危险行为 import sys limit = sys.getrecursionlimit() sys.setrecursionlimit(...)","chapter-2-单向递归递归vs循环#Chapter 2: 单向递归\u0026ndash;递归vs循环":"","chapter-3-单向递归递归的妙用#Chapter 3: 单向递归\u0026ndash;递归的妙用":"","chapter-4-双向递归二叉树的遍历与递归树#Chapter 4: 双向递归\u0026ndash;二叉树的遍历与递归树":"","chapter-5-双向递归二叉树的分治#Chapter 5: 双向递归\u0026ndash;二叉树的分治":"","chapter-6-多向递归组合类问题#Chapter 6: 多向递归\u0026ndash;组合类问题":"","chapter-7-多向递归排列类问题#Chapter 7: 多向递归\u0026ndash;排列类问题":"","chapter-8-非递归二叉树类#Chapter 8: 非递归\u0026ndash;二叉树类":"","chapter-9-非递归排列组合类#Chapter 9: 非递归\u0026ndash;排列组合类":"","classic-method#classic method":"class Solution { public: int binarySearch(std::vector\u003cint\u003e\u0026 nums, int target) { if (nums.size() == 0) { return -1; } int left = 0; int right = nums.size() - 1; while (left + 1 \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e target) { right = mid; } else if (nums[mid] \u003c target) { left = mid; } else { right = mid; } } if (nums[left] == target) { return left; } if (nums[right] == target) { return right; } return -1; } };","classic-method-1#classic method":"class Solution { public: int lastPosition(std::vector\u003cint\u003e\u0026 nums, int target) { if (nums.size() == 0) { return -1; } int left = 0; int right = nums.size() - 1; while (left + 1 \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e target) { right = mid; } else if (nums[mid] \u003c target) { left = mid; } else { left = mid; } } if (nums[right] == target) { return right; } else if (nums[left] == target) { return left; } return -1; } };","exercise-1208-目标和#Exercise: 1208. 目标和":"Lintcode 1208","exercise-1300-巴什博弈#Exercise: 1300. 巴什博弈":"Lintcode 1300 递归的定义 canWinBash(n) 有n个石子，先手拿能否获胜 递归的拆解 canWinBash(n - 1) ==\u003e 拿走1个 canWinBash(n - 2) ==\u003e 拿走2个 canWinBash(n - 3) ==\u003e 拿走3个 递归的出口 n \u003c= 3 // Time Limit Exceeded class Solution { public: bool canWinBash(int n) { if (n \u003c= 3) { return true; } return !canWinBash(n - 1) || !canWinBash(n - 2) || !canWinBash(n - 3); } }; # Time Limit Exceeded class Solution: def can_win_bash(self, n: int) -\u003e bool: if n \u003c= 3: return True; return not self.can_win_bash(n - 1) \\ or not self.can_win_bash(n - 2) \\ or not self.can_win_bash(n - 3)","exercise-14-二分查找#Exercise: 14. 二分查找":"Lintcode 14","exercise-169-汉诺塔#Exercise: 169. 汉诺塔":"Lintcode 169 #include struct Node { Node(int n, char start, char end, char temp) : n(n), start(start), end(end), temp(temp) {} Node* get_left() { // int n = this-\u003en - 1; // char start = this-\u003estart; // char end = this-\u003etemp; // char temp = this-\u003eend; // return new Node(n, start, end, temp); return new Node(n - 1, start, temp, end); } Node* get_right() { // int n = this-\u003en - 1; // char start = this-\u003etemp; // char end = this-\u003eend; // char temp = this-\u003estart; // return new Node(n, start, end, temp); return new Node(n - 1, temp, end, start); } std::string move() { // return std::string(\"from \") + this-\u003estart + \" to \" + this-\u003eend; return std::string(\"from \") + start + \" to \" + end; } int n; char start, end, temp; }; struct State { State(Node* node, int count) : node(node), count(count) {} Node* node; int count; }; class Solution { public: std::vector\u003cstd::string\u003e towerOfHanoi(int n) { std::deque\u003cState*\u003e stack; stack.push_back(new State(new Node(n, 'A', 'C', 'B'), 0)); std::vector\u003cstd::string\u003e moves; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); Node* node = now-\u003enode; int count = now-\u003ecount; if (node-\u003en == 0) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); // can be ignore stack.push_back(new State(node-\u003eget_right(), 0)); stack.push_back(new State(node, 2)); stack.push_back(new State(node-\u003eget_left(), 0)); stack.push_back(new State(node, 1)); // can be ignore } if (count == 2) { moves.push_back(node-\u003emove()); } } return moves; } }; from typing import ( List, ) class Node: def __init__(self, n, start, end, temp): self.n = n self.start = start self.end = end self.temp = temp def get_left(self): n = self.n - 1 start = self.start end = self.temp temp = self.end return Node(n, start, end, temp) def get_right(self): n = self.n - 1 start = self.temp end = self.end temp = self.start return Node(n, start, end, temp) def move(self): return \"from \" + self.start + \" to \" + self.end class Solution: def tower_of_hanoi(self, n: int) -\u003e List[str]: stack = [(Node(n, 'A', 'C', 'B'), 0)] moves = [] while stack: node, count = stack.pop() if node.n == 0: continue if count == 0: stack.append((node, 3)) # can be ignore stack.append((node.get_right(), 0)) stack.append((node, 2)) stack.append((node.get_left(), 0)) stack.append((node, 1)) # can be ignore if count == 2: moves.append(node.move()) return moves","exercise-458-目标最后位置#Exercise: 458. 目标最后位置":"Lintcode 458","exercise-990-美丽排列#Exercise: 990. 美丽排列":"Lintcode 990 递归的定义\nhelper(n, visited, counter) 不需要知道具体排列 把返回值用上可以省略 counter 递归的拆解\n选一个还未选择的且能放到第i位的数 递归的出口\n所有数都被选中的时候 class Solution { public: int countArrangement(int N) { std::unordered_set\u003cint\u003e visited; return helper(N, visited); } private: int helper(int n, std::unordered_set\u003cint\u003e\u0026 visited) { if (visited.size() == n) { return 1; } int counter = 0; for (int num = 1; num \u003c= n; ++num) { if (visited.find(num) != visited.end()) { continue; } // (visited.size() + 1) 代表`i` if (num % (visited.size() + 1) != 0 \u0026\u0026 (visited.size() + 1) % num != 0) { continue; } visited.insert(num); counter += helper(n, visited); visited.erase(num); } return counter; } }; class Solution: def count_arrangement(self, n: int) -\u003e int: return self.helper(n, None) def helper(self, n, visited): if visited is None: visited = set() if len(visited) == n: return 1 counter = 0 for num in range(1, n + 1): if num in visited: continue # (visited.size() + 1) 代表`i` if num % (len(visited) + 1) and (len(visited) + 1) % num: continue visited.add(num) counter += self.helper(n, visited) visited.remove(num) return counter","exercise-寻找最大值#Exercise: 寻找最大值":"Lintcode 297","in-summary#In summary:":"两两交换链表中的节点\n递归比迭代更加好想，好写，不易出bug 但是递归有可能发生爆栈 经典二分查找问题 和 快速幂问题\n和递归的核心思想由大化小完美贴合的两个算法 换种递归拆分的方法会让时间复杂度和栈深度降低很多 由于每次砍掉一半，递归深度不会太深，没有爆栈风险","in-summary-1#In summary":"斐波那契数列\n有递归式的数列可以直接根据递归式写递归 递归树(后序遍历) 汉诺塔\n递归的时候只考虑当前层，否则参数多转移多的递归会很乱 递归树(中序遍历)","memorization-of-fibonacci#memorization of fibonacci":"class Solution { public: int fibonacci(int n) { std::unordered_map\u003cint, int\u003e memo; return fibonacci(n, memo); } private: int fibonacci(int n, std::unordered_map\u003cint, int\u003e\u0026 memo) { if (memo.find(n) != memo.end()) { return memo[n]; } if (n \u003c= 2) { return n - 1; } int result = fibonacci(n - 1, memo) + fibonacci(n - 2, memo); memo[n] = result; return result; } }; class Solution: def fibonacci(self, n: int, memo = None) -\u003e int: if memo is None: memo = dict() if n in memo: return memo[n] if n \u003c= 2: return n - 1 result = self.fibonacci(n - 1, memo) + self.fibonacci(n - 2, memo) memo[n] = result return result","memorization-optimization#memorization optimization":"// Time Limit Exceeded class Solution { public: bool canWinBash(int n) { std::unordered_map\u003cint, bool\u003e memo; bool result = canWinBash(n, memo); return result; } private: bool canWinBash(int n, std::unordered_map\u003cint, bool\u003e\u0026 memo) { if (memo.find(n) != memo.end()) { return memo[n]; } if (n \u003c= 3) { return true; } bool temp = !canWinBash(n - 1) || !canWinBash(n - 2) || !canWinBash(n - 3); memo[n] = temp; return temp; } };","recursion-method#recursion method":"class Solution { public: int binarySearch(std::vector\u003cint\u003e\u0026 nums, int target) { return binarySearch(nums, target, 0, nums.size() - 1); } private: int binarySearch(std::vector\u003cint\u003e\u0026 nums, int target, int start, int end) { if (start \u003e end) { return -1; } // optional base case if (nums[start] == target) { return start; } int mid = start + (end - start) / 2; if (nums[mid] \u003e target) { return binarySearch(nums, target, start, mid - 1); } else if (nums[mid] \u003c target) { return binarySearch(nums, target, mid + 1, end); } else { if (mid - 1 \u003e= 0 \u0026\u0026 nums[mid - 1] == nums[mid]) { return binarySearch(nums, target, start, mid - 1); } else { return mid; } } } }; class Solution: def binarySearch(self, nums, target): return self._binary_search_helper(nums, target, 0, len(nums) - 1) def _binary_search_helper(self, nums, target, start, end): if start \u003e end: return -1 mid = (start + end) // 2 if nums[mid] \u003c target: # return keyword is required return self._binary_search_helper(nums, target, mid + 1, end) elif nums[mid] \u003e target: # return keyword is required return self._binary_search_helper(nums, target, start, mid - 1) else: if mid - 1 \u003e= 0 and nums[mid - 1] == nums[mid]: return self._binary_search_helper(nums, target, start, mid - 1) else: return mid","recursion-method-1#recursion method":"class Solution { public: int lastPosition(std::vector\u003cint\u003e\u0026 nums, int target) { return lastPosition(nums, target, 0, nums.size() - 1); } int lastPosition(std::vector\u003cint\u003e\u0026 nums, int target, int left, int right) { if (left \u003e right) { return -1; } if (nums[right] == target) { return right; } int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { return lastPosition(nums, target, mid + 1, right); } else if (nums[mid] \u003e target) { return lastPosition(nums, target, left, mid - 1); } else { if (mid + 1 \u003c= nums.size() - 1 \u0026\u0026 nums[mid + 1] == nums[mid]) { return lastPosition(nums, target, mid + 1, right); } else { return mid; } } } }; from typing import ( List, ) class Solution: def last_position(self, nums: List[int], target: int) -\u003e int: return self._last_position_helper(nums, target, 0, len(nums) - 1) def _last_position_helper(self, nums, target, left, right): if left \u003e right: return -1 if nums[right] == target: return right mid = (left + right) // 2 if nums[mid] \u003c target: return self._last_position_helper(nums, target, mid + 1, right) elif nums[mid] \u003e target: return self._last_position_helper(nums, target, left, mid - 1) else: if mid + 1 \u003c len(nums) - 1 and nums[mid + 1] == nums[mid]: return self._last_position_helper(nums, target, mid + 1, right) else: return mid","recursion-method-version-2#recursion method version 2":"class Solution { public: int binarySearch(std::vector\u003cint\u003e\u0026 nums, int target) { return binarySearch(nums, target, 0, nums.size() - 1); } int binarySearch(std::vector\u003cint\u003e\u0026 nums, int target, int left, int right) { if (left \u003e right) { return -1; } int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { return binarySearch(nums, target, mid + 1, right); } if (nums[mid] \u003e target) { return binarySearch(nums, target, left, mid - 1); } int temp = binarySearch(nums, target, left, mid - 1); if (temp != -1) { return temp; } return mid; } };","recursion-method-version-2-1#recursion method version 2":"class Solution { public: int lastPosition(std::vector\u003cint\u003e\u0026 nums, int target) { return lastPosition(nums, target, 0, nums.size() - 1); } int lastPosition(std::vector\u003cint\u003e\u0026 nums, int target, int left, int right) { if (left \u003e right) { return -1; } int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { return lastPosition(nums, target, mid + 1, right); } if (nums[mid] \u003e target) { return lastPosition(nums, target, left, mid - 1); } int temp = lastPosition(nums, target, mid + 1, right); if (temp != -1) { return temp; } return mid; } };","wrong-answer-counter-will-always-be-0#Wrong answer: counter will always be 0":"class Solution { public: int findTargetSumWays(std::vector\u003cint\u003e\u0026 nums, int s) { int counter = 0; helper(nums, 0, 0, s, counter); return counter; } private: void helper(std::vector\u003cint\u003e\u0026 nums, int now_index, int now_sum, int s, int counter) { // void helper(std::vector\u0026 nums, int now_index, int now_sum, int s, int\u0026 counter) { // corrected if (now_index == nums.size()) { counter += now_sum == s ? 1 : 0; return; } now_sum += nums[now_index]; helper(nums, now_index + 1, now_sum, s, counter); now_sum -= nums[now_index]; now_sum -= nums[now_index]; helper(nums, now_index + 1, now_sum, s, counter); now_sum += nums[now_index]; } }; from typing import ( List, ) class Solution: def find_target_sum_ways(self, nums: List[int], s: int) -\u003e int: counter = 0 self.helper(nums, 0, 0, s, counter) return counter def helper(self, nums, now_index, now_sum, s, counter): if now_index == len(nums): counter += 1 if now_sum == s else 0 return now_sum += nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum -= nums[now_index] now_sum -= nums[now_index] self.helper(nums, now_index + 1, now_sum, s, counter) now_sum += nums[now_index]","下一个排列解法#下一个排列解法":"参考：下一个排列（非递归） class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e permute(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e permutations; std::sort(nums.begin(), nums.end()); // only for corner case where nums is [] if (nums.empty()) { std::vector\u003cint\u003e permutation; permutations.push_back(permutation); } while (!nums.empty()) { std::vector\u003cint\u003e permutation; for (int i = 0; i \u003c nums.size(); ++i) { permutation.push_back(nums[i]); } permutations.push_back(permutation); nums = NextPermutation(nums); } return permutations; } private: std::vector\u003cint\u003e NextPermutation(std::vector\u003cint\u003e\u0026 nums) { int index = -1; for (int i = nums.size() - 2; i \u003e= 0; --i) { if (nums[i] \u003c nums[i + 1]) { index = i; break; } } if (index == -1) { // Reverse(nums, 0, nums.size() - 1); // return nums; return {}; } int last_bigger = index + 1; for (int i = nums.size() - 1; i \u003e index; --i) { if (nums[i] \u003e nums[index]) { last_bigger = i; break; } } int temp = nums[index]; nums[index] = nums[last_bigger]; nums[last_bigger] = temp; Reverse(nums, index + 1, nums.size() - 1); return nums; } void Reverse(std::vector\u003cint\u003e\u0026 nums, int start, int end) { while (start \u003c end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; ++start; --end; } } }; from typing import ( List, ) class Solution: def permute(self, nums: List[int]) -\u003e List[List[int]]: permutations = list() nums = sorted(nums) while nums is not None: permutations.append(list(nums)) nums = self.next_permutation(nums) return permutations def next_permutation(self, nums: List[int]) -\u003e List[int]: index = -1 for i in range(len(nums) - 2, -1, -1): if nums[i] \u003c nums[i + 1]: index = i break else: # return nums[::-1] return None last_bigger = index + 1 for i in range(len(nums) - 1, index, -1): if nums[i] \u003e nums[index]: last_bigger = i break nums[index], nums[last_bigger] = nums[last_bigger], nums[index] return nums[: index + 1] + nums[len(nums) - 1 : index : -1] We can convert kth permutation problem as well.\n第k个排列是尾递归，可以转化成迭代的形式\nfor 1 .. n!: get kth permutation","下一个排列非递归#下一个排列（非递归）":"Lintcode 52 class Solution { public: std::vector\u003cint\u003e nextPermutation(std::vector\u003cint\u003e\u0026 nums) { int index = -1; // e.g. nums={3,2,5,4,1}, find index of 2 for (int i = nums.size() - 2; i \u003e= 0; --i) { if (nums[i] \u003c nums[i + 1]) { index = i; break; } } if (index == -1) { reverse(nums, 0, nums.size() - 1); return nums; } // set initial last_bigger is index of 5, and then find the smallest bigger number than 2 int last_bigger = index + 1; for (int i = nums.size() - 1; i \u003e index; --i) { if (nums[i] \u003e nums[index]) { last_bigger = i; break; } } // e.g. {3,2,5,4,1} --\u003e {3,4,5,2,1} int temp = nums[index]; nums[index] = nums[last_bigger]; nums[last_bigger] = temp; // e.g. {3,4,5,2,1} --\u003e {3,4,1,2,5} reverse(nums, index + 1, nums.size() - 1); return nums; } private: void reverse(std::vector\u003cint\u003e\u0026 nums, int start, int end) { while (start \u003c end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; ++start; --end; } } }; from typing import ( List, ) class Solution: def next_permutation(self, nums: List[int]) -\u003e List[int]: index = -1 for i in range(len(nums) - 2, -1, -1): if nums[i] \u003c nums[i + 1]: index = i break else: return nums[::-1] last_bigger = index + 1 for i in range(len(nums) - 1, index, -1): if nums[i] \u003e nums[index]: last_bigger = i break nums[index], nums[last_bigger] = nums[last_bigger], nums[index] return nums[: index + 1] + nums[len(nums) - 1 : index : -1]","两两交换链表中的节点#两两交换链表中的节点":"Lintcode 451","两种解法对比#两种解法对比":"用Morris实现的解法 时间复杂度：O(n) 空间复杂度：O(1) 对树结构的修改：是（之后有重新修改回去了） 用栈来实现的解法（递归与非递归都一样） 时间复杂度：O(n) 空间复杂度：O(n) 对树结构的修改：否","中序遍历#中序遍历":"Lintcode 67 #include struct State { State(TreeNode* node, int count) : node(node), count(count) {} TreeNode* node; int count; }; class Solution { public: std::vector\u003cint\u003e inorderTraversal(TreeNode* root) { std::deque\u003cState*\u003e stack; stack.push_back(new State(root, 0)); std::vector\u003cint\u003e values; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); TreeNode* node = now-\u003enode; int count = now-\u003ecount; if (node == nullptr) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); // can be ignore stack.push_back(new State(node-\u003eright, 0)); stack.push_back(new State(node, 2)); stack.push_back(new State(node-\u003eleft, 0)); stack.push_back(new State(node, 1)); // can be ignore } if (count == 2) { values.push_back(node-\u003eval); } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def inorder_traversal(self, root: TreeNode) -\u003e List[int]: stack = [(root, 0)] values = [] while stack: node, count = stack.pop() if node is None: continue if count == 0: stack.append((node, 3)) # can be ignore stack.append((node.right, 0)) stack.append((node, 2)) stack.append((node.left, 0)) stack.append((node, 1)) # can be ignore if count == 2: values.append(node.val) return values","中序遍历-1#中序遍历":"Lintcode 67 class Solution { public: std::vector\u003cint\u003e inorderTraversal(TreeNode* root) { std::vector\u003cint\u003e values; TreeNode* now = root; while (now != nullptr) { if (now-\u003eleft != nullptr) { TreeNode* temp = now-\u003eleft; while (temp-\u003eright != nullptr \u0026\u0026 temp-\u003eright != now) { temp = temp-\u003eright; // 一直找到temp 为中序遍历的前驱节点 } if (temp-\u003eright == now) { values.push_back(now-\u003eval); // the only difference against the preorder_traversal temp-\u003eright = nullptr; now = now-\u003eright; } else { temp-\u003eright = now; now = now-\u003eleft; } } else { values.push_back(now-\u003eval); now = now-\u003eright; } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def inorder_traversal(self, root: TreeNode) -\u003e List[int]: values = [] now = root while now: if now.left: temp = now.left while temp.right and temp.right != now: temp = temp.right if temp.right == now: values.append(now.val) # the only difference against the preorder_traversal temp.right = None now = now.right else: temp.right = now now = now.left else: values.append(now.val) now = now.right return values","中序遍历和后序遍历树构造二叉树#中序遍历和后序遍历树构造二叉树":"唯一\nLintcode 72 class Solution { public: TreeNode* buildTree(std::vector\u003cint\u003e\u0026 inorder, std::vector\u003cint\u003e\u0026 postorder) { return buildTree(postorder, 0, postorder.size() - 1, inorder, 0, inorder.size() - 1); } private: TreeNode* buildTree(std::vector\u003cint\u003e\u0026 postorder, int post_start, int post_end, std::vector\u003cint\u003e\u0026 inorder, int in_start, int in_end) { if (post_start \u003e post_end) { return nullptr; } if (in_start \u003e in_end) { return nullptr; } int position = FindPosition(inorder, postorder[post_end]); int left_len = position - in_start; int right_len = in_end - position; TreeNode* root = new TreeNode(postorder[post_end]); root-\u003eleft = buildTree(postorder, post_start, post_start + left_len - 1, inorder, in_start, position - 1); root-\u003eright = buildTree(postorder, post_end - right_len, post_end - 1, inorder, position + 1, in_end); return root; } int FindPosition(std::vector\u003cint\u003e\u0026 nums, int target) { for (int i = 0; i \u003c nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def build_tree(self, inorder: List[int], postorder: List[int]) -\u003e TreeNode: return self.build_tree_helper(postorder, 0, len(postorder) - 1, inorder, 0, len(inorder) - 1) def build_tree_helper(self, postorder, post_start, post_end, inorder, in_start, in_end): if post_start \u003e post_end: return None if in_start \u003e in_end: return None root = TreeNode(postorder[post_end]) position = inorder.index(postorder[post_end]) left_len = position - in_start right_len = in_end - position root.left = self.build_tree_helper(postorder, post_start, post_start + left_len - 1, inorder, in_start, position - 1) root.right = self.build_tree_helper(postorder, post_end - right_len, post_end - 1, inorder, position + 1, in_end) return root","二分查找的递归方式#二分查找的递归方式":"递归的定义 findPosition(nums, start, end, target) 在nums数组[start, end]区间上查找target 递归的拆解 找到start到end这个范围的中间值middle 如果middle这个位置小了 findPosition(nums, middle + 1, end, target) 如果middle这个位置大了 findPosition(nums, start, middle - 1, target) 递归的出口 start \u003e end; return -1 nums[middle] == target: return middle class Solution { public: int findPosition(std::vector\u003cint\u003e\u0026 nums, int target) { return findPosition(nums, 0, nums.size() - 1, target); } private: int findPosition(std::vector\u003cint\u003e\u0026 nums, int start, int end, int\u0026 target) { if (start \u003e end) { return -1; } int middle = start + (end - start) / 2; if (nums[middle] \u003c target) { findPosition(nums, middle + 1, end, target); } else if (nums[middle] \u003e target) { findPosition(nums, start, middle - 1, target); } else { return middle; } } }; class Solution: def findPosition(self, nums, target): return self.findPosition_helper(nums, 0, len(nums) - 1, target) def findPosition_helper(self, nums, start, end, target): if start \u003e end: return -1 middle = (start + end) // 2 if nums[middle] \u003c target: # keyword return is requried???? return self.findPosition_helper(nums, middle + 1, end, target) elif nums[middle] \u003e target: # keyword return is requried???? return self.findPosition_helper(nums, start, middle - 1, target) else: return middle python doesn’t support function overloading","二叉树上分治模版template-of-divide-and-conquer-for-binary-tree#二叉树上分治模版(template of Divide and Conquer for Binary Tree)":"class Solution { public: 返回结果类型 DivideConquer(TreeNode* root) { if (root == nullptr) { 处理空树应该返回的结果 } // if (root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr) { // 处理叶子应该返回的结果 // 如果叶子的返回结果可以通过两个空节点的返回结果得到 // 就可以省略这一段代码 // 一般可省略 // } 左子树的返回结果 = DivideConquer(root-\u003eleft) 右子树的返回结果 = DivideConquer(root-\u003eright) 整棵树的结果 = 按照一定方法合并左右子树的结果 } }; def devide_conquer(root): if root is None: 处理空树应该返回的结果 # if root.left is None and root.right is None: # 处理叶子应该返回的结果 # 如果叶子的返回结果可以通过两个空节点的返回结果得到 # 就可以省略这一段代码 # 一般可省略 左子树的返回结果 = self.divide_conquer(root.left) 右子树的返回结果 = self.divide_conquer(root.right) 整棵树的结果 = 按照一定方法合并左右子树的结果","二叉树的最大深度#二叉树的最大深度":"Lintcode 97 递归的定义 maxDepth(root) 以root为根的二叉树的最大深度是多少 递归的拆解 maxDepth(root.left) maxDepth(root.right) 递归的出口 root是一棵空树的根 class Solution { public: int maxDepth(TreeNode* root) { if (root == nullptr) { return 0; } return std::max(maxDepth(root-\u003eleft), maxDepth(root-\u003eright)) + 1; } }; from lintcode import ( TreeNode, ) class Solution: def max_depth(self, root: TreeNode) -\u003e int: if root is None: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1","二叉树的深度优先遍历#二叉树的深度优先遍历":"前序遍历(Preorder Traversal)\n根节点 -\u003e 左子树 -\u003e 右子树 Root -\u003e Left -\u003e Right 中序遍历\n左子树 -\u003e 根节点 -\u003e 右子树 Left -\u003e Root -\u003e Right 后序遍历\n左子树 -\u003e 右子树 -\u003e 根节点 Left -\u003e Right -\u003e Root","二叉树遍历解法#二叉树遍历解法":"1. 参考：二叉树遍历解法(递归) struct State { State(int node, int count) : node(node), count(count) {} int node, count; }; class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsets(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); std::deque\u003cState*\u003e stack; stack.push_back(new State(0, 0)); while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); int node = now-\u003enode; int count = now-\u003ecount; if (node == nums.size()) { combinations.push_back(combination); continue; } if (count == 0) { stack.push_back(new State(node, 3)); stack.push_back(new State(node + 1, 0)); stack.push_back(new State(node, 2)); stack.push_back(new State(node + 1, 0)); stack.push_back(new State(node, 1)); } if (count == 1) { combination.push_back(nums[node]); } if (count == 2) { combination.erase(combination.begin() + combination.size() - 1); } } return combinations; } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u003e List[List[int]]: combination = [] combinations = [] nums = sorted(nums) stack = [(0, 0)] while stack: node, count = stack.pop() if node == len(nums): combinations.append(list(combination)) continue if count == 0: stack.append((node, 3)) stack.append((node + 1, 0)) stack.append((node, 2)) stack.append((node + 1, 0)) stack.append((node, 1)) if count == 1: combination.append(nums[node]) if count == 2: combination.pop() return combinations","二进制枚举解法#二进制枚举解法":"Time complexity O(n * 2^n)\nclass Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsets(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i \u003c (1 \u003c\u003c n); ++i) { std::vector\u003cint\u003e combination; for (int j = 0; j \u003c n; ++j) { if ((i \u0026 (1 \u003c\u003c j)) != 0) { combination.push_back(nums[j]); } } combinations.push_back(combination); } return combinations; } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u003e List[List[int]]: combinations = [] nums = sorted(nums) n = len(nums) for i in range(0, (1 \u003c\u003c n)): combination = [] for j in range(n): if i \u0026 (1 \u003c\u003c j): combination.append(nums[j]) combinations.append(combination) return combinations","二阶阶乘#二阶阶乘":"Lintcode 771","先右子树再左子树的前序遍历-vs-后序遍历#先右子树再左子树的前序遍历 VS 后序遍历":"刚好是反着的关系\ndef helper(self, root, nodes): if root is None: return nodes.append(root.val) self.helper(root.right, nodes) self.helper(root.left, nodes) e.g. result = {2,1,5,4,3,7,6}\ndef helper(self, root, nodes): if root is None: return self.helper(root.left, nodes) self.helper(root.right, nodes) nodes.append(root.val) e.g. result = {6,7,3,4,5,1,2}","全排列#全排列":"Lintcode 15","分治法-vs-递归#分治法 vs 递归":"分治法：分治法 是一种 算法 递归：递归 是一种 程序设计方式","前序遍历#前序遍历":"Lintcode 66 #include struct State { State(TreeNode* node, int count) : node(node), count(count) {} TreeNode* node; int count; }; class Solution { public: std::vector\u003cint\u003e preorderTraversal(TreeNode* root) { std::deque\u003cState*\u003e stack; stack.push_back(new State(root, 0)); std::vector\u003cint\u003e values; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); TreeNode* node = now-\u003enode; int count = now-\u003ecount; if (node == nullptr) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); // can be ignore stack.push_back(new State(node-\u003eright, 0)); stack.push_back(new State(node, 2)); // can be ignore stack.push_back(new State(node-\u003eleft, 0)); stack.push_back(new State(node, 1)); } if (count == 1) { values.push_back(node-\u003eval); } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def preorder_traversal(self, root: TreeNode) -\u003e List[int]: stack = [(root, 0)] values = [] while stack: node, count = stack.pop() if node is None: continue if count == 0: stack.append((node, 3)) # can be ignore stack.append((node.right, 0)) stack.append((node, 2)) # can be ignore stack.append((node.left, 0)) stack.append((node, 1)) if count == 1: values.append(node.val) return values","前序遍历-1#前序遍历":"Lintcode 66 树上的节点最多只会被访问两次，而对于没有左孩子的节点只会访问一次（把两次访问合二为一）\ne.g. 2在中序遍历下的前驱节点是7; 1在中序遍历下的前驱节点是4\nclass Solution { public: std::vector\u003cint\u003e preorderTraversal(TreeNode* root) { std::vector\u003cint\u003e values; TreeNode* now = root; while (now != nullptr) { if (now-\u003eleft != nullptr) { TreeNode* temp = now-\u003eleft; while (temp-\u003eright != nullptr \u0026\u0026 temp-\u003eright != now) { temp = temp-\u003eright; // 一直找到temp 为中序遍历的前驱节点 } if (temp-\u003eright == now) { temp-\u003eright = nullptr; now = now-\u003eright; } else { values.push_back(now-\u003eval); temp-\u003eright = now; now = now-\u003eleft; } } else { values.push_back(now-\u003eval); now = now-\u003eright; } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def preorder_traversal(self, root: TreeNode) -\u003e List[int]: values = [] now = root while now: if now.left: temp = now.left while temp.right and temp.right != now: temp = temp.right if temp.right == now: temp.right = None now = now.right else: values.append(now.val) temp.right = now now = now.left else: values.append(now.val) now = now.right return values","前序遍历和中序遍历树构造二叉树#前序遍历和中序遍历树构造二叉树":"唯一\nLintcode 73 递归的定义 buildTree(preorder, pre_start, pre_end, inorder, in_start, in_end) 以preorder数组的pre_start~pre_end区间为前序遍历 以inorder数组的in_start~in_end区间为中序遍历 构建二叉树 递归的拆解 preorder[pre_start]: 前序遍历第一个访问到的节点必是根 inorder中preorder[pre_start]左边的部分是左子树，右边的部分是右子树 root.left = buildTree(preorder, pre_start + 1, pre_start + leftLen, inorder, in_start, position - 1) root.right = buildTree(preorder, pre_end - rightLen + 1, pre_end, inorder, position + 1, in_end) 递归的出口 preorder数组或inorder数组区间为空的时候 class Solution { public: TreeNode* buildTree(std::vector\u003cint\u003e\u0026 preorder, std::vector\u003cint\u003e\u0026 inorder) { return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); } private: TreeNode* buildTree(std::vector\u003cint\u003e\u0026 preorder, int pre_start, int pre_end, std::vector\u003cint\u003e\u0026 inorder, int in_start, int in_end) { if (pre_start \u003e pre_end) { return nullptr; } if (in_start \u003e in_end) { return nullptr; } TreeNode* root = new TreeNode(preorder[pre_start]); int position = FindPosition(inorder, preorder[pre_start]); int left_len = position - in_start; int right_len = in_end - position; root-\u003eleft = buildTree(preorder, pre_start + 1, pre_start + left_len, inorder, in_start, position - 1); root-\u003eright = buildTree(preorder, pre_end - right_len + 1, pre_end, inorder, position + 1, in_end); return root; } int FindPosition(std::vector\u003cint\u003e\u0026 nums, int target) { for (int i = 0; i \u003c nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def build_tree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: return self.build_tree_helper(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1) def build_tree_helper(self, preorder, pre_start, pre_end, inorder, in_start, in_end): if pre_start \u003e pre_end: return None if in_start \u003e in_end: return None root = TreeNode(preorder[pre_start]) position = inorder.index(preorder[pre_start]) left_len = position - in_start right_len = in_end - position root.left = self.build_tree_helper(preorder, pre_start + 1, pre_start + left_len, inorder, in_start, position - 1) root.right = self.build_tree_helper(preorder, pre_end - right_len + 1, pre_end, inorder, position + 1, in_end) return root","前序遍历和后序遍历树构造二叉树#前序遍历和后序遍历树构造二叉树":"不唯一\nLintcode 1593 递归的定义 buildTree(pre, preStart, preEnd, post, postStart, postEnd) 以pre数组的preStart ~ preEnd区间为前序遍历 以post数组的postStart ~ postEnd区间为后序遍历 构建二叉树 递归的拆解 pre[preStart]: 前序遍历第一个访问到的节点必是根 post中pre[preStart + 1]以及左边的部分是左子树，右边的部分是右子树 root.left = buildTree(pre, preStart + 1, preStart + leftLen, post, postStart, postStart + leftLen - 1) root.right = buildTree(pre, preEnd - rightLen + 1, preEnd, post, postEnd - rightLen, postEnd - 1) 递归的出口 pre数组或post数组区间为空的时候 class Solution { public: TreeNode* constructFromPrePost(std::vector\u003cint\u003e\u0026 pre, std::vector\u003cint\u003e\u0026 post) { return BuildTree(pre, 0, pre.size() - 1, post, 0, post.size() - 1); } private: TreeNode* BuildTree(std::vector\u003cint\u003e\u0026 pre, int pre_start, int pre_end, std::vector\u003cint\u003e\u0026 post, int post_start, int post_end) { if (pre_start \u003e pre_end) { return nullptr; } if (post_start \u003e post_end) { return nullptr; } // here is optional if (pre[pre_start] != post[post_end]) { return nullptr; } TreeNode* root = new TreeNode(pre[pre_start]); // here is required. 是递归出口。这里属于模版里面需要特殊处理的叶子节点。如果不处理叶子节点，后面pre_start + 1, 就会数组越界。如果不是叶子节点，就再处理后面的左子树和右子树。 if (pre_start == pre_end || post_start == post_end) { return root; } int position = FindPosition(post, pre[pre_start + 1]); int left_len = position - post_start + 1; int right_len = post_end - position - 1; // 将争议节点并入左子树 root-\u003eleft = BuildTree(pre, pre_start + 1, pre_start + left_len, post, post_start, post_start + left_len - 1); root-\u003eright = BuildTree(pre, pre_end - right_len + 1, pre_end, post, post_end - right_len, post_end - 1); return root; } int FindPosition(std::vector\u003cint\u003e\u0026 nums, int target) { for (int i = 0; i \u003c nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def construct_from_pre_post(self, pre: List[int], post: List[int]) -\u003e TreeNode: return self.build_tree(pre, 0, len(pre) - 1, post, 0, len(post) - 1) def build_tree(self, pre, pre_start, pre_end, post, post_start, post_end): if pre_start \u003e pre_end: return None if post_start \u003e post_end: return None if pre[pre_start] != post[post_end]: return None root = TreeNode(pre[pre_start]) # leaf node if pre_start == pre_end or post_start == post_end: return root position = post.index(pre[pre_start + 1]) left_len = position - post_start + 1 right_len = post_end - position - 1 root.left = self.build_tree(pre, pre_start + 1, pre_start + left_len, post, post_start, post_start + left_len - 1) root.right = self.build_tree(pre, pre_end - right_len + 1, pre_end, post, post_end - right_len, post_end - 1) return root","后序遍历#后序遍历":"Lintcode 68 #include struct State { State(TreeNode* node, int count) : node(node), count(count) {} TreeNode* node; int count; }; class Solution { public: std::vector\u003cint\u003e postorderTraversal(TreeNode* root) { std::deque\u003cState*\u003e stack; stack.push_back(new State(root, 0)); std::vector\u003cint\u003e values; while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); TreeNode* node = now-\u003enode; int count = now-\u003ecount; if (node == nullptr) { continue; } if (count == 0) { stack.push_back(new State(node, 3)); stack.push_back(new State(node-\u003eright, 0)); stack.push_back(new State(node, 2)); // can be ignore stack.push_back(new State(node-\u003eleft, 0)); stack.push_back(new State(node, 1)); // can be ignore } if (count == 3) { values.push_back(node-\u003eval); } } return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def postorder_traversal(self, root: TreeNode) -\u003e List[int]: stack = [(root, 0)] values = [] while stack: node, count = stack.pop() if node is None: continue if count == 0: stack.append((node, 3)) stack.append((node.right, 0)) stack.append((node, 2)) # can be ignore stack.append((node.left, 0)) stack.append((node, 1)) # can be ignore if count == 3: values.append(node.val) return values","后序遍历-1#后序遍历":"Lintcode 68","如何从全排列问题转化过来#如何从全排列问题转化过来":"class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e permuteUnique(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e permutations; std::sort(nums.begin(), nums.end()); // important std::vector\u003cint\u003e permutation; std::vector\u003cbool\u003e visited(nums.size(), false); helper(nums, permutations, permutation, visited); return permutations; } private: void helper(std::vector\u003cint\u003e\u0026 nums, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 permutations, std::vector\u003cint\u003e\u0026 permutation, std::vector\u003cbool\u003e\u0026 visited) { if (permutation.size() == nums.size()) { permutations.push_back(permutation); return; } for (int i = 0; i \u003c nums.size(); ++i) { if (visited[i]) { continue; } if (i - 1 \u003e= 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 !visited[i - 1]) { continue; } permutation.push_back(nums[i]); visited[i] = true; helper(nums, permutations, permutation, visited); permutation.pop_back(); visited[i] = false; } } }; from typing import ( List, ) class Solution: def permute_unique(self, nums: List[int]) -\u003e List[List[int]]: permutations = list() nums = sorted(nums) # sort self.helper(nums, permutations, None, None) return permutations def helper(self, nums, permutations, permutation, visited): if permutation is None: permutation = list() if visited is None: visited = [False] * len(nums) if len(permutation) == len(nums): permutations.append(list(permutation)) return # can be ignored for i in range(len(nums)): if visited[i]: continue if i - 1 \u003e= 0 and nums[i] == nums[i - 1] and not visited[i - 1]: continue permutation.append(nums[i]) visited[i] = True self.helper(nums, permutations, permutation, visited) permutation.pop() visited[i] = False","如何通过morris解决后序遍历先将问题转化成异样的前序遍历然后再翻转morris的结果#如何通过Morris解决后序遍历：先将问题转化成异样的前序遍历，然后再翻转Morris的结果":"class Solution { public: std::vector\u003cint\u003e postorderTraversal(TreeNode* root) { std::vector\u003cint\u003e values; TreeNode* now = root; while (now != nullptr) { if (now-\u003eright != nullptr) { TreeNode* temp = now-\u003eright; while (temp-\u003eleft != nullptr \u0026\u0026 temp-\u003eleft != now) { temp = temp-\u003eleft; } if (temp-\u003eleft == now) { temp-\u003eleft = nullptr; now = now-\u003eleft; } else { values.push_back(now-\u003eval); temp-\u003eleft = now; now = now-\u003eright; } } else { values.push_back(now-\u003eval); now = now-\u003eleft; } } std::reverse(values.begin(), values.end()); return values; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def postorder_traversal(self, root: TreeNode) -\u003e List[int]: values = list() now = root while now: if now.right: temp = now.right while temp.left and temp.left != now: temp = temp.left if temp.left == now: temp.left = None now = now.left else: values.append(now.val) temp.left = now now = now.right else: values.append(now.val) now = now.left values.reverse() return values","子集#子集":"Lintcode 17","子集ii-#子集II: ????":"Lintcode 18","尾递归--迭代#尾递归 \u0026ndash;\u0026gt; 迭代":"尾递归优化：就是把递归改成迭代形式\n不支持尾递归优化的语言，解决stackoverflow： 把递归改成迭代形式 Note：所谓的尾递归优化，就是把递归改成迭代形式。所以如果语言不支持尾递归优化，需要手动将尾递归改成迭代形式。 支持尾递归优化的语言，是由编译器自动将尾递归的代码翻译成迭代形式的代码。\n如何改成迭代： 模拟递归中调用下一层的参数传递过程: 1.先做完本层递归的事儿 2.再计算出下一层递归的各个参数 3.然后把值赋给当前层的各个参数 template:(C++) public: ReturnType FunctionName(parameters) { while (true) { do something ... get new parameters parameters = new parameters } } template:(python) def functionName(parameters): while True: do something ... get new parameters parameters = new parameters class Solution { public: long long doubleFactorial(int n) { return doubleFactorial(n , 1); } private: long long doubleFactorial(int n, long long result) { while (true) { // do something if (n \u003c= 2) { return n * result; } // get new parameters int next_n = n - 2; long next_result = n * result; // parameters = new parameters n = next_n; result = next_result; } } }; class Solution: def doubleFactorial(self, n, result=1): while True: # do something if n \u003c= 2: return n * result # get new parameters next_n, next_result = n - 2, n * result # parameters = new parameters n, result = next_n, next_result","尾递归--迭代-1#尾递归 \u0026ndash;\u0026gt; 迭代":"do something?\npos == 1 last = n \u0026 1 get new parameters\nnew_n = n » 1 new_pos = pos - 1 new_result = result + last « (pos - 1) parameters = new parameters\nn = new_n pos = new_pos result = new_result class Solution { public: long long reverseBits(long long n) { return reverseBits(n, 32, 0); } private: long long reverseBits(long long n, int pos, long long result) { while (true) { // do something if (pos == 1) { return n + result; } long long last = n \u0026 1; // get new parameters long long new_n = n \u003e\u003e 1; int new_pos = pos - 1; long long new_result = result + (last \u003c\u003c (pos - 1)); // parameters = new parameters n = new_n; pos = new_pos; result = new_result; } } }; class Solution: def reverse_bits(self, n, pos=32, result=0) -\u003e int: while True: # do something if pos == 1: return n + result last = n \u0026 1 # get new parameters new_n, new_pos, new_result = n \u003e\u003e 1, pos - 1, result + (last \u003c\u003c (pos - 1)) # parameters = new parameters n, pos, result = new_n, new_pos, new_result","尾递归--迭代-2#尾递归 \u0026ndash;\u0026gt; 迭代":"class Solution { public: int maxNum(std::vector\u003cint\u003e\u0026 nums) { return maxNum(nums, 0, nums[0]); } private: int maxNum(std::vector\u003cint\u003e\u0026 nums, int index, int result) { while (true) { if (index == nums.size() - 1) { return nums[index] \u003e result ? nums[index] : result; } int new_index = index + 1; int new_result = result \u003e nums[index] ? result : nums[index]; index = new_index; result = new_result; } } }; from typing import ( List, ) class Solution: def max_num(self, nums: List[int], index=0, result=float(\"-inf\")) -\u003e int: while True: if index == len(nums) - 1: return nums[index] if nums[index] \u003e result else result new_index, new_result = index + 1, result if result \u003e nums[index] else nums[index] index, result = new_index, new_result","带重复元素的排列#带重复元素的排列":"Lintcode 16 递归的定义\nhelper(nums, permutations, permutation, visited) 递归的拆解\n在 nums 里选择一个还未选择的数 且这个数前面相同的数都被选过了 递归的出口\n所有数都被选中的时候","快速幂#快速幂":"Lintcode 140","快速幂的迭代形式-pass#快速幂的迭代形式: Pass":"class Solution { public: int fastPower(int a, int b, int n) { int result = 1 % b; while (n != 0) { if (n % 2 == 1) { result = (long long)result * a % b; } a = (long long)a * a % b; n /= 2; } return result; } }; class Solution: def fast_power(self, a: int, b: int, n: int) -\u003e int: result = 1 % b while n != 0: if n % 2 == 1: result = result * a % b a = a * a % b n //= 2 return result","快速幂的递归方式-pass#快速幂的递归方式: Pass":"递归的定义 fastPower(a, b, n) 计算(a^n) % b 递归的拆解 n % 2 == 0 x –\u003e a^(n/2) y –\u003e a^(n/2) n % 2 == 1 x –\u003e a^(n/2) y –\u003e a^(n/2) * a z –\u003e b 递归的出口 n == 0 return 1 % b class Solution { public: int fastPower(int a, int b, int n) { if (n == 0) { return 1 % b; } // here must be long long, cannot be int long long x = fastPower(a, b, n / 2); long long y = n % 2 != 0 ? (x * a % b) : x; return x * y % b; } }; class Solution: def fast_power(self, a: int, b: int, n: int) -\u003e int: if n == 0: return 1 % b x = self.fast_power(a, b, n // 2) y = x * a % b if n % 2 != 0 else x return x * y % b","排列类问题非递归#排列类问题非递归":"Lintcode 15","排列问题递归树#排列问题递归树":"递归的定义 helper(nums, permutations, permutation, visited) 不需要 start 和 end 两个指针 递归的拆解 在 nums 里选择一个还未选择的数 递归的出口 所有数都被选中的时候 visited 的大小达到了 length 或者 permutation 的大小达到了 length class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e permute(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e permutations; std::vector\u003cint\u003e permutation; std::unordered_set\u003cint\u003e visited; helper(nums, permutations, permutation, visited); return permutations; } private: void helper(std::vector\u003cint\u003e\u0026 nums, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 permutations, std::vector\u003cint\u003e\u0026 permutation, std::unordered_set\u003cint\u003e\u0026 visited) { if (visited.size() == nums.size()) { permutations.push_back(permutation); return; // can be ignored } for (int i = 0; i \u003c nums.size(); ++i) { if (visited.find(nums[i]) != visited.end()) { continue; } permutation.push_back(nums[i]); visited.insert(nums[i]); helper(nums, permutations, permutation, visited); permutation.pop_back(); visited.erase(nums[i]); } } }; return?\nfrom typing import ( List, ) class Solution: def permute(self, nums: List[int]) -\u003e List[List[int]]: permutations = list() self.helper(nums, permutations, None, None) return permutations def helper(self, nums, permutations, permutation, visited): if permutation is None: permutation = list() if visited is None: visited = set() if len(visited) == len(nums): permutations.append(list(permutation)) return # can be ignored for num in nums: if num in visited: continue permutation.append(num) visited.add(num) self.helper(nums, permutations, permutation, visited) permutation.pop() visited.remove(num) return?","数字组合#数字组合":"Lintcode 135","斐波那契数列#斐波那契数列":"递归树(后序遍历) Lintcode 366 fibonacci 递归的定义 fibonacci(n) 求解斐波那契数列第n项 递归的拆解 fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2) 递归的出口 fibonacci(1) = 0 fibonacci(2) = 1 // Time Limit Exceeded class Solution { public: int fibonacci(int n) { if (n \u003c= 2) { return n - 1; } return fibonacci(n - 1) + fibonacci(n - 2); } };","普通写法的递归方式#普通写法的递归方式:":"","普通写法的递归方式-time-limit-exceeded#普通写法的递归方式: Time Limit Exceeded":"递归的定义 findPosition(nums, start, end, target) 在nums数组[start, end]区间上查找target 递归的拆解 findPosition(nums, start + 1, end, target) 递归的出口 start \u003e end: return -1 nums[start] == target: return start class Solution { public: int findPosition(std::vector\u003cint\u003e\u0026 nums, int target) { return findPosition(nums, 0, nums.size() - 1, target); } private: int findPosition(std::vector\u003cint\u003e\u0026 nums, int start, int end, int\u0026 target) { if (start \u003e end) { return -1; } if (nums[start] == target) { return start; } return findPosition(nums, start + 1, end, target); } }; class Solution: def findPosition(self, nums, target, start=0, end=None): if end is None: end = len(nums) - 1 if start \u003e end: return -1 if nums[start] == target: return start return self.findPosition(nums, target, start + 1, end)","普通递归#普通递归":"递归的定义 doubleFactorial(n) 接收一个正整数n 返回n的二阶阶乘 递归的拆解 求解doubleFactorial(n - 2) 在doubleFactorial(n - 2)的基础上乘n 递归的出口 doubleFactorial(1) = 1 doubleFactorial(2) = 2 class Solution { public: long long doubleFactorial(int n) { if (n \u003c= 2) { return n; } long long temp = doubleFactorial(n - 2); return n * temp; } }; class Solution: def double_factorial(self, n: int) -\u003e int: if n \u003c= 2: return n temp = self.double_factorial(n - 2) return n * temp class Solution { public: long long doubleFactorial(int n) { if (n \u003c= 2) { return n; } return n * doubleFactorial(n - 2); } }; class Solution: def double_factorial(self, n: int) -\u003e int: if n \u003c= 2: return n return n * self.double_factorial(n - 2)","普通递归--尾递归#普通递归 \u0026ndash;\u0026gt; 尾递归":"尾递归：\n尾递归的特点： 函数中所有递归形式的调用都出现在函数的末尾 递归调用不属于表达式的一部分（在回归过程中不用做任何操作） 尾递归的作用： 尾递归的调用不会在栈中去创建一个新的 而是覆盖当前的活动记录 为什么可以尾递归： 在回归过程中不用做任何操作 // 在回归过程中不能做任何操作 // 事先处理掉乘n的操作 // 把结果作为参数传递给递归函数 class Solution { public: long long doubleFactorial(int n) { return doubleFactorial(n , 1); } private: long long doubleFactorial(int n, long long result) { if (n \u003c= 2) { return n * result; } return doubleFactorial(n - 2, n * result); } }; class Solution: def double_factorial(self, n, result=1): if n \u003c= 2: return n * result return self.double_factorial(n - 2, n * result) 不是所有语言都支持尾递归优化：\n不支持：python, java, C++ 支持：kotlin(tailrec) 以上四种语言都支持尾递归写法，但是支持尾递归优化都只有kotlin","普通递归--尾递归-1#普通递归 \u0026ndash;\u0026gt; 尾递归":"在回归过程中不能做任何操作 事先处理掉 (last « (pos - 1)) + ret 的操作 事先把(last « (post - 1)) 加到result里 再把result作为参数传给下一层递归 class Solution { public: long long reverseBits(long long n) { return reverseBits(n, 32, 0); } private: long long reverseBits(long long n, int pos, long long result) { if (pos == 1) { return n + result; } long long last = n \u0026 1; result += last \u003c\u003c (pos - 1); return reverseBits(n \u003e\u003e 1, pos - 1, result); } }; class Solution: def reverse_bits(self, n, pos=32, result=0) -\u003e int: if pos == 1: return n + result last = n \u0026 1 result += (last \u003c\u003c (pos - 1)) return self.reverse_bits(n \u003e\u003e 1, pos - 1, result)","普通递归--尾递归-2#普通递归 \u0026ndash;\u0026gt; 尾递归":"class Solution { public: int maxNum(std::vector\u003cint\u003e\u0026 nums) { return maxNum(nums, 0, nums[0]); } private: int maxNum(std::vector\u003cint\u003e\u0026 nums, int index, int result) { if (index == nums.size() - 1) { return nums[index] \u003e result ? nums[index] : result; } result = result \u003e nums[index] ? result : nums[index]; return maxNum(nums, index + 1, result); } }; from typing import ( List, ) class Solution: def max_num(self, nums: List[int], index=0, result=float(\"-inf\")) -\u003e int: if index == len(nums) - 1: return nums[index] if nums[index] \u003e result else result result = result if result \u003e nums[index] else nums[index] return self.max_num(nums, index + 1, result)","普通递归-1#普通递归":"递归的定义 reverseBits(n, pos) 翻转一个pos位无符号整数n的二进制位并返回 Hints: 把n看成长度为pos的一个数组 递归的拆解 求出n的最后一位二进制位last 翻转n前面的pos-1位 把last放到最前面 递归的出口 n只有1位 pos == 1 class Solution { public: long long reverseBits(long long n) { return reverseBits(n, 32); } private: long long reverseBits(long long n, int pos) { if (pos == 1) { return n; } long long last = n \u0026 1; long long ret = reverseBits(n \u003e\u003e 1, pos - 1); long long result = (last \u003c\u003c (pos - 1)) + ret; return result; } }; class Solution: def reverse_bits(self, n: int, pos=32) -\u003e int: if pos == 1: return n last = n \u0026 1 ret = self.reverse_bits(n \u003e\u003e 1, pos - 1) result = (last \u003c\u003c (pos - 1)) + ret return result","普通递归-2#普通递归":"递归的定义 maxNum(nums, index) 递归的拆解 nums[index] vs maxNum(…) 递归的出口 index = nums.size() - 1 class Solution { public: int maxNum(std::vector\u003cint\u003e\u0026 nums) { return maxNum(nums, 0); } private: int maxNum(std::vector\u003cint\u003e\u0026 nums, int index) { if (index == nums.size() - 1) { return nums[index]; } int ret = maxNum(nums, index + 1); return nums[index] \u003e ret ? nums[index] : ret; } }; from typing import ( List, ) class Solution: def max_num(self, nums: List[int], index=0) -\u003e int: if index == len(nums) - 1: return nums[index] ret = self.max_num(nums, index + 1) return nums[index] if nums[index] \u003e ret else ret","最大二叉树#最大二叉树":"Lintcode 1106 递归的定义 buildTree(nums, start, end) 以nums数组的start～end区间构建最大二叉树 递归的拆解 找到nums数组start～end区间上的最大元素位置记做position root = nums[position] root.left = buildTree(nums, start, position - 1); root.right = buildTree(nums, position + 1, end); 递归的出口 nums数组或start～end区间为空的时候 class Solution { public: TreeNode* constructMaximumBinaryTree(std::vector\u003cint\u003e\u0026 nums) { return buildTree(nums, 0, nums.size() - 1); } private: TreeNode* buildTree(std::vector\u003cint\u003e\u0026 nums, int start, int end) { if (start \u003e end) { return nullptr; } int position = start; for (int i = start + 1; i \u003c= end; ++i) { if (nums[i] \u003e nums[position]) { position = i; } } TreeNode* root = new TreeNode(nums[position]); root-\u003eleft = buildTree(nums, start, position - 1); root-\u003eright = buildTree(nums, position + 1, end); return root; } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def construct_maximum_binary_tree(self, nums: List[int]) -\u003e TreeNode: return self.buildTree(nums, 0, len(nums) - 1) def buildTree(self, nums, start, end): if start \u003e end: return None position = start for i in range(start + 1, end + 1): if nums[i] \u003e nums[position]: position = i root = TreeNode(nums[position]) root.left = self.buildTree(nums, start, position - 1) root.right = self.buildTree(nums, position + 1, end) return root","求解一个排列是第几个排列#求解一个排列是第几个排列":"","求解第k个排列#求解第k个排列":"","汉诺塔#汉诺塔":"递归树(中序遍历) 拆解的时候只考虑当前层 Lintcode 169 tower of Hanoi 递归的定义 helper(n, start, end, temp, moves) 把n个盘子从start移到end 可以借助temp进行移动 移动的方案存到moves里 递归的拆解 把前n - 1个盘子从start移到temp helper(n - 1, start, temp, end, moves) 把第n个盘子从start移到end 把前n-1个盘子从temp移到end helper(n - 1, temp, end, start, moves) 递归的出口 n == 1 直接把盘子从start移到end class Solution { public: std::vector\u003cstd::string\u003e towerOfHanoi(int n) { std::vector\u003cstd::string\u003e moves; towerOfHanoi(n, 'A', 'C', 'B', moves); return moves; } private: void towerOfHanoi(int n, char start, char end, char temp, std::vector\u003cstd::string\u003e\u0026 moves) { if (n == 1) { moves.push_back(move(start, end)); return; // don't forgot this return } towerOfHanoi(n - 1, start, temp, end, moves); moves.push_back(move(start, end)); towerOfHanoi(n - 1, temp, end, start, moves); } std::string move(char start, char end) { return std::string() + \"from \" + start + \" to \" + end; } }; from typing import ( List, ) class Solution: def tower_of_hanoi(self, n: int) -\u003e List[str]: moves = list() self.helper(n, 'A', 'C', 'B', moves) return moves def helper(self, n, start, end, temp, moves): if n == 1: moves.append(self.move(start, end)) return # don't forgot this return self.helper(n - 1, start, temp, end, moves) moves.append(self.move(start, end)) self.helper(n - 1, temp, end, start, moves) def move(self, start, end): return \"from \" + start + \" to \" + end","用morris算法实现二叉树非递归遍历#用Morris算法实现二叉树非递归遍历":"","用手写栈模拟递归解法#用手写栈模拟递归解法":"参考：全排列 struct State { State(int node, int count) : node(node), count(count) {} int node, count; }; class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e permute(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cint\u003e permutation; std::vector\u003cstd::vector\u003cint\u003e\u003e permutations; std::unordered_set\u003cint\u003e visited; std::deque\u003cState*\u003e stack; stack.push_back(new State(0, 0)); while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); int node = now-\u003enode; int count = now-\u003ecount; if (count == 0) { // didn't use node here when count is 0 if (visited.size() == nums.size()) { permutations.push_back(permutation); continue; } for (int i = 0; i \u003c nums.size(); ++i) { // begin from 0 instead of node if (visited.find(nums[i]) != visited.end()) { continue; } stack.push_back(new State(i, 2)); stack.push_back(new State(i + 1, 0)); // here i + 1 can be anything stack.push_back(new State(i, 1)); } } if (count == 1) { permutation.push_back(nums[node]); visited.insert(nums[node]); } if (count == 2) { permutation.pop_back(); visited.erase(nums[node]); } } return permutations; } }; from typing import ( List, ) class Solution: def permute(self, nums: List[int]) -\u003e List[List[int]]: permutation = list() permutations = list() visited = set() stack = [(0, 0)] while stack: node, count = stack.pop() if count == 0: # didn't use node here when count is 0 if len(visited) == len(nums): permutations.append(list(permutation)) continue for i in range(len(nums)): # begin from 0 instead of node if nums[i] in visited: continue stack.append((i, 2)) stack.append((i + 1, 0)) # here i + 1 can be anything stack.append((i, 1)) if count == 1: permutation.append(nums[node]) visited.add(nums[node]) if count == 2: permutation.pop() visited.remove(nums[node]) return permutations","用栈实现二叉树非递归遍历#用栈实现二叉树非递归遍历":"","第k个排列#第k个排列":"Lintcode 388 递归的定义\nhelper(nums, k, result) 由于每次修改的位置在中间 无法为 nums 添加 start 和 end 两个指针 递归的拆解\n找到第 k 个排列的第一个元素 再用剩下的元素到下一层构造后面的部分 递归的出口\nnums 数组为空的时候 class Solution { public: std::string getPermutation(int n, int k) { std::vector\u003cint\u003e nums(n); for (int i = 0; i \u003c n; ++i) { nums[i] = i + 1; } std::string result; helper(nums, k, result); return result; } private: void helper(std::vector\u003cint\u003e\u0026 nums, int k, std::string\u0026 result) { if (nums.size() == 0) { return; } // e.g. numbers of result after fixing the first element int factorial = 1; for (int i = 1; i \u003c nums.size(); ++i) { factorial *= i; } int first = (k - 1) / factorial; result += std::to_string(nums[first]); nums.erase(nums.begin() + first); helper(nums, (k - 1) % factorial + 1, result); // ??? } }; class Solution: def get_permutation(self, n: int, k: int) -\u003e str: nums = list(range(1, n + 1)) result = list() self.helper(nums, k, result) return \"\".join(result) def helper(self, nums, k, result): if not nums: return # e.g. numbers of result after fixing the first element factorial = 1 for i in range(1, len(nums)): factorial *= i first = (k - 1) // factorial result.append(str(nums[first])) nums.pop(first) print(nums) self.helper(nums, (k - 1) % factorial + 1, result) # ???","组合数思路解法#组合数思路解法":"2. 参考：组合数解法(递归) struct State { State(int node, int count) : node(node), count(count) {} int node, count; }; class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e subsets(std::vector\u003cint\u003e\u0026 nums) { std::vector\u003cstd::vector\u003cint\u003e\u003e combinations; std::vector\u003cint\u003e combination; std::sort(nums.begin(), nums.end()); std::deque\u003cState*\u003e stack; stack.push_back(new State(0, 0)); while (!stack.empty()) { State* now = stack.back(); stack.pop_back(); int node = now-\u003enode; int count = now-\u003ecount; if (count == 0) { combinations.push_back(combination); for (int i = node; i \u003c nums.size(); ++i) { stack.push_back(new State(i, 2)); stack.push_back(new State(i + 1, 0)); stack.push_back(new State(i, 1)); } } if (count == 1) { combination.push_back(nums[node]); } if (count == 2) { combination.erase(combination.begin() + combination.size() - 1); } } return combinations; } }; from typing import ( List, ) class Solution: def subsets(self, nums: List[int]) -\u003e List[List[int]]: combination = [] combinations = [] nums = sorted(nums) stack = [(0, 0)] while stack: node, count = stack.pop() if count == 0: combinations.append(list(combination)) for i in range(node, len(nums)): stack.append((i, 2)) stack.append((i + 1, 0)) stack.append((i, 1)) if count == 1: combination.append(nums[node]) if count == 2: combination.pop() return combinations","组合类问题非递归三种解法#组合类问题非递归（三种解法）":"Lintcode 17","经典二分查找问题#经典二分查找问题":"Lintcode 457","迭代的方式#迭代的方式":"class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0); dummy-\u003enext = head; head = dummy; while (head-\u003enext != nullptr \u0026\u0026 head-\u003enext-\u003enext != nullptr) { ListNode* first = head-\u003enext; ListNode* second = first-\u003enext; // head-\u003efirst-\u003esecond-\u003e... // =\u003e head-\u003esecond-\u003efirst-\u003e... head-\u003enext = second; first-\u003enext = second-\u003enext; second-\u003enext = first; head = first; } return dummy-\u003enext; } }; from lintcode import ( ListNode, ) class Solution: def swap_pairs(self, head: ListNode) -\u003e ListNode: dummy = ListNode(0) dummy.next = head head = dummy while head.next is not None and head.next.next is not None: first = head.next second = head.next.next # head-\u003efirst-\u003esecond-\u003e... # =\u003e head-\u003esecond-\u003efirst-\u003e... head.next = second first.next = second.next second.next = first head = first return dummy.next","适合分治法的数据结构#适合分治法的数据结构":"数组：一个大数组可以拆分为若干个不相交的子数组 二叉树：整棵二叉树的左子树和右子树都是二叉树","递归二叉树的遍历#递归，二叉树的遍历：":"Lintcode 66 preorder Lintcode 67 inorder Lintcode 68 postorder 递归的定义 preorderTraversal(root) —- 前序遍历 inorderTraversal(root) —- 中序遍历 postorderTraversal(root) —- 后序遍历 递归的拆解 先处理自己 再处理左子树 然后处理右子树 —- 前序遍历 先处理左子树 再处理自己 然后处理右子树 —- 中序遍历 先处理左子树 再处理右子树 然后处理自己 —- 后序遍历 递归的出口 root是一颗空树 —- 前序遍历、中序遍历、后序遍历 class Solution { public: std::vector\u003cint\u003e preorderTraversal(TreeNode* root) { std::vector\u003cint\u003e nodes; preorder_traversal(root, nodes); return nodes; } private: void preorder_traversal(TreeNode* root, std::vector\u003cint\u003e\u0026 nodes) { if (root == nullptr) { return; } nodes.push_back(root-\u003eval); preorder_traversal(root-\u003eleft, nodes); preorder_traversal(root-\u003eright, nodes); } }; from typing import ( List, ) from lintcode import ( TreeNode, ) class Solution: def preorder_traversal(self, root: TreeNode) -\u003e List[int]: nodes = list() self.preorder_traversal_helper(root, nodes) return nodes def preorder_traversal_helper(self, root, nodes): if root is None: return nodes.append(root.val) self.preorder_traversal_helper(root.left, nodes) self.preorder_traversal_helper(root.right, nodes)","递归改非递归#递归改非递归":"尾递归 改成迭代形式：只要是线性递归，都能改成迭代形式 非尾递归 模拟系统调用栈：当遇到非线性递归（二叉递归，多叉递归） 用特殊思路来完成递归要做的事儿 Morris算法 不算是递归改成非递归","递归求解an#递归求解a^n":"递归的定义 fastPower(a, n) 计算a^n 递归的拆解 a * fastPower(a, n - 1) 递归的出口 n == 0 return 1 同余定理： x * y % z = (x % z) * (y % z) % z\na % b = (a + b) % b = (a + 2 * b) % b … = (a + k * b) % b, k 是任意整数 x 和 (x % z) 取余相差了整数个z y 和 (y % z) 取余相差了整数个z","递归求解an--b-fail#递归求解(a^n) % b: Fail":"递归的定义 fastPower(a, b, n) 计算(a^n) % b 递归的拆解 同余定理 (x * y) % z –\u003e ((x % z) * (y % z)) % z x –\u003e a y –\u003e a^(n - 1) z –\u003e b 递归的出口 n == 0 return 1 % b 递归时间复杂度 = 函数参数的可能组合 * 每层递归的处理时间\n函数参数的可能组合 O(n) 每层递归的时间 O(1) class Solution { public: int fastPower(int a, int b, int n) { if (n == 0) { return 1 % b; } int x = a % b; int y = fastPower(a, b, n - 1); return x * y % b; } }; class Solution: def fast_power(self, a: int, b: int, n: int) -\u003e int: if n == 0: return 1 % b x = a % b y = self.fast_power(a, b, n - 1) return x * y % b","递归的方式#递归的方式":"递归的定义 swapPairs(head) 两两交换链表head中的节点 返回交换后的链表表头 递归的拆解 取下head中的前两个节点并交换 swapPairs(head.next.next) 连接前两个节点和后面部分链表 递归的出口 链表中节点数量不足两个 不用交换，直接返回当前表头 class Solution { public: ListNode* swapPairs(ListNode* head) { if (head == nullptr || head-\u003enext == nullptr) { return head; } ListNode* first = head; ListNode* second = head-\u003enext; ListNode* suffix = swapPairs(second-\u003enext); second-\u003enext = first; first-\u003enext = suffix; return second; } }; from lintcode import ( ListNode, ) class Solution: def swap_pairs(self, head: ListNode) -\u003e ListNode: if head is None or head.next is None: return head first, second = head, head.next suffix = self.swap_pairs(second.next) second.next = first first.next = suffix return second","递归的核心思想由大化小best-solution#递归的核心思想：由大化小：Best Solution":"class Solution { public: bool canWinBash(int n) { return n % 4 != 0; } }; class Solution: def can_win_bash(self, n: int) -\u003e bool: return n % 4 != 0","通过遍历序确定二叉树important#通过遍历序确定二叉树(important)":"","颠倒二进制位#颠倒二进制位":"Lintcode 1333"},"title":"Recursion"},"/blog/partition/":{"data":{"":"Partition Template Quick Sort Top K Split(Quick Selection): (n = k/1/n-k-1) Top Kth Smallest Top Kth Largest","kth-large#Kth large":"int TopKthLarge(vector\u003cint\u003e\u0026 nums, int k) { // parttion是按从小到大划分的，如果让index左边为前n-k个小的数，则index右边为前k个大的数 TopKSplit(nums, nums.size() - k, 0, nums.size() - 1); // change k to nums.size() - k return nums[nums.size() - k]; }","kth-small#Kth small":"int TopKthSmall(vector\u003cint\u003e\u0026 nums, int k) { TopKSplit(nums, k - 1, 0, nums.size() - 1); return nums[k - 1]; }","only-sort-top-k-larges#Only Sort Top K Larges":"// 只排序后 k 个大的数 // 获得前 k 小的数 O(n)，进行快排 O(klogk) vector\u003cint\u003e TopKSortLeft(vector\u003cint\u003e\u0026 nums, int k) { TopKSplit(nums, nums.size() - k, 0, nums.size() - 1); vector\u003cint\u003e topk = vector\u003cint\u003e(nums.begin() + nums.size() - k, nums.end()); QuickSort(topk, 0, topk.size() - 1); topk.insert(topk.begin(), nums.begin() + nums.size() - k, nums.end()); return topk; }","only-sort-top-k-smalls#Only Sort Top K Smalls":"// 只排序前 k 个小的数 // 获得前 k 小的数 O(n)，进行快排 O(klogk) vector\u003cint\u003e TopKSortLeft(vector\u003cint\u003e\u0026 nums, int k) { TopKSplit(nums, k, 0, nums.size() - 1); vector\u003cint\u003e topk = vector\u003cint\u003e(nums.begin(), nums.begin() + k); QuickSort(topk, 0, topk.size() - 1); topk.insert(topk.end(), nums.begin() + k, nums.end()); return topk; }","partition-template#Partition Template":"int partition(vector\u003cint\u003e\u0026 nums, int start, int end) { int pivot = nums[start]; // 初始化一个待比较数据; int i = start, j = end; while (i \u003c j) { // 从后往前查找，直到找到一个比pivot更小的数 while (i \u003c j \u0026\u0026 nums[j] \u003e= pivot) --j; nums[i] = nums[j]; // 将更小的数放入左边 // 从前往后找，直到找到一个比pivot更大的数 while (i \u003c j \u0026\u0026 nums[i] \u003c= pivot) ++i; nums[j] = nums[i]; // 将更大的数放入右边 } // 循环结束，i与j相等 nums[i] = pivot; return i; // 返回待比较数据最终位置 }","quick-sort#Quick Sort":"void QuickSort(vector\u003cint\u003e\u0026 nums, int start, int end) { if (start \u003e= end) return; int idx = partition(nums, start, end); QuickSort(nums, start, idx - 1); QuickSort(nums, idx + 1, end); }","top-k-larges#Top K Larges":"vector\u003cint\u003e TopKLarges(vector\u003cint\u003e\u0026 nums, int k) { // parttion是按从小到大划分的，如果让index左边为前n-k个小的数，则index右边为前k个大的数 TopKSplit(nums, nums.size() - k, 0, nums.size() - 1); // change k to nums.size() - k return vector\u003cint\u003e(nums.begin() + nums.size() - k, nums.end()); }","top-k-smalls#Top K Smalls":"vector\u003cint\u003e TopKSmalls(vector\u003cint\u003e\u0026 nums, int k) { TopKSplit(nums, k, 0, nums.size() - 1); return vector\u003cint\u003e(nums.begin(), nums.begin() + k); }","top-k-split#Top K Split":"将快速排序改成快速选择，即我们希望寻找到一个位置，这个位置左边是k个比这个位置上的数更小的数，右边是n - k - 1个比该位置上的数大的数，我将它命名为TopKSplit，找到这个位置后停止迭代，完成了一次划分。 // Quick Selection void TopKSplit(vector\u003cint\u003e\u0026 nums, int k, int left, int right) { // 寻找到第k个数停止递归，使得nums数组中index左边是前k个小的数，index右边是后面n-k个大的数 int idx = partition(nums, left, right); if (idx == k) return; else if (idx \u003c k) TopKSplit(nums, k, idx + 1, right); else TopKSplit(nums, k, left, idx - 1); }","usages#Usages":""},"title":"Partition"},"/blog/segment_tree/":{"data":{"":"Covered topics of Segment Tree and Binary Index Tree","build-template-on#Build: template (O(n))":"SegmentTreeNode* build(int start, int end) { if (start \u003e end) { return nullptr; } if (start == end) { return new SegmentTreeNode(start, end); } SegmentTreeNode* root = new SegmentTreeNode(start, end); if (start != end) { int mid = start + (end - start) / 2; root-\u003eleft_child = build(start, mid); root-\u003eright_child = build(mid + 1, end); } return root; }","chapter-1-线段树-segment-tree#Chapter 1 线段树 Segment Tree":"如果仅涉及区间上的查询，而不涉及修改，那么用前缀和即可。\n线段树的性质：\n除表示单点的一个节点是叶子节点外，其他每一个表示区间的节点都有两颗子树 每一个节点分出了左右节点的区间长度为父亲节点长度的一半（左边向上取整，右边向下取整） 每一个节点存储的值都是左右节点进行对应运算得出的。这个运算是根据要求而定的。如：求和的是和，求最大值的是max","chapter-2#Chapter 2":"","chapter-3-树状数组-binary-index-tree#Chapter 3 树状数组 Binary Index Tree":"用于维护前缀信息的结构，对前缀信息的处理也是非常高效的\n给定一个整数数组nums，然后你需要实现两个函数: Update(i, val)将数组下标为i的元素修改为val SumRange(l, r)返回数组下标在[l, r]区间的元素的和 暴力求解: Update时间复杂度O(1)、SumRange时间复杂度O(n)\n树状数组求解: Update时间复杂度O(logn)、SumRange时间复杂度O(logn)、对于长度为n的数组，构建树状数组时间复杂度O(nlogn)\nBinary Index Tree 是通过前缀和思想，用来完成 单点更新 和 区间查询 的数据结构。 Binary Index Tree advantages compared to Segment Tree: 所用空间更小（空间复杂度都是O(n), 但是Binary Index Tree只开了一个大小为n的数组，Segment Tree有左右指针, 区间端点等等），速度更快。 注意: 树状数组的下标从 1 开始计数。 定义: 数组 C 是一个对原始数组 A 的预处理数组。 C[i]的元素个数（来自于A）：取决于i的二进制末尾有几个连续的0.\ne.g. i有k个0，那么C[i]共有2^k个A中的元素.\n根据lowbit函数，可以知道C[i]代表几个A中的元素相加，以及i的父亲在哪儿(i + lowbit(i), e.g. 6 + lowbit(6) = 8)","chapter-4#Chapter 4":"","content#Content":"Chapter 1 线段树 Segment Tree Node: range-max Build: template (O(n)) Example: build range-max (O(n)) Modify: range-max (O(logn)) Query: range-max (O(logn)) Chapter 2 Lintcode 206 Interval Sum Lintcode 207 Interval Sum II Lintcode 248 Count of Smaller Number Lintcode 249 Count of Smaller Number before itself Exercise: Lintcode 201 Build Segment Tree Exercise: Lintcode 439 Build Segment Tree II Exercise: Lintcode 202 Query Segment Tree Exercise: Lintcode 247 Query Segment Tree II Exercise: Lintcode 203 Modify Segment Tree Chapter 3 树状数组 Binary Index Tree Lowbit 的两个含义 树状数组的程序实现: Lintcode 840: Range Sum In summary Chapter 4 Lintcode 206 Interval Sum Lintcode 207 Interval Sum II Lintcode 248 Count of Smaller Number Lintcode 249 Count of Smaller Number before itself Exercise: Lintcode 840 可变范围求和 Exercise: Lintcode 817 范围矩阵元素和-可变的 Exercise: Lintcode 665 平面范围求和 -不可变矩阵 Exercise: Lintcode 207 区间求和 II Exercise: Lintcode 206 区间求和 I","example-build-range-max-on#Example: build range-max (O(n))":"SegmentTreeNode* build(int start, int end, std::vector\u003cint\u003e\u0026 A) { if (start \u003e end) { return nullptr; } if (start == end) { return new SegmentTreeNode(start, end, A[start]); } SegmentTreeNode* node = new SegmentTreeNode(start, end, A[start]); if (start != end) { int mid = start + (end - start) / 2; node-\u003eleft_child = build(start, mid, A); node-\u003eright_child = build(mid + 1, end, A); } if (node-\u003eleft_child != nullptr \u0026\u0026 node-\u003eleft_child-\u003emax \u003e node-\u003emax) { node-\u003emax = node-\u003eleft_child-\u003emax; } if (node-\u003eright_child != nullptr \u0026\u0026 node-\u003eright_child-\u003emax \u003e node-\u003emax) { node-\u003emax = node-\u003eright_child-\u003emax; } return node; }","exercise-lintcode-201-build-segment-tree#Exercise: Lintcode 201 Build Segment Tree":"Lintcode 201 Build Segment Tree /** * Definition of SegmentTreeNode: * class SegmentTreeNode { * public: * int start, end; * SegmentTreeNode *left, *right; * SegmentTreeNode(int start, int end) { * this-\u003estart = start, this-\u003eend = end; * this-\u003eleft = this-\u003eright = NULL; * } * } */ class Solution { public: SegmentTreeNode* build(int start, int end) { } };","exercise-lintcode-202-query-segment-tree#Exercise: Lintcode 202 Query Segment Tree":"Lintcode 202 Query Segment Tree","exercise-lintcode-203-modify-segment-tree#Exercise: Lintcode 203 Modify Segment Tree":"Lintcode 203 Modify Segment Tree","exercise-lintcode-206-区间求和-i#Exercise: Lintcode 206 区间求和 I":"Lintcode 206 区间求和 I","exercise-lintcode-207-区间求和-ii#Exercise: Lintcode 207 区间求和 II":"Lintcode 207 区间求和 II","exercise-lintcode-247-query-segment-tree-ii#Exercise: Lintcode 247 Query Segment Tree II":"Lintcode 247 Query Segment Tree II","exercise-lintcode-439-build-segment-tree-ii#Exercise: Lintcode 439 Build Segment Tree II":"Lintcode 439 Build Segment Tree II","exercise-lintcode-665-平面范围求和--不可变矩阵#Exercise: Lintcode 665 平面范围求和 -不可变矩阵":"Lintcode 665 平面范围求和 -不可变矩阵","exercise-lintcode-817-范围矩阵元素和-可变的#Exercise: Lintcode 817 范围矩阵元素和-可变的":"Lintcode 817 范围矩阵元素和-可变的","exercise-lintcode-840-可变范围求和#Exercise: Lintcode 840 可变范围求和":"Lintcode 840 可变范围求和","in-summary#In summary":"若求区间(i, j)的区间和rangeSum(i, j) 使用前缀和时，rangeSum(i, j) = sum(j) - sum(i)，时间复杂度为O(1)。 使用线段树时，需要从根向下搜索，找到所有包含且仅包含(i, j)中元素的区间和，所有的深度最大为树的高度，时间复杂度为O(log n)。 使用树状数组，根据公式sum(i) = sum(i - lowbit(i)) + C[i]，使用树状数组求前缀和的时间复杂度为O(log n)。区间和rangeSum(i, j) = sum(j) - sum(i)，求区间和的操作可以转换为求两次前缀和，因此时间复杂度也是O(log n)。","lintcode-206-interval-sum#Lintcode 206 Interval Sum":"Lintcode 206 Interval Sum n为数组长度，m为查询次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) 前缀和数组O(n + m) struct STNode { STNode(int start, int end) : start(start), end(end), sum(0), left_child(nullptr), right_child(nullptr) {} int start, end; long long sum; STNode* left_child; STNode* right_child; }; class SegmentTree { public: SegmentTree(std::vector\u003cint\u003e\u0026 A) : size_(A.size()), root_(BuildTree(0, size_ - 1, A)) {} long long QuerySum(int start, int end) { return QuerySum(root_, start, end); } private: STNode* BuildTree(int start, int end, std::vector\u003cint\u003e\u0026 A) { STNode* node = new STNode(start, end); if (start == end) { node-\u003esum = A[start]; return node; } int mid = start + (end - start) / 2; node-\u003eleft_child = BuildTree(start, mid, A); node-\u003eright_child = BuildTree(mid + 1, end, A); node-\u003esum = node-\u003eleft_child-\u003esum + node-\u003eright_child-\u003esum; return node; } // [start, end] 包含于 [node-\u003estart, node-\u003eend] // 在 node 节点下，查询原数组 [start, end] 区间和 long long QuerySum(STNode* node, int start, int end) { if (node-\u003estart == start \u0026\u0026 node-\u003eend == end) { return node-\u003esum; } int mid = node-\u003estart + (node-\u003eend - node-\u003estart) / 2; long long left_sum = 0; long long right_sum = 0; if (start \u003c= mid) { left_sum = QuerySum(node-\u003eleft_child, start, std::min(end, mid)); } if (end \u003e= mid + 1) { right_sum = QuerySum(node-\u003eright_child, std::max(mid + 1, start), end); } return left_sum + right_sum; } int size_; // array size STNode* root_; }; /** * Definition of Interval: * class Interval { * public: * int start, end; * Interval(int start, int end) { * this-\u003estart = start; * this-\u003eend = end; * } * } */ class Solution { public: /** * @param a: An integer list * @param queries: An query list * @return: The result list */ std::vector\u003clong long\u003e intervalSum(std::vector\u003cint\u003e\u0026 A, std::vector\u003cInterval\u003e\u0026 queries) { std::vector\u003clong long\u003e result; SegmentTree* tree = new SegmentTree(A); for (Interval\u0026 i : queries) { result.push_back(tree-\u003eQuerySum(i.start, i.end)); } return result; } };","lintcode-206-interval-sum-1#Lintcode 206 Interval Sum":"Lintcode 206 Interval Sum n为数组长度，m为查询次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) 前缀和数组O(n + m) class BinaryIndexTree { public: BinaryIndexTree(std::vector\u003cint\u003e\u0026 A) { size_ = A.size(); a_ = std::vector\u003clong long\u003e(size_ + 1); // a_.assign(size_ + 1, 0); for (int i = 0; i \u003c size_; ++i) { Add(i, A[i]); } } // A[index] += val void Add(int index, int val) { ++index; while (index \u003c= size_) { a_[index] += val; index += Lowbit(index); } } // A[0] + ... + A[index] long long PrefixSum(int index) { ++index; long long ans = 0; while (index \u003e 0) { ans += a_[index]; index -= Lowbit(index); } return ans; } private: inline int Lowbit(int x) { return x \u0026 (-x); } std::vector\u003clong long\u003e a_; int size_; }; class Solution { public: std::vector\u003clong long\u003e intervalSum(std::vector\u003cint\u003e\u0026 A, std::vector\u003cInterval\u003e\u0026 queries) { std::vector\u003clong long\u003e ans; // BinaryIndexTree tree(A); BinaryIndexTree* tree = new BinaryIndexTree(A); // for (Interval\u0026 i : queries) { // if (i.start == 0) { // ans.push_back(tree.PrefixSum(i.end)); // } else { // ans.push_back(tree.PrefixSum(i.end) - // tree.PrefixSum(i.start - 1)); // } // } for (Interval\u0026 i : queries) { if (i.start == 0) { ans.push_back(tree-\u003ePrefixSum(i.end)); } else { ans.push_back(tree-\u003ePrefixSum(i.end) - tree-\u003ePrefixSum(i.start - 1)); } } return ans; } };","lintcode-207-interval-sum-ii#Lintcode 207 Interval Sum II":"Lintcode 207 Interval Sum II n为数组长度，m为操作次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) struct STNode { STNode(int start, int end) : start(start), end(end), sum(0), left_child(nullptr), right_child(nullptr) {} int start, end; long long sum; STNode* left_child; STNode* right_child; }; class SegmentTree { public: SegmentTree(std::vector\u003cint\u003e\u0026 A) : size_(A.size()), root_(BuildTree(0, size_, A)) {} long long QueryTree(int start, int end) { return QueryTree(root_, start, end); } void ModifyTree(int index, int value) { return ModifyTree(root_, index, value); } private: STNode* BuildTree(int start, int end, std::vector\u003cint\u003e\u0026 A) { STNode* node = new STNode(start, end); if (start == end) { node-\u003esum = A[start]; return node; } int mid = start + (end - start) / 2; node-\u003eleft_child = BuildTree(start, mid, A); node-\u003eright_child = BuildTree(mid + 1, end, A); node-\u003esum = node-\u003eleft_child-\u003esum + node-\u003eright_child-\u003esum; return node; } // [start, end] 包含于 [node-\u003estart, node-\u003eend] long long QueryTree(STNode* node, int start, int end) { // WRONG!!! if (node-\u003estart == node-\u003eend) { if (start == node-\u003estart \u0026\u0026 end == node-\u003eend) { return node-\u003esum; } long long left_sum = 0; long long right_sum = 0; int mid = node-\u003estart + (node-\u003eend - node-\u003estart) / 2; if (start \u003c= mid) { left_sum = QueryTree(node-\u003eleft_child, start, std::min(mid, end)); } if (end \u003e mid) { right_sum = QueryTree(node-\u003eright_child, std::max(start, mid + 1), end); } return left_sum + right_sum; } void ModifyTree(STNode* node, int index, int value) { // if (node-\u003estart == node-\u003eend) { if (node-\u003estart == node-\u003eend \u0026\u0026 node-\u003eend == index) { node-\u003esum = value; return; } if (node-\u003eleft_child-\u003eend \u003e= index) { ModifyTree(node-\u003eleft_child, index, value); } else { ModifyTree(node-\u003eright_child, index, value); } node-\u003esum = node-\u003eleft_child-\u003esum + node-\u003eright_child-\u003esum; } int size_; STNode* root_; }; class Solution { public: Solution(std::vector\u003cint\u003e\u0026 A) { if (A.size() == 0) { return; } tree = new SegmentTree(A); } long long query(int start, int end) { if (tree == nullptr) { return 0; } return tree-\u003eQueryTree(start, end); } void modify(int index, int value) { if (tree == nullptr) { return; } tree-\u003eModifyTree(index, value); } SegmentTree* tree; };","lintcode-207-interval-sum-ii-1#Lintcode 207 Interval Sum II":"Lintcode 207 Interval Sum II n为数组长度，m为操作次数\n暴力枚举求和O(nm) 树状数组/线段树查询区间和O(mlogn) class BinaryIndexTree { public: BinaryIndexTree(std::vector\u003cint\u003e\u0026 A) { size_ = A.size(); a_ = std::vector\u003clong long\u003e(size_ + 1); // a_.assign(size_ + 1, 0); for (int i = 0; i \u003c size_; ++i) { Add(i, A[i]); } } // A[index] += val void Add(int index, int val) { ++index; while (index \u003c= size_) { a_[index] += val; index += Lowbit(index); } } // A[0] + ... + A[index] long long PrefixSum(int index) { ++index; long long ans = 0; while (index \u003e 0) { ans += a_[index]; index -= Lowbit(index); } return ans; } private: inline int Lowbit(int x) { return x \u0026 (-x); } std::vector\u003clong long\u003e a_; int size_; }; class Solution { public: Solution(std::vector\u003cint\u003e\u0026 A) { A_ = A; tree_ = new BinaryIndexTree(A); } long long query(int start, int end) { if (start == 0) { return tree_-\u003ePrefixSum(end); } else { return tree_-\u003ePrefixSum(end) - tree_-\u003ePrefixSum(start - 1); } } void modify(int index, int value) { tree_-\u003eAdd(index, value - A_[index]); A_[index] = value; } private: std::vector\u003cint\u003e A_; // 为了计算difference BinaryIndexTree* tree_; };","lintcode-248-count-of-smaller-number#Lintcode 248 Count of Smaller Number":"Lintcode 248 Count of Smaller Number n为数组长度，m为查询次数，k为数组最大值\n暴力求解O(nm) 树状数组/线段树O(mlogk) 二分法O(nlogn + mlogn) 前缀和数组O(k + n + m) struct STNode { STNode(int start, int end) : start(start), end(end), sum(0), right(nullptr), left(nullptr) {} int start, end, sum; STNode* left; STNode* right; }; class STree { public: STree(int size) : size_(size), root_(BuildTree(0, size_ - 1)) {} int QueryTree(int start, int end) { return QueryTree(root_, start, end); } void ModifyTree(int index, int value) { return ModifyTree(root_, index, value); } private: STNode* BuildTree(int start, int end) { STNode* node = new STNode(start, end); if (start == end) { return node; } int mid = start + (end - start) / 2; node-\u003eleft = BuildTree(start, mid); node-\u003eright = BuildTree(mid + 1, end); return node; } int QueryTree(STNode* node, int start, int end) { if (node-\u003estart == start \u0026\u0026 node-\u003eend == end) { return node-\u003esum; } int mid = node-\u003estart + (node-\u003eend - node-\u003estart) / 2; int left_sum = 0; int right_sum = 0; if (start \u003c= mid) { left_sum = QueryTree(node-\u003eleft, start, std::min(mid, end)); } if (end \u003e mid) { right_sum = QueryTree(node-\u003eright, std::max(start, mid + 1), end); } return left_sum + right_sum; } void ModifyTree(STNode* node, int index, int value) { if (node-\u003estart == node-\u003eend \u0026\u0026 node-\u003estart == index) { node-\u003esum = value; return; } int mid = node-\u003estart + (node-\u003eend - node-\u003estart) / 2; if (index \u003c= mid) { ModifyTree(node-\u003eleft, index, value); } else { ModifyTree(node-\u003eright, index, value); } node-\u003esum = node-\u003eleft-\u003esum + node-\u003eright-\u003esum; } int size_; STNode* root_; }; class Solution { public: std::vector\u003cint\u003e countOfSmallerNumber(std::vector\u003cint\u003e\u0026 A, std::vector\u003cint\u003e\u0026 queries) { std::vector\u003cint\u003e B(10001); for (int\u0026 a : A) { ++B[a]; } STree* tree = new STree(10001); for (int i = 0; i \u003c= 10000; ++i) { tree-\u003eModifyTree(i, B[i]); } std::vector\u003cint\u003e result; for (int\u0026 q : queries) { if (q == 0) { result.push_back(0); } else { result.push_back(tree-\u003eQueryTree(0, q - 1)); } } return result; } };","lintcode-248-count-of-smaller-number-1#Lintcode 248 Count of Smaller Number":"Lintcode 248 Count of Smaller Number n为数组长度，m为查询次数，k为数组最大值\n暴力求解O(nm) 树状数组/线段树O(mlogk) 二分法O(nlogn + mlogn) 前缀和数组O(k + n + m) class BinaryIndexTree { public: BinaryIndexTree(int size) { size_ = size; a_.assign(size_ + 1, 0); } // B[index] += val void Add(int index, int val) { ++index; while (index \u003c= size_) { a_[index] += val; index += Lowbit(index); } } // B[0] + ... + B[index] int PrefixSum(int index) { ++index; int ret = 0; while (index \u003e 0) { ret += a_[index]; index -= Lowbit(index); } return ret; } private: int Lowbit(int x) { return x \u0026 (-x); } int size_; std::vector\u003cint\u003e a_; }; class Solution { public: std::vector\u003cint\u003e countOfSmallerNumber(std::vector\u003cint\u003e\u0026 A, std::vector\u003cint\u003e\u0026 queries) { int max_a = -1; for (int\u0026 i : A) { max_a = std::max(max_a, i); } BinaryIndexTree* tree = new BinaryIndexTree(max_a + 1); // B[A[i]]++ for (int\u0026 i : A) { tree-\u003eAdd(i, 1); } std::vector\u003cint\u003e ans; for (int\u0026 i : queries) { if (i \u003e max_a) { ans.push_back(A.size()); } else if (i \u003c 0) { ans.push_back(0); } else { ans.push_back(tree-\u003ePrefixSum(i - 1)); } } return ans; } };","lintcode-249-count-of-smaller-number-before-itself#Lintcode 249 Count of Smaller Number before itself":"Lintcode 249 Count of Smaller Number before itself n为数组长度，k为数组最大值\n暴力求解O(n^2) 树状数组/线段树O(nlogk) 在单点修改的情况下，维护前缀和：使用线段树维护B数组\nstruct STNode { STNode(int start, int end) : start(start), end(end), sum(0), left(nullptr), right(nullptr) {} int start, end; int sum; STNode* left; STNode* right; }; class STree { public: STree(int size) : size_(size), root_(BuildTree(0, size_ - 1)) {} int QueryTree(int start, int end) { return QueryTree(root_, start, end); } void ModifyTree(int index, int value) { return ModifyTree(root_, index, value); } private: STNode* BuildTree(int start, int end) { STNode* node = new STNode(start, end); if (start == end) { return node; } int mid = start + (end - start) / 2; node-\u003eleft = BuildTree(start, mid); node-\u003eright = BuildTree(mid + 1, end); return node; } int QueryTree(STNode* node, int start, int end) { if (node-\u003estart == start \u0026\u0026 node-\u003eend == end) { return node-\u003esum; } int left_sum = 0; int right_sum = 0; int mid = node-\u003estart + (node-\u003eend - node-\u003estart) / 2; if (start \u003c= mid) { left_sum = QueryTree(node-\u003eleft, start, std::min(mid, end)); } if (end \u003e mid) { right_sum = QueryTree(node-\u003eright, std::max(start, mid + 1), end); } return left_sum + right_sum; } void ModifyTree(STNode* node, int index, int value) { if (node-\u003estart == node-\u003eend \u0026\u0026 node-\u003estart == index) { node-\u003esum = value; return; } if (node-\u003eleft-\u003eend \u003e= index) { ModifyTree(node-\u003eleft, index, value); } else { ModifyTree(node-\u003eright, index, value); } node-\u003esum = node-\u003eleft-\u003esum + node-\u003eright-\u003esum; } int size_; STNode* root_; }; class Solution { public: std::vector\u003cint\u003e countOfSmallerNumberII(std::vector\u003cint\u003e\u0026 A) { STree* tree = new STree(10001); std::vector\u003cint\u003e B(10001); std::vector\u003cint\u003e result; for (int\u0026 i : A) { if (i == 0) { result.push_back(0); } else { result.push_back(tree-\u003eQueryTree(0, i - 1)); } ++B[i]; tree-\u003eModifyTree(i, B[i]); } return result; } };","lintcode-249-count-of-smaller-number-before-itself-1#Lintcode 249 Count of Smaller Number before itself":"Lintcode 249 Count of Smaller Number before itself n为数组长度，k为数组最大值\n暴力求解O(n^2) 树状数组/线段树O(nlogk) class BinaryIndexTree { public: BinaryIndexTree(int size) { size_ = size; a_.assign(size_ + 1, 0); } // B[index] += val void Add(int index, int val) { ++index; while (index \u003c= size_) { a_[index] += val; index += Lowbit(index); } } // B[0] + ... + B[index] int PrefixSum(int index) { ++index; int ret = 0; while (index \u003e 0) { ret += a_[index]; index -= Lowbit(index); } return ret; } private: int Lowbit(int x) { return x \u0026 (-x); } int size_; std::vector\u003cint\u003e a_; }; class Solution { public: std::vector\u003cint\u003e countOfSmallerNumberII(std::vector\u003cint\u003e\u0026 A) { std::vector\u003cint\u003e ans; int max_a = -1; for (int\u0026 i : A) { max_a = std::max(max_a, i); } BinaryIndexTree* tree = new BinaryIndexTree(max_a + 1); for (int\u0026 i : A) { if (i == 0) { ans.push_back(0); } else { ans.push_back(tree-\u003ePrefixSum(i - 1)); } tree-\u003eAdd(i, 1); // B[i] += 1 } return ans; } };","lowbit-的两个含义#Lowbit 的两个含义":"e.g. Lowbit(4) = 4:\n从A[4]出发向左共四个数的SUM 从C[4]搭出去梯子的长度（长度为4: A[5], A[6], A[7], A[8]），C[4]的值会影响到C[8]","materials#Materials":"segment_tree.pdf binary_index_tree.pdf","modify-range-max-ologn#Modify: range-max (O(logn))":"void modify(SegmentTreeNode* root, int index, int value) { // if (root-\u003estart == root-\u003eend) { // if (root-\u003estart == root-\u003eend \u0026\u0026 root-\u003eend == index) { if (root-\u003estart == index \u0026\u0026 root-\u003eend == index) { root-\u003emax = value; return; } int mid = root-\u003estart + (root-\u003eend - root-\u003estart) / 2; if (root-\u003estart \u003c= index \u0026\u0026 index \u003c= mid) { modify(root-\u003eleft_child, index, value); } if (mid \u003c index \u0026\u0026 index \u003c= root-\u003eend) { modify(root-\u003eright_child, index, value); } // non-leaf always has two children root-\u003emax = std::max(root-\u003eleft_child-\u003emax, root-\u003eright_child-\u003emax); }","node-range-max#Node: range-max":"struct SegmentTreeNode { SegmentTreeNode(int start, int end, int max) : start(start), end(end), max(max), left_child(nullptr), right_child(nullptr) {} int start; int end; int max; SegmentTreeNode* left_child; SegmentTreeNode* right_child; };","query-range-max-ologn#Query: range-max (O(logn))":"[start, end] 包含于 [node-\u003estart, node-\u003eend]\nint query(SegmentTreeNode* root, int left, int right) { if (left == root-\u003estart \u0026\u0026 right == root-\u003eend) { return root-\u003emax; } int mid = root-\u003estart + (root-\u003eend - root-\u003estart) / 2; int left_max = 0xcfcfcfcf; // some default minimum integer int right_max = 0xcfcfcfcf; // some default minimum integer if (left \u003c= mid) { if (mid \u003c right) { left_max = query(root-\u003eleft_child, left, mid); } else { left_max = query(root-\u003eleft_child, left, right); } } if (mid \u003c right) { if (left \u003c= mid) { right_max = query(root-\u003eright_child, mid + 1, right); } else { right_max = query(root-\u003eright_child, left, right); } } return std::max(left_max, right_max); }","树状数组的程序实现-lintcode-840-range-sum#树状数组的程序实现: Lintcode 840: Range Sum":"Lintcode 840 Range Sum /** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */ class NumArray { public: NumArray(std::vector\u003cint\u003e\u0026 nums) { // both of them have to be assigned to 0 arr_.assign(nums.size(), 0); bit_.assign(nums.size() + 1, 0); for (int i = 0; i \u003c nums.size(); ++i) { update(i, nums[i]); } } void update(int index, int value) { int delta = value - arr_[index]; arr_[index] = value; // Lowbit(i) 此时是Lowbit的第二个含义，即搭出去的梯子 for (int i = index + 1; i \u003c= arr_.size(); i = i + Lowbit(i)) { // bit_[i] 即C数组，包含了Lowbit的第二个含义（bit_[i]记录了Lowbit(i)个值的Sum） bit_[i] += delta; } } int sumRange(int left, int right) { return GetPrefixSum(right) - GetPrefixSum(left - 1); } private: int GetPrefixSum(int index) { int sum = 0; // Lowbit(i) 此时是Lowbit的第二个含义，即搭出去的梯子 for (int i = index + 1; i \u003e 0; i = i - Lowbit(i)) { sum += bit_[i]; } return sum; } inline int Lowbit(int x) { return x \u0026 (-x); } std::vector\u003cint\u003e arr_, bit_; };"},"title":"Segment Tree \u0026 Binary Index Tree"},"/blog/sweep_line_algorithm/":{"data":{"":"使用一根假想的线，在坐标轴上水平或垂直移动 像扫描一样经过数据并处理的算法 Take Aways: 注意点有交集的时候: case 1(merge interval): start = -1, end = 1 (or comp: left[1] \u003e right[1]) case 2(meeting room II, employee free time): start = 1, end = -1 (or comp: left[1] \u003c right[1]) sort all boundary sort first element first, then sort the second element watch on left == right scenarios Prefix Sum Sweep Line Algorithm Greedy - Prev End Greedy - Simulation","-approach-2-sweep-line-ac#!!! Approach 2: Sweep Line: AC":"when the prefix sum cannot identify the specific index, we need use sweep line class Solution { public: std::vector\u003cstd::vector\u003clong long\u003e\u003e splitPainting(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 A) { std::map\u003cint, long long\u003e mp; for (auto\u0026 a : A) { mp[a[0]] += a[2]; mp[a[1]] -= a[2]; } std::vector\u003cstd::vector\u003clong long\u003e\u003e result; int prev_key = -1; // None long long color = 0; // temp_sum: color mix accumulation for (auto\u0026 [key, _] : mp) { // std::cout \u003c\u003c \"key: \" \u003c\u003c key \u003c\u003c \" value: \" \u003c\u003c _ \u003c\u003c \" mp[prev_key]: \" \u003c\u003c mp[prev_key] \u003c\u003c std::endl; if (color != 0) { // if color == 0, means this part isn't paint result.push_back({prev_key, key, color}); } color += mp[key]; prev_key = key; } return result; } };","advanced-approaches#Advanced Approaches":"","approach-1-greedy#Approach 1: Greedy":"intervals排序，左边界越小越优先 前一个区间的右边界在后一个区间的左边界之后 == 两区间合并 class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e merge(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { // corner case std::vector\u003cstd::vector\u003cint\u003e\u003e result; if (intervals.size() == 0) return result; // intervals排序，左边界越小越优先 auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] \u003c right[0]) { return true; } return false; }; std::sort(intervals.begin(), intervals.end(), comp); // 前一个区间的右边界在后一个区间的左边界之后 == 两区间合并 for (int i = 0; i \u003c intervals.size(); ++i) { int left = intervals[i][0]; int right = intervals[i][1]; if (result.size() == 0 || result[result.size() - 1][1] \u003c left) { result.push_back(intervals[i]); } else { result[result.size() - 1][1] = std::max(result[result.size() - 1][1], right); } } return result; } };","approach-1-greedy---prev-end#Approach 1: Greedy - prev end":"sort based on the end use prev_end as a bar iterate class Solution { public: int findMinArrowShots(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 points) { if (points.size() == 0) return 0; auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[1] == right[1]) return left[0] \u003c right[0]; return left[1] \u003c right[1]; }; std::sort(points.begin(), points.end(), comp); int prev_end = points[0][1]; // !!! initialize the prev_end int arrow_count = 1; // initialize the first result // start from the second element for (int i = 1; i \u003c points.size(); ++i) { if (points[i][0] \u003e prev_end) { ++arrow_count; prev_end = points[i][1]; } } return arrow_count; } };","approach-1-greedy---prev-end---sort-by-end#Approach 1: Greedy - prev end - Sort by end":"class Solution { public: int eraseOverlapIntervals(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { if (intervals.size() == 0) return 0; auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[1] == right[1]) return left[0] \u003c right[0]; return left[1] \u003c right[1]; }; std::sort(intervals.begin(), intervals.end(), comp); int prev_end = intervals[0][1]; // !!! use prev strategy here int count_overlap = 0; // initialize the result for (int i = 1; i \u003c intervals.size(); ++i) { if (intervals[i][0] \u003c prev_end) { ++count_overlap; } else { prev_end = intervals[i][1]; } } return count_overlap; } };","approach-1-greedy---prev-end---sorty-by-end#Approach 1: Greedy - prev end - Sorty by end":"class Solution { public: bool canAttendMeetings(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { if (intervals.size() == 0) return true; auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[1] == right[1]) return left[0] \u003c right[0]; return left[1] \u003c right[1]; }; std::sort(intervals.begin(), intervals.end(), comp); int prev_end = intervals[0][1]; for (int i = 1; i \u003c intervals.size(); ++i) { if (intervals[i][0] \u003e= prev_end) { prev_end = intervals[i][1]; } else { return false; } } return true; } };","approach-1-greedy---prev-end-1#Approach 1: Greedy - prev end":"class Solution { public: int findLongestChain(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 pairs) { if (pairs.size() == 0) return 0; auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[1] == right[1]) return left[0] \u003c right[0]; return left[1] \u003c right[1]; }; std::sort(pairs.begin(), pairs.end(), comp); int prev_end = pairs[0][1]; int count_chain = 1; for (int i = 1; i \u003c pairs.size(); ++i) { if (pairs[i][0] \u003e prev_end) { ++count_chain; prev_end = pairs[i][1]; } } return count_chain; } };","approach-1-greedy-1#Approach 1: Greedy":"class Solution { public: int minMeetingRooms(vector\u003cvector\u003cint\u003e\u003e\u0026 logs) { std::vector\u003cint\u003e starts(logs.size(), 0); std::vector\u003cint\u003e ends(logs.size(), 0); for (int i = 0; i \u003c logs.size(); ++i) { starts[i] = logs[i][0]; ends[i] = logs[i][1]; } std::sort(starts.begin(), starts.end()); std::sort(ends.begin(), ends.end()); int rooms = 0; int ends_itr = 0; for (int i = 0; i \u003c starts.size(); ++i) { if (starts[i] \u003c ends[ends_itr]) { ++rooms; } else { ++ends_itr; } } return rooms; } };","approach-1-prefix-sum#Approach 1: Prefix Sum":"class Solution { public: bool isCovered(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 ranges, int left, int right) { // no corner case here // prefix sum std::vector\u003cint\u003e ps(52, 0); // it must be at least 52 here for (int i = 0; i \u003c ranges.size(); ++i) { int start = ranges[i][0]; int end = ranges[i][1]; ++ps[start]; --ps[end + 1]; // because it's inclusive, we have to include end } for (int i = 1; i \u003c ps.size(); ++i) { ps[i] += ps[i - 1]; } for (int i = left; i \u003c= right; ++i) { if (ps[i] \u003c 1) return false; } return true; } };","approach-1-prefix-sum-1#Approach 1: Prefix Sum":"class Solution { public: std::vector\u003cint\u003e getModifiedArray(int length, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 updates) { std::vector\u003cint\u003e nums(length + 1, 0); for (int i = 0; i \u003c updates.size(); ++i) { int start = updates[i][0]; int end = updates[i][1]; int ins = updates[i][2]; nums[start] += ins; nums[end + 1] -= ins; } for (int i = 1; i \u003c nums.size(); ++i) { nums[i] += nums[i - 1]; } return std::vector\u003cint\u003e(nums.begin(), nums.begin() + length); } };","approach-1-prefix-sum-2#Approach 1: Prefix Sum":"#define print(x) std::copy(x.begin(), x.end(), std::ostream_iterator(std::cout, \" \")); std::cout \u003c\u003c std::endl class Solution { public: int maxSumRangeQuery(vector\u003cint\u003e\u0026 nums, vector\u003cvector\u003cint\u003e\u003e\u0026 requests) { if (requests.size() == 0) return 0; std::vector\u003cint\u003e ps(nums.size() + 1, 0); for (int i = 0; i \u003c requests.size(); ++i) { int start = requests[i][0]; int end = requests[i][1]; ++ps[start]; // use accumulation instead of assign to 1 --ps[end + 1]; // same here } // 0, 1, 2, 3, 4, 5 // 1 -1 // 1 -1 // 1 -1 for (int i = 1; i \u003c ps.size(); ++i) { ps[i] += ps[i - 1]; } std::sort(nums.begin(), nums.end(), std::greater\u003cint\u003e()); std::sort(ps.begin(), ps.end() - 1, std::greater\u003cint\u003e()); // except the last element of prefix sum array long long mod = 1000000007; long long result = 0; for (int i = 0; i \u003c nums.size(); ++i) { result += (nums[i] % mod) * (ps[i] % mod); result %= mod; } return result % mod; } };","approach-1-prefix-sum-failed-in-corner-case#Approach 1: Prefix Sum: Failed in corner case":"Failded Corner Case: Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]] Output: [[1,4,12],[4,7,12]] #define print(x) std::copy(x.begin(), x.end(), std::ostream_iterator(std::cout, \" \")); std::cout \u003c\u003c std::endl class Solution { public: std::vector\u003cstd::vector\u003clong long\u003e\u003e splitPainting(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 segments) { std::vector\u003cstd::vector\u003clong long\u003e\u003e result; if (segments.size() == 0) return result; std::vector\u003cint\u003e v(100001, 0); for (auto\u0026 s : segments) { int start = s[0]; int end = s[1]; int color = s[2]; v[start] += color; v[end] -= color; } for (int i = 1; i \u003c v.size(); ++i) { v[i] += v[i - 1]; } print(v); // 0, 0, 1, 1, 2, 2, 1, 0, 0 int left, right; int pre_mix = 0; for (int i = 0; i \u003c v.size() - 1; ++i) { if (v[i] == pre_mix) { // leading 0 or unchanged mix color continue; } if (pre_mix == 0) { left = i; } else { result.push_back({left, i, v[i - 1]}); if (v[i] != 0) { left = i; } } pre_mix = v[i]; } return result; } };","approach-1-simulation---greedy#Approach 1: Simulation - Greedy":"class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e removeInterval(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals, std::vector\u003cint\u003e\u0026 to_be_removed) { std::vector\u003cstd::vector\u003cint\u003e\u003e result; if (intervals.size() == 0) return result; if (to_be_removed.size() == 0) return intervals; for (int i = 0; i \u003c intervals.size(); ++i) { // case 1 // there are no overlaps with to_be_removed if (intervals[i][1] \u003c to_be_removed[0] || intervals[i][0] \u003e to_be_removed[1]) { result.push_back(intervals[i]); } else { // case 2, 3, 4 // there is left overlap if (intervals[i][0] \u003c to_be_removed[0]) { result.push_back({intervals[i][0], to_be_removed[0]}); } // there is right overlap if (intervals[i][1] \u003e to_be_removed[1]) { result.push_back({to_be_removed[1], intervals[i][1]}); } } } return result; } };","approach-1-sweep-line-algorithm#Approach 1: Sweep Line Algorithm":"Similar to Merge Interval Pay attention to the intersect point, sort strategy class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e insert(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals, std::vector\u003cint\u003e\u0026 new_interval) { if (new_interval.size() == 0) return intervals; std::vector\u003cstd::vector\u003cint\u003e\u003e v; for (int i = 0; i \u003c intervals.size(); ++i) { int start = intervals[i][0]; int end = intervals[i][1]; v.push_back({start, 1}); v.push_back({end, -1}); } v.push_back({new_interval[0], 1}); v.push_back({new_interval[1], -1}); auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) return left[1] \u003e right[1]; // here must be \u003e return left[0] \u003c right[0]; }; std::sort(v.begin(), v.end(), comp); std::vector\u003cstd::vector\u003cint\u003e\u003e result; int temp_sum = 0; int left, right; for (int i = 0; i \u003c v.size(); ++i) { if (temp_sum == 0) { left = v[i][0]; } temp_sum += v[i][1]; if (temp_sum == 0) { right = v[i][0]; result.push_back({left, right}); } } return result; } };","approach-1-sweep-line-without-heap#Approach 1: Sweep Line: without heap":"class Solution { public: std::vector\u003cInterval\u003e employeeFreeTime(std::vector\u003cstd::vector\u003cInterval\u003e\u003e schedule) { std::vector\u003cInterval\u003e result; if (schedule.size() == 0) return result; std::vector\u003cstd::vector\u003cint\u003e\u003e v; for (int i = 0; i \u003c schedule.size(); ++i) { for (int j = 0; j \u003c schedule[i].size(); ++j) { v.push_back({schedule[i][j].start, 1}); v.push_back({schedule[i][j].end, -1}); } } auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) return left[1] \u003c right[1]; return left[0] \u003c right[0]; }; std::sort(v.begin(), v.end(), comp); int temp_sum = 0; int left = INT_MIN, right = INT_MAX; for (int i = 0; i \u003c v.size(); ++i) { if (temp_sum == 0) { left = v[i][0]; if (right != INT_MAX \u0026\u0026 left != right) { // left != right is the corner case result.push_back(Interval(right, left)); // right, left } } temp_sum += v[i][1]; if (temp_sum == 0) { right = v[i][0]; } } return result; } };","approach-1failed-sweep-line-algorithm-without-heap#Approach 1(Failed): Sweep Line Algorithm without heap":"it’s not concise compared to the prefix sum version, not AC class Solution { public: int meetRequirement(int n, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 lights, std::vector\u003cint\u003e\u0026 requirement) { // no corner case std::vector\u003cstd::vector\u003cint\u003e\u003e v; for (int i = 0; i \u003c lights.size(); ++i) { int position = lights[i][0]; int range = lights[i][1]; v.push_back({std::max(0, position - range), 1}); v.push_back({std::min(n - 1, position + range), -1}); } auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) return left[1] \u003e right[1]; return left[0] \u003c right[0]; // the intersection point should be inclusive }; std::sort(v.begin(), v.end(), comp); for (int i = 0; i \u003c v.size(); ++i) { std::cout \u003c\u003c \"point: \" \u003c\u003c v[i][0] \u003c\u003c \" type: \" \u003c\u003c v[i][1] \u003c\u003c std::endl; } std::cout \u003c\u003c std::endl; int temp_sum = 0; int left, right; std::vector\u003cint\u003e light_sum(requirement.size(), 0); for (int i = 0; i \u003c v.size(); ++i) { if (temp_sum == 0) { left = v[i][0]; } temp_sum += v[i][1]; light_sum[v[i][0]] = std::max(light_sum[v[i][0]], temp_sum); if (temp_sum == 0) { right = v[i][0]; } } for (auto e : light_sum) { std::cout \u003c\u003c e \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; int result = 0; for (int i = 0; i \u003c requirement.size(); ++i) { if (light_sum[i] \u003e= requirement[i]) ++result; } return result; } };","approach-2-dp---sort-by-start#Approach 2: DP - Sort by start":"class Solution { public: int eraseOverlapIntervals(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { } };","approach-2-dp---sort-by-start-1#Approach 2: DP - Sort by start":"class Solution { public: int findLongestChain(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 pairs) { } };","approach-2-prefix-sum#Approach 2: Prefix Sum":"if the absolute value between right and left is large, the performance will be bad. // Approach 1: prefix sum class Solution { public: int minMeetingRooms(vector\u003cvector\u003cint\u003e\u003e\u0026 logs) { if (logs.size() == 0) return 0; std::vector\u003cint\u003e v(1000001, 0); for (int i = 0; i \u003c logs.size(); ++i) { int left = logs[i][0]; int right = logs[i][1]; ++v[left]; --v[right]; } for (int i = 1; i \u003c v.size(); ++i) { v[i] = v[i - 1] + v[i]; } return *max_element(v.begin(), v.end()); } };","approach-2-prefix-sum-1#Approach 2: Prefix Sum":"class Solution { public: int meetRequirement(int n, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 lights, std::vector\u003cint\u003e\u0026 requirement) { // no coner case here // prefix sum std::vector\u003cint\u003e nums(n + 1, 0); // size has to be n + 1 for (int i = 0; i \u003c lights.size(); ++i) { int position = lights[i][0]; int range = lights[i][1]; ++nums[std::max(0, position - range)]; --nums[std::min(n - 1, position + range) + 1]; // add 1 for the ending index } for (int i = 1; i \u003c nums.size(); ++i) { nums[i] = nums[i - 1] + nums[i]; // this version of prefix sum doens't need to have a leading 0 } int result = 0; for (int i = 0; i \u003c requirement.size(); ++i) { if (nums[i] \u003e= requirement[i]) { ++result; } } return result; } };","approach-2-sweep-line-algorithm#Approach 2: Sweep Line Algorithm":"similar to prefix_sum class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e merge(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { std::vector\u003cstd::vector\u003cint\u003e\u003e result; if (intervals.size() == 0) return result; std::vector\u003cstd::vector\u003cint\u003e\u003e boundaries; for (int i = 0; i \u003c intervals.size(); ++i) { boundaries.push_back({intervals[i][0], -1}); boundaries.push_back({intervals[i][1], 1}); } // !!! sort on first element, then sort on second elemen auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) { return left[1] \u003c right[1]; } return left[0] \u003c right[0]; }; std::sort(boundaries.begin(), boundaries.end(), comp); int is_matched = 0; int left = 0, right = 0; for (int i = 0; i \u003c boundaries.size(); ++i) { if (is_matched == 0) { left = boundaries[i][0]; } is_matched += boundaries[i][1]; if (is_matched == 0) { right = boundaries[i][0]; result.push_back({left, right}); } } return result; } };","approach-2-sweep-line-algorithm-1#Approach 2: Sweep Line Algorithm":"start of remove index is -1, end is 1 four senarios: none overlaps left overlap right overlap left and right overlaps think through: decide left and then right to cover all scenarios handle corner case: start of interval == the start of remove. let value != 0\nclass Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e removeInterval(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals, std::vector\u003cint\u003e\u0026 to_be_removed) { std::map\u003cint, int\u003e v; for (auto\u0026 i : intervals) { ++v[i[0]]; --v[i[1]]; } --v[to_be_removed[0]]; ++v[to_be_removed[1]]; std::vector\u003cstd::vector\u003cint\u003e\u003e result; int temp_sum = 0; int left, right; for (auto\u0026 [key, value] : v) { temp_sum += value; if (temp_sum \u003e 0) { left = key; } // handle corner case: start of interval == the start of remove. let value != 0 if (temp_sum == 0 \u0026\u0026 value != 1 \u0026\u0026 value != 0) { right = key; result.push_back({left, right}); } } return result; } };","approach-2-sweep-line-with-heap#Approach 2: Sweep Line: with heap":"class Solution { public: std::vector\u003cInterval\u003e employeeFreeTime(std::vector\u003cstd::vector\u003cInterval\u003e\u003e schedule) { std::vector\u003cInterval\u003e result; if (schedule.size() == 0) return result; auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) return left[1] \u003c right[1]; return left[0] \u003c right[0]; }; std::multiset\u003cstd::vector\u003cint\u003e, decltype(comp)\u003e heap(comp); for (int i = 0; i \u003c schedule.size(); ++i) { for (int j = 0; j \u003c schedule[i].size(); ++j) { heap.insert({schedule[i][j].start, 1}); heap.insert({schedule[i][j].end, -1}); } } int count = 0; while (heap.size() \u003e 1) { std::vector\u003cint\u003e left = *heap.begin(); heap.erase(heap.begin()); std::vector\u003cint\u003e right = *heap.begin(); count += left[1]; if (left[1] == -1 \u0026\u0026 right[1] == 1 \u0026\u0026 count == 0 \u0026\u0026 left[0] != right[0]) { result.push_back(Interval(left[0], right[0])); } } return result; } };","approach-3-sweep-line-without-heap#Approach 3: Sweep Line without Heap":"class Solution { public: int minMeetingRooms(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 logs) { if (logs.size() == 0) return 0; std::vector\u003cstd::vector\u003cint\u003e\u003e v; for (int i = 0; i \u003c logs.size(); ++i) { v.push_back({logs[i][0], 1}); v.push_back({logs[i][1], -1}); } auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) { return left[1] \u003c right[1]; } return left[0] \u003c right[0]; }; std::sort(v.begin(), v.end(), comp); int left, right; int temp_sum = 0; int answer = -1; for (int i = 0; i \u003c v.size(); ++i) { // if (temp_sum == 0) { // left = v[i][0]; // } temp_sum += v[i][1]; answer = std::max(answer, temp_sum); // compete the maximum number of overlap layers // if (temp_sum == 0) { // right = v[i][0]; // } } return answer; } };","approach-4-sweep-line-with-heap#Approach 4: Sweep Line with Heap":"use multiset to handle same key inserted class Solution { public: int minMeetingRooms(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 logs) { if (logs.size() == 0) return 0; auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) return left[1] \u003c right[1]; return left[0] \u003c right[0]; }; std::multiset\u003cstd::vector\u003cint\u003e, decltype(comp)\u003e heap(comp); // multiset, to handle same key for (int i = 0; i \u003c logs.size(); ++i) { heap.insert({logs[i][0], 1}); heap.insert({logs[i][1], -1}); } int result = 0; int temp_sum = 0; for (auto it = heap.begin(); it != heap.end(); ++it) { temp_sum += it-\u003eat(1); // it-\u003eat(index) result = std::max(result, temp_sum); } return result; } };","approach-sweep-line-with-heap#Approach: Sweep Line with heap":"#define print(x) std::copy(x.begin(), x.end(), std::ostream_iterator(std::cout, \" \")); std::cout \u003c\u003c std::endl class MyCalendarTwo { public: MyCalendarTwo() {} bool book(int start, int end) { v.insert({start, 1}); v.insert({end, -1}); // std::cout \u003c\u003c \"start: \" \u003c\u003c start \u003c\u003c \" end: \" \u003c\u003c end \u003c\u003c std::endl; // for (auto e : v) { // std::cout \u003c\u003c e[0] \u003c\u003c \" \" \u003c\u003c e[1] \u003c\u003c std::endl; // } if (IsValid()) { return true; } else { // Approach 1: with find_if // auto index = std::find_if(v.begin(), v.end(), [\u0026start](const auto\u0026 first) { // return first[0] == start \u0026\u0026 first[1] == 1; // }); // v.erase(index); // index = std::find_if(v.begin(), v.end(), [\u0026end](const auto\u0026 first) { // return first[0] == end \u0026\u0026 first[1] == -1; // }); // v.erase(index); // Approach 2: with find v.erase(v.find({start, 1})); v.erase(v.find({end, -1})); return false; } } bool IsValid() { // check if there is triple booking int count = 0; for (auto it = v.begin(); it != v.end(); ++it) { count += it-\u003eat(1); if (count \u003e= 3) return false; } return true; } std::multiset\u003cstd::vector\u003cint\u003e\u003e v; }","leetcode-1272-remove-interval#Leetcode 1272. Remove Interval":"Leetcode 1272. Remove Interval","leetcode-1589-maximum-sum-obtained-of-any-permutation#Leetcode 1589. Maximum Sum Obtained of Any Permutation":"","leetcode-1893-check-if-all-the-integers-in-a-range-are-covered#Leetcode 1893. Check if All the Integers in a Range Are Covered":"Leetcode 1893. Check if All the Integers in a Range Are Covered","leetcode-1943-describe-the-painting#Leetcode 1943. Describe the Painting":"Leetcode 1943. Describe the Painting","leetcode-2158-amount-of-new-area-painted-each-day#Leetcode 2158. Amount of New Area Painted Each Day":"Leetcode 2158. Amount of New Area Painted Each Day class Solution { public: std::vector\u003cint\u003e amountPainted(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 paint) { } };","leetcode-2237-count-positions-on-street-with-required-brightness#Leetcode 2237. Count Positions on Street With Required Brightness":"Leetcode 2237. Count Positions on Street With Required Brightness","leetcode-252-meeting-rooms#Leetcode 252. Meeting Rooms":"Leetcode 252. Meeting Rooms","leetcode-253-meeting-rooms-ii#Leetcode 253. Meeting Rooms II":"Leetcode 253. Meeting Rooms II","leetcode-370-range-addition#Leetcode 370. Range Addition":"Leetcode 370. Range Addition","leetcode-435-non-overlapping-intervals#Leetcode 435. Non-overlapping Intervals":"Leetcode 435. Non-overlapping Intervals","leetcode-452-minimum-number-of-arrows-to-burst-ballons#Leetcode 452. Minimum Number of Arrows to Burst Ballons":"Leetcode 452. Minimum Number of Arrows to Burst Ballons","leetcode-56-merge-intervals#Leetcode 56. Merge Intervals":"Leetcode 56. Merge Intervals","leetcode-56-merge-intervals-1#Leetcode 56. Merge Intervals":"Leetcode 56. Merge Intervals class Solution0 { public: std::vector\u003cstd::vector\u003cint\u003e\u003e merge(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { std::vector\u003cstd::vector\u003cint\u003e\u003e result; if (intervals.size() == 0) return result; std::vector\u003cstd::vector\u003cint\u003e\u003e boundaries; for (int i = 0; i \u003c intervals.size(); ++i) { boundaries.push_back({intervals[i][0], 1}); boundaries.push_back({intervals[i][1], -1}); } // !!! sort on first element, then sort on second elemen auto comp = [](const auto\u0026 left, const auto\u0026 right) { if (left[0] == right[0]) { return left[1] \u003e right[1]; } return left[0] \u003c right[0]; }; std::sort(boundaries.begin(), boundaries.end(), comp); int is_matched = 0; int left = 0, right = 0; for (int i = 0; i \u003c boundaries.size(); ++i) { if (is_matched == 0) { left = boundaries[i][0]; } is_matched += boundaries[i][1]; if (is_matched == 0) { right = boundaries[i][0]; result.push_back({left, right}); } } return result; } }; class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e merge(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals) { vector\u003cvector\u003cint\u003e\u003e result; if (intervals.size() == 0) return result; sort(intervals.begin(), intervals.end()); vector\u003cint\u003e\u0026 curr = intervals[0]; for (int i = 1; i \u003c intervals.size(); ++i) { vector\u003cint\u003e\u0026 inter = intervals[i]; if (curr[1] \u003c inter[0]) { result.push_back(curr); curr = inter; } else { curr[1] = max(curr[1], inter[1]); } } result.push_back(curr); return result; } };","leetcode-57-insert-interval#Leetcode 57. Insert Interval":"Leetcode 57. Insert Interval","leetcode-57-insert-interval-1#Leetcode 57. Insert Interval":"Leetcode 57. Insert Intervals class Solution0 { public: std::vector\u003cstd::vector\u003cint\u003e\u003e insert(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals, std::vector\u003cint\u003e\u0026 new_interval) { vector\u003cvector\u003cint\u003e\u003e result; if (intervals.size() == 0) return {new_interval}; vector\u003cvector\u003cint\u003e\u003e boundaries; for (auto\u0026 v : intervals) { boundaries.push_back({v[0], 1}); boundaries.push_back({v[1], -1}); } boundaries.push_back({new_interval[0], 1}); boundaries.push_back({new_interval[1], -1}); auto comp = [](auto const\u0026 left, auto const\u0026 right) { if (left[0] == right[0]) return left[1] \u003e right[1]; return left[0] \u003c right[0]; }; sort(boundaries.begin(), boundaries.end(), comp); int temp_sum = 0; int left; for (int i = 0; i \u003c boundaries.size(); ++i) { if (temp_sum == 0) { left = boundaries[i][0]; } temp_sum += boundaries[i][1]; if (temp_sum == 0) { result.push_back({left, boundaries[i][0]}); } } return result; } }; class Solution1 { public: std::vector\u003cstd::vector\u003cint\u003e\u003e insert(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals, std::vector\u003cint\u003e\u0026 new_interval) { std::vector\u003cstd::vector\u003cint\u003e\u003e result; for (auto\u0026 i : intervals) { if (i[1] \u003c new_interval[0]) { result.push_back(i); } else if (new_interval[1] \u003c i[0]){ result.push_back(new_interval); new_interval = i; } else if (new_interval[1] \u003e= i[0]) { new_interval[0] = min(new_interval[0], i[0]); new_interval[1] = max(new_interval[1], i[1]); } } result.push_back(new_interval); return result; } }; // review better class Solution { public: std::vector\u003cstd::vector\u003cint\u003e\u003e insert(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 intervals, std::vector\u003cint\u003e\u0026 new_interval) { vector\u003cvector\u003cint\u003e\u003e result; // the given intervals is sorted bool added = false; for (int i = 0; i \u003c intervals.size(); ++i) { vector\u003cint\u003e\u0026 inter = intervals[i]; // check if exist overlapping int max_start = max(inter[0], new_interval[0]); int min_end = min(inter[1], new_interval[1]); if (max_start \u003c= min_end) { new_interval[0] = min(new_interval[0], inter[0]); new_interval[1] = max(new_interval[1], inter[1]); } else { if (new_interval[1] \u003c inter[0] \u0026\u0026 added == false) { result.push_back(new_interval); added = true; } result.push_back(inter); } } if (added == false) { result.push_back(new_interval); } return result; } };","leetcode-646-maximum-length-of-pair-chain#Leetcode 646. Maximum Length of Pair Chain":"Leetcode 646. Maximum Length of Pair Chain","leetcode-731-my-calendar-ii#Leetcode 731. My Calendar II":"Leetcode 731. My Calendar II","leetcode-759-employee-free-time#Leetcode 759. Employee Free Time":"Leetcode 759. Employee Free Time","leetcode-discuss-study-guide#Leetcode Discuss: Study Guide:":"Leetcode discuss/study guide","skip-leetcode-1674-minimum-moves-to-make-array-complementary#[Skip] Leetcode 1674. Minimum Moves to Make Array Complementary":"class Solution { public: int minMoves(std::vector\u003cint\u003e\u0026 nums, int limit) { } };"},"title":"Sweep Line Algorithm"},"/blog/thread_vs_process/":{"data":{"":"The difference between thread and process.\nA thread is a lightweight process that shares the same address space as other threads in the same process.\nA process is a heavyweight unit of execution that has its own address space, memory, and resources.\nThreads are typically used to improve the performance of an application by allowing multiple tasks to be executed concurrently.\nProcesses are typically used to improve the security of an application by isolating different tasks from each other.\nFeature Thread Process Address Space Shares the same address space as other threads in the same process Has its own address space Memory Shares the same memory as other threads in the same process Has its own memory Resources Shares the same resources as other threads in the same process Has its own resources Performance Typically better than process Typically worse than threads Security Less secure than processes More secure than threads"},"title":"Thread vs Process"},"/blog/z-function/":{"data":{"":"","example-z-algo#Example: Z Algo":"Leetcode 3036. Number of Subarrays That Match a Pattern II the Z-function for a string s is an array where the ith element z[i] represents the length of the longest substring starting from i that is also a prefix of s.","example-z-function#Example: Z Function":"Leetcode 3031. Minimum Time to Revert Word to Initial State II class Solution { public: int minimumTimeToInitialState(string word, int k) { // z function auto z = z_function(word); // auto z = z_function_trivial(word); for (int i = k; i \u003c word.size(); i += k) { // if (word.substr(i, word.size() - i) == word.substr(0, word.size() - i)) // return i / k; if (z[i] == word.size() - i) return i / k; } return ceil((double)word.size() / k); } vector\u003cint\u003e z_function(const string \u0026s) { int n = s.size(); vector\u003cint\u003e z(n); z[0] = n; for (int i = 1, l = 0, r = 0; i \u003c n; i++) { if (i \u003c= r) z[i] = min(z[i - l], r - i + 1); for (int \u0026j = z[i]; i + j \u003c n \u0026\u0026 s[j] == s[i + j]; j++); if (z[i] \u003e r - i + 1) l = i, r = i + z[i] - 1; } return z; } vector\u003cint\u003e z_function_trivial(string s) { int n = s.size(); vector\u003cint\u003e z(n); for (int i = 1; i \u003c n; i++) { while (i + z[i] \u003c n \u0026\u0026 s[z[i]] == s[i + z[i]]) { z[i]++; } } return z; } };","z-algo-template#Z Algo template":"vector\u003cint\u003e ZAlgo(const string\u0026 input) { vector\u003cint\u003e Z(input.size()); int left = 0; int right = 0; for (int k = 1; k \u003c input.size(); k++) { if (k \u003e right) { left = right = k; while (right \u003c input.size() \u0026\u0026 input[right] == input[right - left]) { right++; } Z[k] = right - left; right--; } else { // we are operating inside box int k1 = k - left; // if value does not stretches till right bound then just copy it. if (Z[k1] \u003c right - k + 1) { Z[k] = Z[k1]; } else { // otherwise try to see if there are more matches. left = k; while (right \u003c input.size() \u0026\u0026 input[right] == input[right - left]) { right++; } Z[k] = right - left; right--; } } } return Z; } };","z-function-template#Z function template":"vector\u003cint\u003e z_function(const string \u0026s) { int n = s.size(); vector\u003cint\u003e z(n); z[0] = n; for (int i = 1, l = 0, r = 0; i \u003c n; i++) { if (i \u003c= r) z[i] = min(z[i - l], r - i + 1); for (int \u0026j = z[i]; i + j \u003c n \u0026\u0026 s[j] == s[i + j]; j++); if (z[i] \u003e r - i + 1) l = i, r = i + z[i] - 1; } return z; }"},"title":"Z Algorithm"},"/docs/":{"data":{"":"This is a demo of the theme’s documentation layout.","hello-world#Hello, World!":"main.gopackage main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") }"},"title":"Documentation"},"/docs/first-page/":{"data":{"":"A simple demo page."},"title":"Demo Page"},"/docs/folder/":{"data":{"":"Pages can be organized into folders."},"title":"Folder"},"/docs/folder/leaf/":{"data":{"":"This page is under a folder."},"title":"Leaf Page"}}